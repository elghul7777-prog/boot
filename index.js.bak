import 'dotenv/config';
import { Telegraf, Markup } from 'telegraf';
import yts from 'yt-search';
import crypto from 'crypto';
import axios from 'axios';
import Jimp from 'jimp';
import fs from 'fs';
import { fileURLToPath } from 'url';
import CryptoJS from 'crypto-js';
import fetch from 'node-fetch';
import * as cheerio from 'cheerio';
import WebSocket from "ws";
import path from 'path';
import { fileTypeFromBuffer } from "file-type";
import FormData from "form-data";
import { exec } from 'child_process';
import { mohnd } from "./mohnd.js";
import { Readable } from 'stream'
import sharp from 'sharp'
import { performance } from "perf_hooks";
import { ogmp3 } from "./lib/youtubedl.js"; 
import { webp2png } from "./lib/webp2mp4.js";
import { webp2mp4 } from "./lib/webp2mp4.js";
import { ffmpeg } from "./lib/converter.js";
import  uploadFile  from "./lib/uploadFile.js";
import { ephoto } from "./lib/ephoto.js";
import translate from "@vitalets/google-translate-api";
import chalk from "chalk";
import setupAudio from "./audio.js";
import { musicallydown } from "./lib/tiktok.js"; 
import  uploadImage  from "./lib/uploadImage.js";
import ffmpegStatic from "ffmpeg-static";
import ytdl from "ytdl-core";
import { setupHeadersCommand } from './tiktok.js';
import { setupTiktokCommand } from './T.js';

const bot = new Telegraf(process.env.BOT_TOKEN);

//=============
setupHeadersCommand(bot);
setupAudio(bot);
setupTiktokCommand(bot);
const OWNER_ID = ['7708820857','7819888120','7572308415']
const owners = ['7708820857','7819888120','7572308415']
// Ø­Ø· Ø§Ù„Ø§ÙŠ Ø¯ÙŠ Ø¨ØªØ§Ø¹Ùƒ Ø§Ù†Øª (Ø¹Ù„Ø´Ø§Ù† Ø¨Ø³ Ø§Ù„Ù…Ø·ÙˆØ± ÙŠÙ‚Ø¯Ø± ÙŠØ³ØªØ®Ø¯Ù…Ù‡)
const developers = ['7708820857','7819888120','7572308415']

// ====== Sessions ===================
  
// âš¡ ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
global.db = {
  users: {},
  chats: {},
  settings: {}
};

function isNumber(x) {
  return typeof x === "number" && !isNaN(x);
}

// ğŸ› ï¸ Ø¯Ø§Ù„Ø© initDatabase
function initDatabase(ctx, botId) {
  try {
    const sender = ctx.from.id;
    const chatId = ctx.chat.id;

    // ğŸ§‘ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    let user = global.db.users[sender];
    if (typeof user !== "object") global.db.users[sender] = {};
    user = global.db.users[sender];

    Object.assign(user, {
      chip: isNumber(user.chip) ? user.chip : 0,
      level: isNumber(user.level) ? user.level : 1,
      atm: isNumber(user.atm) ? user.atm : 0,
      fullatm: isNumber(user.fullatm) ? user.fullatm : 0,
      bank: isNumber(user.bank) ? user.bank : 0,
      health: isNumber(user.health) ? user.health : 100,
      potion: isNumber(user.potion) ? user.potion : 0,
      trash: isNumber(user.trash) ? user.trash : 0,
      wood: isNumber(user.wood) ? user.wood : 0,
      rock: isNumber(user.rock) ? user.rock : 0,
      string: isNumber(user.string) ? user.string : 0,
      petfood: isNumber(user.petfood) ? user.petfood : 0,
      emerald: isNumber(user.emerald) ? user.emerald : 0,
      diamond: isNumber(user.diamond) ? user.diamond : 0,
      gold: isNumber(user.gold) ? user.gold : 0,
      iron: isNumber(user.iron) ? user.iron : 0,
      common: isNumber(user.common) ? user.common : 0,
      uncommon: isNumber(user.uncommon) ? user.uncommon : 0,
      mythic: isNumber(user.mythic) ? user.mythic : 0,
      legendary: isNumber(user.legendary) ? user.legendary : 0,
      umpan: isNumber(user.umpan) ? user.umpan : 0,
      ojekk: isNumber(user.ojekk) ? user.ojekk : 0,
      lastmisi: isNumber(user.lastmisi) ? user.lastmisi : 0,
      premium: user.premium || false,
      premiumTime: isNumber(user.premiumTime) ? user.premiumTime : 0
    });

    // ğŸ˜ï¸ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø´Ø§Øª
    let chats = global.db.chats[chatId];
    if (typeof chats !== "object") global.db.chats[chatId] = {};
    chats = global.db.chats[chatId];

    Object.assign(chats, {
      welcome: "welcome" in chats ? chats.welcome : false,
      goodbye: "goodbye" in chats ? chats.goodbye : false
    });

    // âš™ï¸ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    let setting = global.db.settings[botId];
    if (typeof setting !== "object") global.db.settings[botId] = {};
    setting = global.db.settings[botId];

    Object.assign(setting, {
      anticall: "anticall" in setting ? setting.anticall : false,
      status: isNumber(setting.status) ? setting.status : 0,
      autobio: "autobio" in setting ? setting.autobio : false,
      autoread: "autoread" in setting ? setting.autoread : false,
      onlygrub: "onlygrub" in setting ? setting.onlygrub : true,
      onlypc: "onlypc" in setting ? setting.onlypc : false
    });

  } catch (err) {
    console.error("Database init error:", err);
  }
}

export { initDatabase };
// =============================

// ğŸ©¸ Function: WebP â†’ MP4

global.db = global.db || {};
global.db.users = global.db.users || {};

// =============================
// Anti-Spam plugin
// by Mohnd + ChatGPT


export async function before(m, { isAdmin, isOwner, isBotAdmin, conn }) {
  const users = global.db.data.users;
  const chats = global.db.data.chats;

  // ØªØ®Ø·ÙŠ Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù„ÙŠ Ù…Ø´ Ù…Ø­ØªØ§Ø¬Ø© ÙÙ„ØªØ±Ø©
  if (
    !chats[m.chat]?.antiSpam || // Ù„Ùˆ Ø®Ø§ØµÙŠØ© AntiSpam Ù…Ø´ Ù…ÙØ¹Ù„Ø©
    m.isBaileys || // Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¨ÙˆØª Ù†ÙØ³Ù‡
    m.mtype === "protocolMessage" ||
    m.mtype === "pollUpdateMessage" ||
    m.mtype === "reactionMessage"
  )
    return;

  if (
    !m.msg ||
    !m.message ||
    m.key.remoteJid !== m.chat ||
    users[m.sender]?.banned ||
    chats[m.chat]?.isBanned
  )
    return;

  // Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø¨Ø§Ù… Ù„ÙƒÙ„ ÙŠÙˆØ²Ø±
  this.spam = this.spam || {};
  this.spam[m.sender] = this.spam[m.sender] || { count: 0, lastspam: 0 };

  const now = performance.now();
  const timeDifference = now - this.spam[m.sender].lastspam;

  if (timeDifference < 5000) {
    // Ø£Ù‚Ù„ Ù…Ù† 5 Ø«ÙˆØ§Ù†ÙŠ = Ù…Ù…ÙƒÙ† Spam
    this.spam[m.sender].count++;

    if (this.spam[m.sender].count >= 4 && !isOwner && !isAdmin) {
      // Ban Ù…Ø¤Ù‚Øª
      users[m.sender].banned = true;
      this.spam[m.sender].lastspam = now + 5000;

      // Ø¨Ø¹Ø¯ 10 Ø«ÙˆØ§Ù†ÙŠ Ø§Ù„Ø¨Ø§Ù† Ø¨ÙŠØªØ´Ø§Ù„
      setTimeout(() => {
        users[m.sender].banned = false;
        this.spam[m.sender].count = 0;

        if (conn) {
          conn.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        }
      }, 10000);

      // Ø±Ø³Ø§Ù„Ø© ØªÙˆØ¶ÙŠØ­
      return m.reply("âš ï¸ ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØªØŒ Ø§Ù†ØªØ¸Ø± 10 Ø«ÙˆØ§Ù†Ù ..");
    }
  } else {
    // Reset Ø§Ù„Ø¹Ø¯Ø§Ø¯
    this.spam[m.sender].count = 0;
  }

  this.spam[m.sender].lastspam = now;
}
// =============================


async function Uguu(buffer, filename) {
  try {
    const form = new FormData();
    form.append("files[]", buffer, { filename });
    const { data } = await axios.post("https://uguu.se/upload.php", form, {
      headers: form.getHeaders(),
    });

    if (data.files && data.files[0]) {
      return {
        name: data.files[0].name,
        url: data.files[0].url,
        size: data.files[0].size,
      };
    } else {
      throw new Error("ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù ğŸ©¸");
    }
  } catch (err) {
    throw `ğŸ©¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±ÙØ¹: ${err.message}`;
  }
}


export async function getBuffer(ctx, fileId) {
  const fileLink = await ctx.telegram.getFileLink(fileId)
  const response = await fetch(fileLink.href)
  const buffer = Buffer.from(await response.arrayBuffer())

  // ØªØ­ÙˆÙŠÙ„ Buffer Ù„Ù€ ArrayBuffer
  const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)

  return { buffer, arrayBuffer }
}
//================
function msToDate(ms) {
  let d = Math.floor(ms / 86400000);
  let h = Math.floor(ms / 3600000) % 24;
  let m = Math.floor(ms / 60000) % 60;
  let s = Math.floor(ms / 1000) % 60;
  return `${d} ÙŠÙˆÙ… ${h} Ø³Ø§Ø¹Ø© ${m} Ø¯Ù‚ÙŠÙ‚Ø© ${s} Ø«Ø§Ù†ÙŠØ©`;
}


function clockString(ms) {
  let h = Math.floor(ms / 3600000);
  let m = Math.floor(ms / 60000) % 60;
  let s = Math.floor(ms / 1000) % 60;
  return [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
}

bot.command(["menu", "start"], async (ctx) => {
  const uptime = clockString(process.uptime() * 1000);

  const mainMenuMessage = `\`\`\`
â”â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ•·ï¸ã€•âŒ¬â•„â”â”â•¾â”â”“
â”‡ ğ™±ğ™¾ğšƒ ğ™½ğ™°ğ™¼ğ™´ : BOT SPAMğŸ©¸
â”‡ ğš…ğ™´ğšğš‚ğ™¸ğ™¾ğ™½ : 2.4
â”‡ ğšğš„ğ™½ğšƒğ™¸ğ™¼ğ™´ : ${uptime}
â”—â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ©¸ã€•âŒ¬â•„â”â”â•¾â”â”›

â”â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ©¸ã€•âŒ¬â•„â”â”â•¾â”â”“
â”‡ [ select on botton ]
â”—â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ•·ï¸ã€•âŒ¬â•„â”â”â•¾â”â”›
\`\`\``;

  const mainKeyboard = [
    [
      { text: "ã€ ğŸ•·ï¸FLAGS MENUğŸ©¸ ã€", callback_data: "flags_menu" },
      { text: "ã€ ğŸ•·ï¸DOWNLOADğŸ©¸ ã€", callback_data: "download_menu" }
    ],
	  [
        { text: "ã€ ğŸ•·ï¸GROUP MENUğŸ©¸ ã€", callback_data: "group_menu" },
      { text: "ã€ ğŸ•·ï¸ AUDIO MENUğŸ©¸ ã€", callback_data: "ad_menu" }
      ],
    [
      { text: "ã€ ğŸ•·ï¸IMG MENUğŸ©¸ ã€", callback_data: "img_menu" },
      { text: "ã€ ğŸ•·ï¸USERS MENUğŸ©¸ ã€", callback_data: "users_menu" }
    ],
    [
        { text: "ã€ ğŸ•·ï¸DEV MENUğŸ©¸ ã€", callback_data: "dev_menu" },
            { text: "ã€ ğŸ•·ï¸DEEN MENUğŸ©¸ ã€", callback_data: "deen_menu" }
      ],
    [
      { text: "ã€ ğŸ•·ï¸AI MENUğŸ©¸ ã€", callback_data: "ai_menu" },
      { text: "ã€ ğŸ•·ï¸FUN MENUğŸ©¸ ã€", callback_data: "fun_menu" }
    ],
    	  [
        { text: "ã€ ğŸ•·ï¸CONVERTION MENUğŸ©¸ ã€", callback_data: "convertion_menu" }
      ]
  ];

  await ctx.replyWithPhoto("https://files.catbox.moe/xsplj9.jpg", {
    caption: mainMenuMessage,
    parse_mode: "Markdown",
    reply_markup: { inline_keyboard: mainKeyboard }
  });
});

// ğŸŸ¢ FLAGS MENU
bot.action("flags_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ FLAGS MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ‡¯ğŸ‡´â¯ /flag1 â†œ Ø§Ù„Ø£Ø±Ø¯Ù†  
ââ•â—¡ÌˆâƒğŸ‡¸ğŸ‡¦â¯ /flag2 â†œ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©  
ââ•â—¡ÌˆâƒğŸ‡²ğŸ‡¦â¯ /flag3 â†œ Ø§Ù„Ù…ØºØ±Ø¨  
ââ•â—¡ÌˆâƒğŸ‡¸ğŸ‡©â¯ /flag4 â†œ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†  
ââ•â—¡ÌˆâƒğŸ‡®ğŸ‡¶â¯ /flag5 â†œ Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª  
ââ•â—¡ÌˆâƒğŸ‡¾ğŸ‡ªâ¯ /flag6 â†œ Ø§Ù„ÙŠÙ…Ù†  
ââ•â—¡ÌˆâƒğŸ‡ªğŸ‡­â¯ /flag7 â†œ Ø³ÙˆØ±ÙŠØ§  
ââ•â—¡ÌˆâƒğŸ‡¸ğŸ‡©â¯ /flag8 â†œ ÙÙ„Ø³Ø·ÙŠÙ†  
ââ•â—¡ÌˆâƒğŸ‡ªğŸ‡¬â¯ /flag9 â†œ Ù…ØµØ±  
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});
bot.action("group_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ GROUP MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /kick â†œ Ø·Ø±Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /admin â†œ Ù„Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ù…Ø´Ø±Ù 
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /demote â†œ Ù„Ø¥Ù†Ø²Ø§Ù„ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ù…Ù† Ù…Ø´Ø±Ù
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /ht â†œ Ø¹Ù…Ù„ Ù…Ù†Ø´Ù† Ù…Ø®ÙÙŠ Ù„Ù„Ø¹Ø¶Ø§Ø¡
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /link â†œ ÙŠØ¬ÙŠØ¨ Ù„ÙŠÙ†Ùƒ Ø§Ù„Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /pin â†œ ØªØ«Ø¨ÙŠØª Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /unpin â†œ ÙŠÙ„ØºÙŠ ØªØ«Ø¨ÙŠØª Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¬Ø±ÙˆØ¨ 
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /destacar â†œ ÙŠÙ…ÙŠØ² Ø±Ø³Ø§Ù„Ù‡
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /desmarcar â†œ ÙŠÙ„ØºÙŠ ØªÙ…ÙŠØ² Ø±Ø³Ø§Ù„Ù‡
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /totag â†œ ÙŠØ¹Ù…Ù„ Ø§ÙŠ Ø±Ø³Ø§Ù„Ù‡ ØªØ±ÙŠØ¨ Ø¹Ù„ÙŠÙ‡Ø§ Ù…Ù†Ø´Ù†
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /delete â†œ Ù„Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø§Ù„Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /tagall â†œ ÙŠÙ…Ù†Ø´Ù† Ø¬Ù…ÙŠØ¹ Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /warn â†œ ÙŠØªÙ… ÙˆØ¶Ø¹ ØªØ­Ø°ÙŠØ± Ø¹Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /setdesc â†œ ØªØºÙŠØ± Ø¨Ø§ÙŠÙˆ Ø§Ù„Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /setname â†œ ØªØºÙŠØ± Ø§Ø³Ù… Ø§Ù„Ø¬Ø±ÙˆØ¨ 
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /kickall â†œ Ø·Ø±Ø¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /mute â†œ ÙƒØªÙ… Ø§Ù„Ø¹Ø¶Ùˆ  
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /group â†œ Ù„ÙØªØ­ Ùˆ Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨ 
ââ•â—¡ÌˆâƒğŸ•·ï¸â¯ /unmute â†œ Ø§Ù„ØºØ§Ø¡ Ø§Ù„ÙƒØªÙ… Ø¹Ù† Ø§Ù„Ø¹Ø¶Ùˆ
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ DOWNLOAD MENU
bot.action("download_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ DOWNLOAD MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ“€â¯ /play â†œ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª Ù…Ù† ÙŠÙˆØªÙŠÙˆØ¨  
ââ•â—¡ÌˆâƒğŸ“€â¯ /video â†œ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù…Ù† Ø§Ù„ÙŠÙˆØªÙŠÙˆØ¨ Ø¨ Ø§Ù„Ø§Ø³Ù… 
ââ•â—¡ÌˆâƒğŸ“€â¯ /ytdl â†œ Ù…ØµØ¯Ø± ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ 
ââ•â—¡ÌˆâƒğŸ“€â¯ /ytinfo â†œ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯
ââ•â—¡ÌˆâƒğŸ“€â¯ /yttags â†œ ÙŠØ¬ÙŠØ¨ Ø§ÙŠ ØªØ§Ø¬ Ù Ø§Ù„ÙÙŠØ¯
ââ•â—¡ÌˆâƒğŸ“€â¯ /google â†œ Ø¨Ø­Ø« Ø¹Ù† Ø§ÙŠ Ø´Ù‰Ø¡ ÙÙŠ Ø¬ÙˆØ¬Ù„
ââ•â—¡ÌˆâƒğŸ“€â¯ /vo2 â†œ ØµÙ†Ø¹ ÙÙŠØ¯ÙŠÙˆ Ù…Ù† Ù…Ø®ÙŠÙ„ØªÙƒ
ââ•â—¡ÌˆâƒğŸ“€â¯ /suno â†œ ØµÙ†Ø¹ Ø§ØºÙ†ÙŠÙ‡ Ù…Ù† Ù…Ø®ÙŠÙ„ØªÙƒ
ââ•â—¡ÌˆâƒğŸ“€â¯ /tiktok â†œ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ØªÙŠÙƒ ØªÙˆÙƒ  
ââ•â—¡ÌˆâƒğŸ“€â¯ /git â†œ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±ÙŠØ¨Ùˆ Ù…Ù† Ø¬ÙŠØªÙ‡Ø§Ø¨
ââ•â—¡ÌˆâƒğŸ“€â¯ /facebook â†œ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù…Ù† ÙÙŠØ³ 
ââ•â—¡ÌˆâƒğŸ“€â¯ /pinterest â†œ Ø¬Ù„Ø¨ ØµÙˆØ± Ù…Ù† Ø¨Ù†ØªØ±ÙŠØ³Øª
ââ•â—¡ÌˆâƒğŸ“€â¯ /ttaudio â†œ ØªØ­Ù…ÙŠÙ„ ØµÙˆØª Ù…Ù† ØªÙŠÙƒ
ââ•â—¡ÌˆâƒğŸ“€â¯ /anydownloader â†œ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ù‡
ââ•â—¡ÌˆâƒğŸ“€â¯ /saveweb â†œ ØªØ­Ù…ÙŠÙ„ Ù…Ù„ÙØ§Øª Ù…Ù† Ø£ÙŠ Ù…ÙˆÙ‚Ø¹  
ââ•â—¡ÌˆâƒğŸ“€â¯ /film â†œ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§ÙŠ ÙÙŠÙ„Ù…
ââ•â—¡ÌˆâƒğŸ“€â¯ /ytmp4 â†œ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ÙŠÙˆØªÙŠÙˆØ¨ Ø¨Ø§Ù„Ø±Ø§Ø¨Ø·  
ââ•â—¡ÌˆâƒğŸ“€â¯ /yt â†œ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ Ù…Ù† Ø¨ÙˆØª Ø§Ø­Ø·ÙŠØ§ØªÙŠ
ââ•â—¡ÌˆâƒğŸ“€â¯ /tts â†œ ØªØ­ÙˆÙŠÙ„ Ù†Øµ Ù„ØµÙˆØª  
ââ•â—¡ÌˆâƒğŸ“€â¯ /headers â†œ Ø¬Ù„Ø¨ Ù‡ÙŠØ¯Ø± Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹  
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ DOWNLOAD MENU
bot.action("dev_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ DEVELOPER MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ§‘â€ğŸ’»â¯ /join â†œ ØªØ¯Ø®ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª 
ââ•â—¡ÌˆâƒğŸ§‘â€ğŸ’»â¯ /out â†œ Ø®Ø±ÙˆØ¬ Ø§Ù„Ø¨ÙˆØª Ø¨ Ø£Ù…Ø± Ù…Ù† Ø§Ù„Ù…Ø·ÙˆØ± 
ââ•â—¡ÌˆâƒğŸ§‘â€ğŸ’»â¯ /up â†œ Ø±ÙØ¹ Ø§Ù„Ù…Ø·ÙˆØ± Ø§Ø¯Ù…Ù† Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨ÙˆØª Ø§Ø¯Ù…Ù†
ââ•â—¡ÌˆâƒğŸ§‘â€ğŸ’»â¯ /ban â†œ ØªØ¨Ù†ÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
ââ•â—¡ÌˆâƒğŸ§‘â€ğŸ’»â¯ /unban â†œ Ø±ÙØ¹ Ø§Ù„ØªØ¨Ù†ÙŠØ¯ Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
ââ•â—¡ÌˆâƒğŸ§‘â€ğŸ’»â¯ /gr â†œ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª Ø§Ù„ÙŠ Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡Ø§
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});
// ğŸŸ¢ DOWNLOAD MENU
bot.action("ad_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ AUDIO MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ§â¯ /deep â†œ ØµÙˆØª Ø¹Ù…ÙŠÙ‚ 
ââ•â—¡ÌˆâƒğŸ§â¯ /crushed â†œ ØµÙˆØª Ù…Ù†ÙÙˆØ®
ââ•â—¡ÌˆâƒğŸ§â¯ /fat â†œ ØµÙˆØª ØªØ®ÙŠÙ†
ââ•â—¡ÌˆâƒğŸ§â¯ /loud â†œ ØµÙˆØª ØµØ§Ø®Ø¨
ââ•â—¡ÌˆâƒğŸ§â¯ /fast â†œ ØµÙˆØª Ø³Ø±ÙŠØ¹
ââ•â—¡ÌˆâƒğŸ§â¯ /fatter â†œ ØµÙˆØª ØªØ®ÙŠÙŠÙ†Ù†
ââ•â—¡ÌˆâƒğŸ§â¯ /robot â†œ ØµÙˆØª Ø±ÙˆØ¨ÙˆØª
ââ•â—¡ÌˆâƒğŸ§â¯ /slow â†œ ØµÙˆØª Ø¨Ø·Ø¦
ââ•â—¡ÌˆâƒğŸ§â¯ /thin â†œ ØµÙˆØª Ø±ÙÙŠØ¹
ââ•â—¡ÌˆâƒğŸ§â¯ /reverse â†œ ØµÙˆØª ØªÙ‚Ø·ÙŠØ¹
ââ•â—¡ÌˆâƒğŸ§â¯ /soft â†œ ØµÙˆØª Ù†Ø§Ø¹Ù… 
ââ•â—¡ÌˆâƒğŸ§â¯ /chipmunk â†œ ØµÙˆØª Ø³Ù†Ø¬Ø§Ø¨ 
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ IMG MENU
bot.action("img_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ IMG MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ“·â¯ /flix â†œ ØµÙ†Ø¹ ØµÙˆØ± Ø¨Ø§Ù„ÙˆØµÙ  
ââ•â—¡ÌˆâƒğŸ“·â¯ /hd â†œ ØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© Ø§Ù„ØµÙˆØ±  
ââ•â—¡ÌˆâƒğŸ“·â¯ /rmbg â†œ Ø­Ø°Ù Ø®Ù„ÙÙŠÙ‡ Ø§Ù„ØµÙˆØ±Ù‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /buti â†œ 22 ÙˆØ¸ÙŠÙÙ‡ Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØµÙˆØ±
ââ•â—¡ÌˆâƒğŸ“·â¯ /blur â†œ Ø¨ÙƒØ³Ù„Ø© Ø§Ù„ØµÙˆØ±  
ââ•â—¡ÌˆâƒğŸ“·â¯ /zengy â†œ ØªØ²Ù†ÙŠØ¬ Ø§Ù„Ø§Ø´Ø®Ø§Øµ
ââ•â—¡ÌˆâƒğŸ“·â¯ /dado â†œ Ø®Ù„ÙÙŠØ§Øª Ù…Ù†ÙˆØ¹Ù‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /deep_fanta â†œØµÙ†Ø¹ ØµÙˆØ± Ø¨Ø·Ø±Ù‚ Ù…Ø®ØªÙ„ÙÙ‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /deep_siber â†œ ØµÙ†Ø¹ ØµÙˆØ± Ù…Ù† Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„
ââ•â—¡ÌˆâƒğŸ“·â¯ /deep_real â†œ ØµÙ†Ø¹ ØµÙˆØ± Ø­Ù‚ÙŠÙ‚ÙŠÙ‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /enhance â†œ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¬ÙˆØ¯Ù‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /restore â†œ Ø§ØµÙ„Ø§Ø­ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ù‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /colorize â†œ ØªÙ„ÙˆÙŠÙ† Ø§Ù„ØµÙˆØ±
ââ•â—¡ÌˆâƒğŸ“·â¯ /upscale â†œ ØªÙƒØ¨ÙŠØ± Ø§Ù„ØµÙˆØ±Ù‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /removebg â†œ Ø­Ø°Ù Ø§Ù„Ø®Ù„ÙÙŠÙ‡
ââ•â—¡ÌˆâƒğŸ“·â¯ /hijab â†œ ØªÙ„Ø¨ÙŠØ³ Ø§Ù„Ø´Ø®ØµÙŠÙ‡ Ø­Ø¬Ø§Ø¨
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ USERS MENU
bot.action("users_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ USERS MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ§â¯ /report â†œ Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù„Ø§ØºØ§Øª Ù„Ù„Ù…Ø·ÙˆØ±  
ââ•â—¡ÌˆâƒğŸ§â¯ /my_pro â†œ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­Ø³Ø§Ø¨Ùƒ  
ââ•â—¡ÌˆâƒğŸ§â¯ /owner â†œ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ø·ÙˆØ±  
ââ•â—¡ÌˆâƒğŸ§â¯ /my_msg â†œ ÙŠØ­Ø³Ø¨ Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„Ùƒ
ââ•â—¡ÌˆâƒğŸ§â¯ /total â†œ ÙŠØ­Ø³Ø¨ Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡
ââ•â—¡ÌˆâƒğŸ§â¯ /sign â†œ ÙŠØ¬ÙŠØ¨ Ø¨Ø±Ø¬Ùƒ
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});
// ğŸŸ¢ USERS MENU
bot.action("deen_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ DEEN MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ•‹â¯ /salah â†œ ÙŠØ¬ÙŠØ¨ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØµÙ„Ø§Ù‡
ââ•â—¡ÌˆâƒğŸ•‹â¯ /astghfarâ†œ ÙŠØ¬Ø¨Ù„Ùƒ Ø§Ø³ØªØºÙØ§Ø±Ø§Øª
ââ•â—¡ÌˆâƒğŸ•‹â¯ /ahades â†œ ÙŠØ¬ÙŠØ¨ Ø§Ø­Ø§Ø¯ÙŠØ« 
ââ•â—¡ÌˆâƒğŸ•‹â¯ /quran â†œ ÙŠØ¬ÙŠØ¨ Ø§Ù„Ù‚Ø±Ø§Ù† Ø¨ØµÙˆØª ÙŠØ§Ø³Ø± Ø§Ù„Ø¯ÙˆØ³Ø±ÙŠ
ââ•â—¡ÌˆâƒğŸ•‹â¯ /ayatkursi ÙŠØ¬ÙŠØ¨ Ø§ÙŠÙ‡ Ø§Ù„ÙƒØ±Ø³ÙŠ
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ AI MENU
bot.action("ai_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ AI MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ“±â¯ /gpt â†œ Ù…ÙˆØ¯ÙŠÙ„ GPT-4  
ââ•â—¡ÌˆâƒğŸ“±â¯ /gpt_pro â†œ Ù…ÙˆØ¯ÙŠÙ„ Ø¨Ø±Ùˆ  
ââ•â—¡ÌˆâƒğŸ“±â¯ /ai_1 â†œ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙØ±Ø¹ÙŠ  
ââ•â—¡ÌˆâƒğŸ“±â¯ /ai_pro â†œ Ø°ÙƒØ§Ø¡ Ø¨Ø±Ùˆ  
ââ•â—¡ÌˆâƒğŸ“±â¯ /lima â†œ Ù…ÙˆØ¯ÙŠÙ„ Ù„ÙŠÙ…Ø§  
ââ•â—¡ÌˆâƒğŸ“±â¯ /franso â†œ Ù…ÙˆØ¯ÙŠÙ„ ÙØ±Ù†Ø³Ø§ÙˆÙŠ  
ââ•â—¡ÌˆâƒğŸ“±â¯ /claud â†œ Ù…ÙˆØ¯ÙŠÙ„ Ø³Ø­Ø§Ø¨ÙŠ  
ââ•â—¡ÌˆâƒğŸ“±â¯ /gemini â†œ Ø¬ÙˆØ¬Ù„ Ø¬ÙŠÙ…ÙŠÙ†Ø§ÙŠ  
ââ•â—¡ÌˆâƒğŸ“±â¯ /deepseek â†œ Ø¯ÙŠØ¨ Ø³ÙŠÙƒ  
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ FUN MENU
bot.action("fun_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ FUN MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /xo â†œ Ù„Ø¹Ø¨Ø© Ø§ÙƒØ³ Ø£Ùˆ  
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /bald â†œ Ù„Ø¬Ø¹Ù„ Ø§ÙŠ Ø´Ø®Øµ ÙÙŠ ØµÙˆØ± Ø§ØµÙ„Ø¹
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /love â†œ ØªÙ…Ù†Ø´Ù† Ø¹Ù„ÙŠ Ø´Ø®Øµ Ùˆ ØªØ±ØªØ¨Ø· Ø¨ÙŠÙ‡
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /taxi â†œ Ù„Ø¹Ø¨Ù‡ ØªØ§ÙƒØ³ÙŠ
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /clac â†œ Ø­Ø³Ø¨Ù‡ Ø§ÙŠ Ù…Ø³Ø§Ù„Ù‡ Ù…Ø¹Ù‚Ø¯Ù‡
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /die â†œ ØªØ®Ù…ÙŠÙ† Ù…ÙˆØªÙƒ
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /lover â†œ ÙŠØ¬ÙˆØ²Ùƒ ÙˆØ­Ø¯Ù‡ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /personality â†œ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø®ØµÙŠÙ‡ 
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /friends â†œ ÙŠØ®ØªØ§Ø± Ø§Ù„Ø§ØªÙ†ÙŠÙ† ÙŠÙƒÙˆÙ†Ùˆ ØµØ­Ø§Ø¨
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /ship â†œ ÙŠÙ‚ÙŠØ³ Ù†Ø³Ø¨Ù‡ Ø­Ø¨ Ø·Ø±ÙÙŠÙ† 
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /mary â†œ Ø²ÙˆØ§Ø¬ Ø´Ø®ØµÙŠÙ† Ù…Ù† Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /divorce â†œ Ø·Ù„Ø§Ù‚ Ø´Ø®ØµÙŠÙ† Ù…Ù† Ø¬Ø±ÙˆØ¨
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /marry_me â†œ Ø¨Ø²ÙˆØ¬Ùƒ Ø´Ø®Øµ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
ââ•â—¡ÌˆâƒğŸ•¹ï¸â¯ /mem â†œ Ø¬Ù„Ø¨ Ù…ÙŠÙ…Ø²
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});
// ğŸŸ¢ CON MENU
bot.action("convertion_menu", async (ctx) => {
  await ctx.deleteMessage();
  const text = `
<b>ğŸ•·ï¸ CONVERTION MENU ğŸ©¸</b>
  â”â”â”âŠœ
ââ•â—¡ÌˆâƒğŸ‘€â¯ /to_vid â†œ ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø§Ø³ØªÙŠÙƒ Ø§Ù„ÙŠ ÙÙŠØ¯ÙŠÙˆ  
ââ•â—¡ÌˆâƒğŸ‘€â¯ /to_mp3 â†œ ØªØ­ÙˆÙŠÙ„ Ù…Ù† ÙÙŠØ¯ Ø§Ù„ÙŠ ØµÙˆØª
ââ•â—¡ÌˆâƒğŸ‘€â¯ /to_img â†œ ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø§Ø³ØªÙŠÙƒØ± Ø§Ù„ÙŠ ØµÙˆØ±Ù‡
ââ•â—¡ÌˆâƒğŸ‘€â¯ /to_url â†œ ØªØ­ÙˆÙŠÙ„ Ø§ÙŠ Ø´Ø¦ Ù„ÙŠ Ø±Ø§Ø¨Ø·
ââ•â—¡ÌˆâƒğŸ‘€â¯ /photo2anime â†œ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ± Ù„Ø§Ù†Ù…ÙŠ
 â”—â”â”â”â”â”â”â”â”â”â”â¬£
`;
  await ctx.replyWithPhoto("https://files.catbox.moe/eb7wk8.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: { inline_keyboard: [[{ text: "â€¹ ğ—•ğ—®ğ—°ğ—¸", callback_data: "back" }]] }
  });
});

// ğŸŸ¢ Ø²Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹

bot.action("back", async (ctx) => {
  try {
    await ctx.deleteMessage();
  } catch (e) {
    console.log("ğŸ©¸ Ù…Ø´ Ù‚Ø§Ø¯Ø± Ø£Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©:", e.message);
  }

  const uptime = clockString(process.uptime() * 1000);

  const text = `â”â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ•·ï¸ã€•âŒ¬â•„â”â”â•¾â”â”“
â”‡ ğ™±ğ™¾ğšƒ ğ™½ğ™°ğ™¼ğ™´ : BOT SPAMğŸ©¸
â”‡ ğš…ğ™´ğšğš‚ğ™¸ğ™¾ğ™½ : 2.4
â”‡ ğšğš„ğ™½ğšƒğ™¸ğ™¼ğ™´ : ${uptime}
â”—â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ©¸ã€•âŒ¬â•„â”â”â•¾â”â”›

â”â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ©¸ã€•âŒ¬â•„â”â”â•¾â”â”“
â”‡ [ select on botton ]
â”—â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ•·ï¸ã€•âŒ¬â•„â”â”â•¾â”â”›`;

  const mainKeyboard = {
    inline_keyboard: [
   [
      { text: "ã€ ğŸ•·ï¸FLAGS MENUğŸ©¸ ã€", callback_data: "flags_menu" },
      { text: "ã€ ğŸ•·ï¸DOWNLOADğŸ©¸ ã€", callback_data: "download_menu" }
    ],
  [
        { text: "ã€ ğŸ•·ï¸GROUP MENUğŸ©¸ ã€", callback_data: "group_menu" },
      { text: "ã€ ğŸ•·ï¸ AUDIO MENUğŸ©¸ ã€", callback_data: "ad_menu" }
      ],
    [
      { text: "ã€ ğŸ•·ï¸IMG MENUğŸ©¸ ã€", callback_data: "img_menu" },
      { text: "ã€ ğŸ•·ï¸USERS MENUğŸ©¸ ã€", callback_data: "users_menu" }
    ],
    [
        { text: "ã€ ğŸ•·ï¸DEV MENUğŸ©¸ ã€", callback_data: "dev_menu" },
            { text: "ã€ ğŸ•·ï¸DEEN MENUğŸ©¸ ã€", callback_data: "deen_menu" }
      ],
    [
      { text: "ã€ ğŸ•·ï¸AI MENUğŸ©¸ ã€", callback_data: "ai_menu" },
      { text: "ã€ ğŸ•·ï¸FUN MENUğŸ©¸ ã€", callback_data: "fun_menu" }
    ],
    	  [
        { text: "ã€ ğŸ•·ï¸CONVERTION MENUğŸ©¸ ã€", callback_data: "convertion_menu" }
      ]
    ]
  };

  await ctx.replyWithPhoto("https://files.catbox.moe/xsplj9.jpg", {
    caption: text,
    parse_mode: "HTML",
    reply_markup: mainKeyboard
  });
});

// Ø£Ù…Ø± Ø§Ø¹ÙØ§Ø¡ Ø§Ù„Ø£Ø¯Ù…Ù†
bot.command("demote", async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;
    if (!reply) {
      return ctx.reply(
        `ã€â€¹âŒ—â€º Ù‚Ù€Ù… Ø¨Ù€Ø±Ø¯ Ø¹Ù€Ù„Ù€ÙŠ Ø§Ù„Ù€Ø±Ø³Ù€Ø§Ù„Ù€Ù‡ Ø§Ùˆ @Ù…Ù€Ù†Ù€Ø´Ù€Ù†Ù€Ù‡ Ù„Ù€ÙƒÙ€ÙŠ ÙŠÙ€ØªÙ€Ù… Ø®Ù€ÙÙ€Ø¶Ù€Ù‡ ğŸ©¸ã€`
      );
    }

    const userId = reply.from.id;
    const chatId = ctx.chat.id;

    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø¹ÙØ§Ø¡ Ø§Ù„Ø£Ø¯Ù…Ù†
    await ctx.telegram.promoteChatMember(chatId, userId, {
      can_manage_chat: false,
      can_post_messages: false,
      can_edit_messages: false,
      can_delete_messages: false,
      can_manage_video_chats: false,
      can_restrict_members: false,
      can_promote_members: false,
      can_change_info: false,
      can_invite_users: false,
      can_pin_messages: false,
    });

    await ctx.reply(
      `â”â”â•¼â”â”â•ƒâŒ¬ã€” ğŸ•·ï¸ ã€•âŒ¬â•„â”â”â•¾â”â”“
â”‡ ğŸ©¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: [${firstName}](tg://user?id=${userId})
â”‡ ğŸ©¸ ØªÙ… Ø¹Ø²Ù„Ù‡ Ù…Ù† Ù…Ù†ØµØ¨ Ø§Ù„Ù…Ø´Ø±Ù!
â”‡ ğŸ©¸ Ø¨Ù‚Ø±Ø§Ø± Ù…Ù†: [${adminName}](tg://user?id=${adminId})
â”‡ ğŸ©¸ Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ø¹Ø¸Ù…Ù‰ ØªØªØ·Ù„Ø¨ Ù…Ø³Ø¤ÙˆÙ„ÙŠØ© Ø¹Ø¸ÙŠÙ…Ø©! ğŸ•¸ï¸
â”—â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ•·ï¸ã€•âŒ¬â•„â”â”â•¾â”â”›`,
      { parse_mode: "Markdown" }
    );
  } catch (e) {
    console.error(e);
    ctx.reply("Ø­ØµÙ„ Ø®Ø·Ø§Ø¡ ğŸ•·ï¸ğŸ©¸");
  }
});


// plugin by noureddine ouafy 
// scrape by malik 


// Helper delay
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©
const translateText = async (text) => {
  try {
    const res = await axios.get(
      `https://api.mymemory.translated.net/get?q=${encodeURIComponent(
        text
      )}&langpair=ar|en`
    );
    return res.data.responseData.translatedText;
  } catch (error) {
    console.error("â—ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©:", error);
    return text;
  }
};

// =============== AiLabs Class ===============
class AiLabs {
  constructor() {
    this.api = {
      base: "https://text2video.aritek.app",
      endpoints: {
        generate: "/txt2videov3",
        video: "/video",
      },
    };
    this.headers = {
      "user-agent": "NB Android/1.0.0",
      "accept-encoding": "gzip",
      "content-type": "application/json",
      authorization: "",
    };
    this.state = { token: null };
    this.setup = {
      cipher:
        "hbMcgZLlzvghRlLbPcTbCpfcQKM0PcU0zhPcTlOFMxBZ1oLmruzlVp9remPgi0QWP0QW",
      shiftValue: 3,
    };
  }

  dec(text, shift) {
    return [...text]
      .map((c) =>
        /[a-z]/.test(c)
          ? String.fromCharCode(
              ((c.charCodeAt(0) - 97 - shift + 26) % 26) + 97
            )
          : /[A-Z]/.test(c)
          ? String.fromCharCode(
              ((c.charCodeAt(0) - 65 - shift + 26) % 26) + 65
            )
          : c
      )
      .join("");
  }

  async decrypt() {
    if (this.state.token) return this.state.token;
    const input = this.setup.cipher;
    const shift = this.setup.shiftValue;
    const decrypted = this.dec(input, shift);
    this.state.token = decrypted;
    this.headers.authorization = decrypted;
    return decrypted;
  }

  deviceId() {
    return Array.from({ length: 16 }, () =>
      Math.floor(Math.random() * 16).toString(16)
    ).join("");
  }

  async txt2vid({ prompt, isPremium = 1 }) {
    try {
      if (!prompt?.trim())
        return { success: false, error: "Prompt cannot be empty" };

      await this.decrypt();
      const payload = {
        deviceID: this.deviceId(),
        isPremium,
        prompt,
        used: [],
        versionCode: 59,
      };
      const url = this.api.base + this.api.endpoints.generate;
      const response = await axios.post(url, payload, { headers: this.headers });
      const { code, key } = response.data;
      if (code !== 0 || !key)
        return { success: false, error: "Failed to get video generation key" };
      return { success: true, data: { task_id: key } };
    } catch (error) {
      return {
        success: false,
        error: error.message || "An unknown error occurred",
      };
    }
  }

  async status({ task_id }) {
    try {
      if (!task_id)
        return { success: false, error: "Invalid task_id provided" };
      await this.decrypt();
      const payload = { keys: [task_id] };
      const url = this.api.base + this.api.endpoints.video;
      const response = await axios.post(url, payload, {
        headers: this.headers,
        timeout: 20000,
      });
      const { code, datas } = response.data;
      if (code === 0 && Array.isArray(datas) && datas.length > 0) {
        const data = datas[0];
        if (data.url && data.url.trim() !== "") {
          return {
            success: true,
            data: {
              status: "completed",
              url: data.url.trim(),
              progress: "100%",
            },
          };
        }
        const progress = parseFloat(data.progress || 0);
        return {
          success: true,
          data: {
            status: "processing",
            progress: `${Math.round(progress)}%`,
          },
        };
      }
      return { success: false, error: "Invalid response from server" };
    } catch (error) {
      return { success: false, error: error.message || "Status check failed" };
    }
  }
}

// =============== Telegraf Bot ===============


bot.command(["veo", "vo2"], async (ctx) => {
  const text = ctx.message.text.replace(/\/(veo|vo2)\s*/, "");

  if (!text) {
    return ctx.reply(
      "âŒ Ù„Ø§Ø²Ù… ØªÙƒØªØ¨ ÙˆØµÙ Ù„Ù„ÙÙŠØ¯ÙŠÙˆ.\n\nÙ…Ø«Ø§Ù„:\n`/veo Ù…Ø¯ÙŠÙ†Ø© Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„ØºØ±ÙˆØ¨`",
      { parse_mode: "Markdown" }
    );
  }

  // Ù„Ùˆ Ø§Ù„Ù†Øµ Ø¹Ø±Ø¨ÙŠ â†’ ØªØ±Ø¬Ù…Ø©
  let prompt = text;
  if (/[\u0600-\u06FF]/.test(text)) {
    const translated = await translateText(text);
    await ctx.reply(
      `ğŸŒ ØªÙ… Ø§Ù„ØªØ±Ø¬Ù…Ø© Ù…Ù† Ø§Ù„Ø¹Ø±Ø¨ÙŠ â†’ Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ:\n\`${translated}\``,
      { parse_mode: "Markdown" }
    );
    prompt = translated;
  }

  const ai = new AiLabs();
  await ctx.reply("ğŸ¬ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ... Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø¹Ø¯Ø© Ø¯Ù‚Ø§Ø¦Ù‚.");

  const initialTask = await ai.txt2vid({ prompt });
  if (!initialTask.success) {
    return ctx.reply(`âŒ ÙØ´Ù„ Ø¨Ø¯Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.\n*Ø§Ù„Ø³Ø¨Ø¨:* ${initialTask.error}`, {
      parse_mode: "Markdown",
    });
  }

  const taskId = initialTask.data.task_id;
  let lastProgress = "";

  for (let i = 0; i < 60; i++) {
    await delay(10000);
    const statusResult = await ai.status({ task_id: taskId });

    if (!statusResult.success) {
      await ctx.reply(`âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙØ­Øµ: ${statusResult.error}`);
      return;
    }

    if (statusResult.data.status === "completed") {
      await ctx.reply("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ!");
      try {
        await ctx.replyWithVideo(
          { url: statusResult.data.url },
          { caption: `*Prompt:* ${text}`, parse_mode: "Markdown" }
        );
      } catch {
        await ctx.reply(
          `âš ï¸ Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙƒØªÙ„ÙŠØ¬Ø±Ø§Ù….\nğŸ”— Ø­Ù…Ù„Ù‡ Ù…Ù† Ù‡Ù†Ø§: ${statusResult.data.url}`
        );
      }
      return;
    }

    if (statusResult.data.progress !== lastProgress) {
      lastProgress = statusResult.data.progress;
      await ctx.reply(`â³ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ... *${lastProgress}*`, {
        parse_mode: "Markdown",
      });
    }
  }

  await ctx.reply("â° Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª ÙˆÙ„Ù… ÙŠÙƒØªÙ…Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.");
});

// Start b



// Ø¯Ø§Ù„Ø© Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©
async function processImage(ctx, tool) {
  if (!ctx.message.reply_to_message || !ctx.message.reply_to_message.photo) {
    return ctx.reply(`ğŸ–¼ï¸ Ù„Ø§Ø²Ù… ØªØ±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙˆØªÙƒØªØ¨: /${tool}`);
  }

  try {
    ctx.reply("â³ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† ØªÙ„ÙŠØ¬Ø±Ø§Ù…
    const fileId = ctx.message.reply_to_message.photo.slice(-1)[0].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const imgRes = await axios.get(fileLink.href, { responseType: "arraybuffer" });
    const buffer = Buffer.from(imgRes.data);

    // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù„Ù‰ API
    const form = new FormData();
    form.append("file", buffer, `${Date.now()}.jpg`);
    form.append("type", tool);

    const res = await axios.post("https://imagetools.rapikzyeah.biz.id/upload", form, {
      headers: form.getHeaders(),
    });

    const $ = cheerio.load(res.data);
    const resultUrl = $("img#memeImage").attr("src");

    if (!resultUrl) {
      return ctx.reply("âŒ Ù…ÙÙŠØ´ Ù†ØªÙŠØ¬Ø© Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±.");
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    await ctx.replyWithPhoto({ url: resultUrl });
  } catch (e) {
    console.error(e);
    ctx.reply(`âŒ Error: ${e.message}`);
  }
}

// Ø£ÙˆØ§Ù…Ø± Ù…Ù†ÙØµÙ„Ø©
bot.command("removebg", (ctx) => processImage(ctx, "removebg"));
bot.command("enhance", (ctx) => processImage(ctx, "enhance"));
bot.command("upscale", (ctx) => processImage(ctx, "upscale"));
bot.command("restore", (ctx) => processImage(ctx, "restore"));
bot.command("colorize", (ctx) => processImage(ctx, "colorize"));

const antiPrivate = true;

let blockedUsers = new Set(); // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†

bot.use(async (ctx, next) => {
  try {
    // Ù„Ùˆ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± => ØªØ¬Ø§Ù‡Ù„
    if (blockedUsers.has(ctx.from.id)) return;

    // Ù„Ùˆ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¬Ø±ÙˆØ¨ => ÙƒÙ…Ù„
    if (ctx.chat.type !== "private") return next();

    // Ù„Ùˆ Ù…ÙÙŠØ´ Ø±Ø³Ø§Ù„Ø© (Ø­Ø§Ù„Ø© Ù†Ø§Ø¯Ø±Ø©) => ØªØ¬Ø§Ù‡Ù„
    if (!ctx.message) return;

    // Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø£ÙˆØ§Ù…Ø± Ù…Ø¹ÙŠÙ†Ø©
    const skipWords = ["owner"];
    if (skipWords.some((word) => ctx.message.text?.toLowerCase().includes(word))) {
      return next();
    }

    // Ø®Ø§Øµ + antiPrivate Ù…ÙØ¹Ù„Ø© + Ø§Ù„Ù…Ø±Ø³Ù„ Ù…Ø´ Owner
    if (antiPrivate && !owners.includes(String(ctx.from.id))) {
      await ctx.replyWithMarkdown(
        `*[ğŸ©¸] Ù…Ø±Ø­Ø¨Ù‹Ø§ ${ctx.from.username ? `@${ctx.from.username}` : ctx.from.first_name}*\n\n` +
          `ğŸš« ÙŠÙÙ…Ù†Ø¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ø®Ø§ØµØŒ ÙˆÙ„Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¨Ø¨ ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡.\n\n` +
          `âœ… Ø¬Ø±Ù‘Ø¨ Ø§Ù„Ø¨ÙˆØª Ø¯Ø§Ø®Ù„ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø¯Ø¹Ù…:\nğŸ‘‰ https://t.me/Terbo888xxx`
      );

      // Ù†Ø¶ÙŠÙ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡
      blockedUsers.add(ctx.from.id);
      return;
    }

    return next();
  } catch (e) {
    console.error("AntiPrivate Error:", e);
    return next();
  }
});
//==============
bot.command('play', async (ctx) => {
  try {
    const query = ctx.message.text.split(' ').slice(1).join(' ');
    if (!query) return ctx.reply('ğŸ©¸ Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø£Ùˆ Ø±Ø§Ø¨Ø· ÙŠÙˆØªÙŠÙˆØ¨');

    const search = await yts(query);
    if (!search.videos.length) return ctx.reply('ğŸ©¸ Ù…ÙÙŠØ´ Ù†ØªØ§Ø¦Ø¬!');

    const video = search.videos[0];
    const caption = `
     â”‡â‰¡ â—¡ÌˆâƒğŸ§›â€â™‚ï¸â†œã€Ù…Ø¹Ù„ÙˆÙ…Ù€Ø§Øª Ø§Ù„Ù€Ù…Ù‚Ù€Ø·Ù€Ø¹ã€â†¶
â”â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ§ã€•âŒ¬â•„â”â”â•¾â”â”“
â”‡â‰¡ â—¡ÌˆâƒğŸ¶â†œ Ø§Ù„Ù€Ø¹Ù€Ù†Ù€ÙˆØ§Ù† â†ã€ ${video.title} ã€
â”‡â‰¡ â—¡ÌˆâƒğŸ“ºâ†œ Ø§Ù„Ù€Ù‚Ù€Ù†Ù€Ø§Ø© â†ã€ ${video.author.name} ã€
â”‡â‰¡ â—¡Ìˆâƒâ±ï¸â†œ Ø§Ù„Ù€Ù…Ù€Ø¯Ø© â†ã€ ${video.timestamp} ã€
â”‡â‰¡ â—¡ÌˆâƒğŸ‘ï¸â†œ Ø§Ù„Ù…Ù€Ø´Ù€Ø§Ù‡Ø¯Ø§Øª â†ã€ ${video.views.toLocaleString()} ã€
â”‡â‰¡ â—¡ÌˆâƒğŸ“…â†œ ØªÙ€Ø§Ø±ÙŠÙ€Ø® Ø§Ù„Ù€Ù†Ù€Ø´Ù€Ø± â†ã€ ${video.ago} ã€
â”—â”â•¼â”â”â•ƒâŒ¬ã€”ğŸ”¥ã€•âŒ¬â•„â”â”â•¾â”â”›
> â—¡ÌˆâƒğŸ©¸â†œ Ø§Ø³ØªØ¹Ø¯ Ù„Ø³Ù…Ø§Ø¹ Ø´ÙŠØ¡ Ø±Ø§Ø¦Ø¹! ğŸ§
    `.trim();

    await ctx.replyWithPhoto(video.thumbnail, { caption, parse_mode: "Markdown" });
    const api = await yta(video.url);
    if (api.status) await ctx.replyWithAudio({ url: api.result.download }, { title: api.result.title });

  } catch (e) {
    console.error(e);
    ctx.reply('âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«.');
  }
});
//============

// Ø¯Ø§Ù„Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
function pickRandom(list) {
  return list[Math.floor(Math.random() * list.length)];
}

// ---------------------- Ø§Ù„Ø£ÙˆØ§Ù…Ø± ----------------------

bot.command("friends", (ctx) => {
  ctx.reply(`ğŸ”° ÙŠÙ„Ø§ Ù†Ø¹Ù…Ù„ ØµØ¯Ø§Ù‚Ø§Øª ğŸ”°\n\nÙŠØ§ @${ctx.from.username || ctx.from.id} ÙƒÙ„Ù… ÙˆØ§Ø­Ø¯ Ù…Ù† Ø§Ù„Ø¬Ø±ÙˆØ¨ ÙˆØ®Ù„ÙŠÙƒÙ… ØµØ­Ø§Ø¨ ğŸ™†\n\nğŸ‘€ Ø£Ø­Ù„Ù‰ ØµØ¯Ø§Ù‚Ø§Øª Ø¨ØªØ¨Ø¯Ø£ Ø¨Ù„Ø¹Ø¨Ø© ğŸ˜‰`);
});

bot.command("lover", (ctx) => {
  ctx.reply(`ğŸ’ ÙŠØ§ @${ctx.from.username || ctx.from.id} Ø§ØªØ¬ÙˆØ²Øª ÙˆØ§Ø­Ø¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ø¬Ø±ÙˆØ¨ ğŸ˜ğŸ’“ Ù…Ø¨Ø±ÙˆÙƒ!`);
});

bot.command("personality", (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  if (!text) return ctx.reply("ğŸ“Œ Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø´Ø®Øµ Ù…Ø«Ù„: /personalidad Ù…Ø­Ù…Ø¯");
  const personalidad = `
â”â”â”Â°â€â¬ *ØªØ­Ù„ÙŠÙ„ Ø´Ø®ØµÙŠØ©* â­â€Â°â”â”â”“
â”ƒâ€¢ Ø§Ù„Ø§Ø³Ù… : ${text}
â”ƒâ€¢ Ø·ÙŠØ¨Ø© : ${pickRandom(['20%','40%','60%','80%','100%'])}
â”ƒâ€¢ Ø´Ø¬Ø§Ø¹Ø© : ${pickRandom(['10%','30%','50%','70%','90%'])}
â”ƒâ€¢ Ù‚ÙˆØ© : ${pickRandom(['Ø¶Ø¹ÙŠÙ','Ù…ØªÙˆØ³Ø·','Ù‚ÙˆÙŠ','Ø®Ø§Ø±Ù‚'])}
â”ƒâ€¢ Ù†ÙˆØ¹ : ${pickRandom(['Ø·ÙŠØ¨','Ø´Ø§ÙŠÙ„ Ù‡Ù…','ÙƒÙŠÙˆØª','Ù…Ø³ØªÙØ²','Ø¹ØµØ¨ÙŠ'])}
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
  ctx.reply(personalidad);
});

bot.command("ship", (ctx) => {
  const args = ctx.message.text.split(" ").slice(1);
  if (args.length < 2) return ctx.reply("âš ï¸ Ù„Ø§Ø²Ù… ØªÙƒØªØ¨ Ø§Ø³Ù…ÙŠÙ†\nÙ…Ø«Ø§Ù„: /ship Ø£Ø­Ù…Ø¯ Ù…Ù†Ù‰");
  let [name1, name2] = args;
  let love = `â¤ï¸ Ù†Ø³Ø¨Ø© Ø§Ù„Ø­Ø¨ Ø¨ÙŠÙ† *${name1}* Ùˆ *${name2}* Ù‡ÙŠ: *${Math.floor(Math.random() * 100)}%* ğŸ‘©ğŸ»â€â¤ï¸â€ğŸ‘¨ğŸ»`;
  ctx.reply(love, { parse_mode: "Markdown" });
});

bot.command("top", (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  if (!text) return ctx.reply("ğŸ“Œ Ù„Ø§Ø²Ù… ØªÙƒØªØ¨ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹\nÙ…Ø«Ø§Ù„: /top Ø§Ù„ÙƒØ³Ø§Ù„Ù‰");
  let top = `ğŸ† ØªÙˆØ¨ 10 ${text} ğŸ†\n\n`;
  for (let i = 1; i <= 10; i++) {
    top += `${i}. Ø¹Ø¶Ùˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ø¬Ø±ÙˆØ¨ ğŸ˜‚\n`;
  }
  ctx.reply(top);
});

bot.command("topgays", (ctx) => {
  let top = `ğŸŒˆ TOP 10 Ù…Ø¶Ø­Ùƒ ğŸŒˆ\n\n`;
  for (let i = 1; i <= 10; i++) {
    top += `${i}. Ø¹Ø¶Ùˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ ğŸ³ï¸â€ğŸŒˆ\n`;
  }
  ctx.reply(top);
});



bot.command("delete", async (ctx) => {
  const chatId = ctx.chat.id;
  const userId = ctx.from.id;

  // Ù„Ø§Ø²Ù… Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("âŒ Ø§Ù„Ø£Ù…Ø± ÙŠØ´ØªØºÙ„ ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª ÙÙ‚Ø·");
  }

  // Ù„Ø§Ø²Ù… Ø±ÙŠØ¨Ù„Ø§ÙŠ
  if (!ctx.message.reply_to_message) {
    return ctx.reply("ğŸ©¸ Ù„Ø§Ø²Ù… ØªØ¹Ù…Ù„ Ø±ÙŠØ¨Ù„Ø§ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªÙ…Ø³Ø­Ù‡Ø§");
  }

  // Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ø¶Ùˆ
  const member = await ctx.telegram.getChatMember(chatId, userId);

  // âœ… Ù‡Ù†Ø§ Ø¹Ø±ÙÙ†Ø§ isOwner
  const isOwner = OWNER_ID.includes(String(userId)) || DEVELOPERS.includes(String(userId));
  const isAdminOrCreator =
    member.status === "administrator" || member.status === "creator";

  if (!isOwner && !isAdminOrCreator) {
    return ctx.reply("âŒ Ø§Ù„Ø£Ù…Ø± Ù…Ø³Ù…ÙˆØ­ ÙÙ‚Ø· Ù„Ù„Ø§Ø¯Ù…Ù†Ø² Ø£Ùˆ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ø£Ùˆ Ù…Ù†Ø´Ø¦ Ø§Ù„Ø¬Ø±ÙˆØ¨");
  }

  try {
    // Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ Ù…Ø¹Ù…ÙˆÙ„ Ù„Ù‡Ø§ Ø±ÙŠØ¨Ù„Ø§ÙŠ
    await ctx.deleteMessage(ctx.message.reply_to_message.message_id);
    // Ù…Ø³Ø­ Ø£Ù…Ø± /delete Ù†ÙØ³Ù‡
    await ctx.deleteMessage(ctx.message.message_id);
  } catch (err) {
    console.error(err);
    ctx.reply("ğŸ©¸ Ù…Ø´ Ù‚Ø§Ø¯Ø± Ø£Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ù„Ø©ØŒ Ø§Ø­ØªÙ…Ø§Ù„ Ù…Ø§ÙÙŠØ´ ØµÙ„Ø§Ø­ÙŠØ§Øª ÙƒØ§ÙÙŠØ© (Ù„Ø§Ø²Ù… Ø§Ù„Ø¨ÙˆØª ÙŠÙƒÙˆÙ† Ø£Ø¯Ù…Ù†).");
  }
});

// Ø£Ù…Ø± Ø¢ÙŠØ© Ø§Ù„ÙƒØ±Ø³ÙŠ
bot.command(["ayatkursi", "Ø§ÙŠØ©", "Ø§ÙŠØ©_Ø§Ù„ÙƒØ±Ø³ÙŠ"], async (ctx) => {
  const caption = `
ã€Ø§ÙŠÙ‡ Ø§Ù„ÙƒØ±Ø³ÙŠğŸ¥¹ğŸ’˜ã€

ã€Ø§Ù„Ù„Ù‘ÙÙ‡Ù Ù„ÙØ§ Ø¥ÙÙ„ÙÙ‡Ù Ø¥ÙÙ„Ù‘ÙØ§ Ù‡ÙÙˆÙ Ø§Ù„Ù’Ø­ÙÙŠÙ‘Ù Ø§Ù„Ù’Ù‚ÙÙŠÙ‘ÙÙˆÙ…Ù Ù„ÙØ§ ØªÙØ£Ù’Ø®ÙØ°ÙÙ‡Ù Ø³ÙÙ†ÙØ©ÙŒ ÙˆÙÙ„ÙØ§ Ù†ÙÙˆÙ’Ù…ÙŒ Ù„ÙÙ‡Ù Ù…ÙØ§ ÙÙÙŠ Ø§Ù„Ø³Ù‘ÙÙ…ÙØ§ÙˆÙØ§ØªÙ ÙˆÙÙ…ÙØ§ ÙÙÙŠ Ø§Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù Ù…ÙÙ†Ù’ Ø°ÙØ§ Ø§Ù„Ù‘ÙØ°ÙÙŠ ÙŠÙØ´Ù’ÙÙØ¹Ù Ø¹ÙÙ†Ù’Ø¯ÙÙ‡Ù Ø¥ÙÙ„Ù‘ÙØ§ Ø¨ÙØ¥ÙØ°Ù’Ù†ÙÙ‡Ù ÙŠÙØ¹Ù’Ù„ÙÙ…Ù Ù…ÙØ§ Ø¨ÙÙŠÙ’Ù†Ù Ø£ÙÙŠÙ’Ø¯ÙÙŠÙ‡ÙÙ…Ù’ ÙˆÙÙ…ÙØ§ Ø®ÙÙ„Ù’ÙÙÙ‡ÙÙ…Ù’ ÙˆÙÙ„ÙØ§ ÙŠÙØ­ÙÙŠØ·ÙÙˆÙ†Ù Ø¨ÙØ´ÙÙŠÙ’Ø¡Ù Ù…ÙÙ†Ù’ Ø¹ÙÙ„Ù’Ù…ÙÙ‡Ù Ø¥ÙÙ„Ù‘ÙØ§ Ø¨ÙÙ…ÙØ§ Ø´ÙØ§Ø¡Ù ÙˆÙØ³ÙØ¹Ù ÙƒÙØ±Ù’Ø³ÙÙŠÙ‘ÙÙ‡Ù Ø§Ù„Ø³Ù‘ÙÙ…ÙØ§ÙˆÙØ§ØªÙ ÙˆÙØ§Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù ÙˆÙÙ„ÙØ§ ÙŠÙØ¦ÙÙˆØ¯ÙÙ‡Ù Ø­ÙÙÙ’Ø¸ÙÙ‡ÙÙ…ÙØ§ ÙˆÙÙ‡ÙÙˆÙ Ø§Ù„Ù’Ø¹ÙÙ„ÙÙŠÙ‘Ù Ø§Ù„Ù’Ø¹ÙØ¸ÙÙŠÙ…Ùã€
`.trim();

  // ÙŠØ¨Ø¹Ø« Ø§Ù„Ù†Øµ
  await ctx.reply(caption, { parse_mode: "Markdown" });

  // ÙŠØ¨Ø¹Ø« Ø¢ÙŠØ© Ø§Ù„ÙƒØ±Ø³ÙŠ ØµÙˆØªÙŠØ©
  await ctx.replyWithAudio(
    { url: "https://files.catbox.moe/vd9rvk.aac" },
    {
      title: "Ø¢ÙŠØ© Ø§Ù„ÙƒØ±Ø³ÙŠ",
      performer: "Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…",
    }
  );
});



// Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ø¹Ø±Ø¨ÙŠ â†’ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ

// Ø£ÙˆØ§Ù…Ø± Ù…ØªØ¹Ø¯Ø¯Ø©: /animeimage Ø£Ùˆ /Ø§Ù†Ù…ÙŠ Ø£Ùˆ /ØµÙˆØ±Ø©Ø§Ù†Ù…ÙŠ
bot.command(["animeimage", "Ø§Ù†Ù…ÙŠ", "ØµÙˆØ±Ø©Ø§Ù†Ù…ÙŠ"], async (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  if (!text) {
    return ctx.reply("ğŸ“âœ¦ Ù…Ù† ÙØ¶Ù„Ùƒ Ø£Ø¯Ø®Ù„ ÙˆØµÙ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±ØŒ Ù…Ø«Ù„:\n/animeimage ÙØªØ§Ø© Ø£Ù†Ù…ÙŠ ØªÙ‚Ù ØªØ­Øª Ø§Ù„Ù…Ø·Ø±");
  }

  await ctx.reply("âŒ› ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ø·Ù„Ø¨Ùƒ...");

  try {
    let prompt = text.trim();
    if (/[\u0600-\u06FF]/.test(prompt)) {
      prompt = await translateToEnglish(prompt);
    }

    const url = `https://api.takamura.site/api/ai/animeimage?prompt=${encodeURIComponent(prompt)}`;
    const { data } = await axios.get(url);

    if (!data.status || !data.image) {
      return ctx.reply("âŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ù‹Ø§.");
    }

    const buffer = Buffer.from(data.image.split(",")[1], "base64");

    await ctx.replyWithPhoto({ source: buffer }, {
      caption: `ğŸ¨âœ¦ *ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n\nğŸ“ Ø§Ù„ÙˆØµÙ: ${text}\nğŸŒ EN: ${prompt}`
    });
  } catch (err) {
    console.error(err);
    ctx.reply("âŒâœ¦ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©.");
  }
});

// Ø±Ø¯ÙˆØ¯ Ø¬Ø§Ù‡Ø²Ø© (Ù‚Ù„Ø¨ØŒ Ø­Ø¨ØŒ Ù‡Ø²Ø§Ø±ØŒ Ø´ØªØ§ÙŠÙ…)


// Ø¯Ø§Ù„Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø¯Ø© Ù„ØµÙŠØºØ© Ø£ÙŠØ§Ù…/Ø³Ø§Ø¹Ø§Øª/Ø¯Ù‚Ø§ÙŠÙ‚/Ø«ÙˆØ§Ù†ÙŠ

// Ø£Ù…Ø± join
bot.command(["join", "Ø§Ø¯Ø®Ù„"], async (ctx) => {
  const userId = String(ctx.from.id);
  const userName = ctx.from.first_name;

  // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø·ÙˆØ± Ø£Ùˆ Ø§Ù„Ù…Ø§Ù„Ùƒ
  if (!OWNER_ID.includes(userId) && !DEVELOPERS.includes(userId)) {
    return ctx.replyWithMarkdown(
      `ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·!\n\n Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: [${userName}](tg://user?id=${userId})`
    );
  }

  const args = ctx.message.text.split(" ").slice(1);
  const inviteLink = args[0];
  const days = args[1];

  if (!inviteLink) {
    return ctx.reply(`ğŸ“Œ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨ Ù…Ø«Ù„:\n/join <Ø§Ù„Ø±Ø§Ø¨Ø·> <Ø§Ù„Ø£ÙŠØ§Ù…>`);
  }
  if (!/https:\/\/t\.me\/\+/.test(inviteLink)) {
    return ctx.reply(`âŒ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ§Ù„Ø­! Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ø±Ø§Ø¨Ø· Ø¯Ø¹ÙˆØ© ØªÙ„ÙŠØ¬Ø±Ø§Ù….`);
  }
  if (!days) {
    return ctx.reply(`ğŸ“Œ Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù… Ù…Ø«Ù„:\n/join <Ø§Ù„Ø±Ø§Ø¨Ø·> 2`);
  }
  if (isNaN(days)) {
    return ctx.reply(`âœ– ÙŠØ¬Ø¨ ÙƒØªØ§Ø¨Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù… ÙƒØ±Ù‚Ù… ÙÙ‚Ø·!`);
  }

  const nDays = 86400000 * Number(days);
  const expireTime = msToDate(nDays);

  await ctx.reply("ğŸ˜ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø®Ù„Ø§Ù„ 3 Ø«ÙˆØ§Ù†Ù...");
  await new Promise((res) => setTimeout(res, 3000));

  try {
    // Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„Ø¬Ø±ÙˆØ¨
    const chat = await ctx.telegram.joinChat(inviteLink);
    const groupId = chat.id;
    const groupName = chat.title;

    // Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨
    await ctx.telegram.sendMessage(
      groupId,
      `âœ… ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­\n\nğŸ“› Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: ${groupName}\nâ³ Ù…Ø¯Ø© Ø§Ù„Ø¨Ù‚Ø§Ø¡: ${expireTime}`,
      { parse_mode: "Markdown" }
    );

    await new Promise((res) => setTimeout(res, 2000));

    await ctx.telegram.sendMessage(
      groupId,
      `ğŸ® Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø§Ù„Ø¬Ù…ÙŠØ¹!\nØªÙ…Øª Ø¯Ø¹ÙˆØªÙŠ Ø¨ÙˆØ§Ø³Ø·Ø© ${userName}`,
      { parse_mode: "Markdown" }
    );

    await new Promise((res) => setTimeout(res, 7000));

    await ctx.telegram.sendMessage(groupId, "ğŸ¤­ ÙÙ„ÙŠÙ‡Ø¯Ø£ Ø§Ù„Ø¬Ù…ÙŠØ¹!");

    // Ø±Ø³Ø§Ù„Ø© Ø®Ø§ØµØ© Ù„ÙƒÙ„ Ø§Ù„Ù…Ø§Ù„ÙƒÙŠÙ†
    for (const owner of OWNER_ID) {
      await ctx.telegram.sendMessage(
        owner,
        `âš¡ Ø¯Ø¹ÙˆØ© Ø¬Ø±ÙˆØ¨\n\nğŸ‘¤ ${userName} Ø¯Ø¹Ø§Ù†ÙŠ\n\nğŸ“› Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: ${groupName}\nğŸ†” ID: ${groupId}\nğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: ${inviteLink}\n\nâ³ Ù…Ø¯Ø© Ø§Ù„Ø¨Ù‚Ø§Ø¡: ${expireTime}`,
        { parse_mode: "Markdown" }
      );
    }

    // Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    await ctx.telegram.sendMessage(
      groupId,
      `ğŸ‘‹ğŸ» Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒÙ…\n\nØªÙ…Øª Ø¯Ø¹ÙˆØªÙŠ Ø¨ÙˆØ§Ø³Ø·Ø© ${userName}\n\nâœ§ Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§ÙƒØªØ¨:\n/Ø§Ù„Ø§ÙˆØ§Ù…Ø±\n\nğŸ“Œ Ø³Ø£Ø®Ø±Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯: ${expireTime}`,
      {
        parse_mode: "Markdown",
        reply_markup: {
          inline_keyboard: [
            [{ text: "âœ† Ø§Ù„Ù…Ø·ÙˆØ±", callback_data: "owner" }],
            [{ text: "â¦™â˜° Ø§Ù„Ø£ÙˆØ§Ù…Ø±", callback_data: "menu" }],
          ],
        },
      }
    );
  } catch (err) {
    console.error("join error:", err);
    ctx.reply("âš ï¸ ÙØ´Ù„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…! Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ Ø£Ùˆ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù†ØªÙ‡ÙŠ.");
  }
});


// Ø£Ù…Ø± Ø§Ù„ØªØ«Ø¨ÙŠØª
bot.command("pin", async (ctx) => {
  if (!ctx.message.reply_to_message) {
    return ctx.reply("ğŸ•·ï¸ Ù„Ø§Ø²Ù… ØªØ±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø¹Ø´Ø§Ù† Ø£Ø«Ø¨ØªÙ‡Ø§.");
  }
  try {
    await ctx.pinChatMessage(ctx.message.reply_to_message.message_id);
    ctx.reply("ğŸ©¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§ØªØ«Ø¨ØªØª");
  } catch (e) {
    console.error(e);
    ctx.reply("ğŸ•·ï¸ Ù…Ø§Ù‚Ø¯Ø±ØªØ´ Ø£Ø«Ø¨Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø©.");
  }
});

// Ø£Ù…Ø± Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ«Ø¨ÙŠØª
bot.command("unpin", async (ctx) => {
  try {
    await ctx.unpinChatMessage();
    ctx.reply("ğŸ©¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§ØªØ´Ø§Ù„Øª Ù…Ù† Ø§Ù„ØªØ«Ø¨ÙŠØª");
  } catch (e) {
    console.error(e);
    ctx.reply("ğŸ•·ï¸ Ù…Ø§Ù‚Ø¯Ø±ØªØ´ Ø£Ø´ÙŠÙ„ Ø§Ù„ØªØ«Ø¨ÙŠØª.");
  }
});

// Ø£Ù…Ø± ØªÙ…ÙŠÙŠØ² (Ù‡Ù†Ø¹Ù…Ù„Ù‡ ÙƒØ­ÙØ¸ Ø±Ø³Ø§Ù„Ø© Ø¨Ø§Ù„Ù€ forward Ù„Ù†ÙØ³ Ø§Ù„Ø¬Ø±ÙˆØ¨ ÙƒÙ€ Ù…Ø±Ø¬Ø¹)
bot.command("destacar", async (ctx) => {
  if (!ctx.message.reply_to_message) {
    return ctx.reply("ğŸ©¸ Ù„Ø§Ø²Ù… ØªØ±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø¹Ø´Ø§Ù† ØªÙ…ÙŠØ²Ù‡Ø§.");
  }
  try {
    await ctx.forwardMessage(ctx.chat.id, ctx.chat.id, ctx.message.reply_to_message.message_id);
    ctx.reply("ğŸ©¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§ØªØ¹Ù„Ù…Øª ÙˆÙ…ÙˆØ¬ÙˆØ¯Ø© ÙƒÙ…Ø±Ø¬Ø¹");
  } catch (e) {
    console.error(e);
    ctx.reply("ğŸ©¸ Ù…Ø§Ù‚Ø¯Ø±ØªØ´ Ø£Ù…ÙŠØ² Ø§Ù„Ø±Ø³Ø§Ù„Ø©.");
  }
});

// Ø£Ù…Ø± Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ…ÙŠÙŠØ² (Ù…ÙÙŠØ´ API Ù…Ø¨Ø§Ø´Ø± ÙÙŠ ØªÙ„ÙŠØ¬Ø±Ø§Ù…)
// Ù…Ù…ÙƒÙ† Ù†Ø¹ØªØ¨Ø±Ù‡ Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ Ø§ØªØ¹Ù…Ù„Ù‡Ø§ forward ÙƒÙ…Ø±Ø¬Ø¹
bot.command("desmarcar", async (ctx) => {
  ctx.reply("â„¹ï¸ ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù…ÙÙŠÙ‡ÙˆØ´ Ø¥Ù„ØºØ§Ø¡ ØªÙ…ÙŠÙŠØ² Ù…Ø¨Ø§Ø´Ø±ØŒ Ù„ÙƒÙ† ØªÙ‚Ø¯Ø± ØªÙ…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ Ø§ØªØ¹Ù„Ù…Øª ÙŠØ¯ÙˆÙŠ.");
});

// ØªØ´ØºÙŠÙ„ 

// Ø¯Ø§Ù„Ø© Ø§Ù„Ø¨Ø­Ø«
async function xnxxsearch(query, page = 1) {
  const baseurl = 'https://www.xnxx.com';
  const url = `${baseurl}/search/${query}/${page}`;
  try {
    const res = await fetch(url);
    const text = await res.text();
    const $ = cheerio.load(text);
    const results = [];

    $('div.mozaique').each((a, b) => {
      const thumb = $(b).find('div.thumb a');
      const thumbUnder = $(b).find('div.thumb-under');
      thumb.each((i, el) => {
        const link = baseurl + $(el).attr('href').replace('/THUMBNUM/', '/');
        const title = thumbUnder.eq(i).find('a').attr('title');
        const info = thumbUnder.eq(i).find('p.metadata').text().trim();
        const [author, time, resolution, views] = info
          .split(/[\s-]+/)
          .filter(item => item.trim() !== '');
        results.push({ title, author, time, resolution, views, link });
      });
    });

    return { code: 200, status: true, result: results.slice(0, 10) };
  } catch (err) {
    return { code: 503, status: false, result: err };
  }
}

// Ø¯Ø§Ù„Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
async function xnxxdl(URL) {
  return new Promise((resolve, reject) => {
    fetch(`${URL}`, { method: 'get' })
      .then((res) => res.text())
      .then((res) => {
        const $ = cheerio.load(res, { xmlMode: false });
        const title = $('meta[property="og:title"]').attr('content');
        const duration = $('meta[property="og:duration"]').attr('content');
        const image = $('meta[property="og:image"]').attr('content');
        const videoScript = $('#video-player-bg > script:nth-child(6)').html();
        const files = {
          low: (videoScript.match(/html5player.setVideoUrlLow\('(.*?)'\);/) || [])[1],
          high: (videoScript.match(/html5player.setVideoUrlHigh\('(.*?)'\);/) || [])[1],
        };
        resolve({ status: 200, result: { title, URL, duration, image, files } });
      })
      .catch((err) => reject({ code: 503, status: false, result: err }));
  });
}

// set bot name
bot.command("setbotname", async (ctx) => {
  const args = ctx.message.text.split(" ").slice(1).join(" ");
  const chatId = ctx.chat.id;

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ù†Ù‡ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  if (!args) {
    return ctx.reply("ğŸ©¸ Ø§ÙƒØªØ¨ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¨ÙˆØª\nÙ…Ø«Ø§Ù„: /setbotname MyTelegramBot");
  }

  try {
    await ctx.telegram.setMyName(args);
    ctx.reply("ğŸ©¸ ØªÙ… ØªØºÙŠÙŠØ± Ø§Ø³Ù… Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­");
  } catch (err) {
    ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ ØªØºÙŠÙŠØ± Ø§Ø³Ù… Ø§Ù„Ø¨ÙˆØª");
  }
});

// 


// Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†
const DEVELOPERS = [2012345678, 2019876543]; // â† Ø­Ø· Ù‡Ù†Ø§ IDs Ø¨ØªÙˆØ¹ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†

// Ø£Ù…Ø± Ø±ÙØ¹ (Ø§Ø±ÙØ¹Ù†ÙŠ)
bot.command("up", async (ctx) => {
  const chatId = ctx.chat.id;
  const userId = ctx.from.id;
  const text = ctx.message.text.split(" ").slice(1).join(" ");

  try {
    // Ù„Ùˆ ÙƒØªØ¨ "Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†"
    if (text === "deve") {
      if (DEVELOPERS.length === 0) {
        return ctx.reply("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ Ù…Ø·ÙˆØ±ÙŠÙ†.");
      }

      for (let devId of DEVELOPERS) {
        try {
          await ctx.telegram.promoteChatMember(chatId, devId, {
            can_change_info: true,
            can_post_messages: true,
            can_edit_messages: true,
            can_delete_messages: true,
            can_invite_users: true,
            can_restrict_members: true,
            can_pin_messages: true,
            can_promote_members: true,
          });
        } catch (err) {
          console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ±Ù‚ÙŠØ© Ù…Ø·ÙˆØ±:", err);
        }
      }
      return ctx.reply("âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† ÙˆØªØ¹ÙŠÙŠÙ†Ù‡Ù… Ù…Ø´Ø±ÙÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­.");
    }

    // Ù„Ùˆ ÙƒØªØ¨ Ù…Ù† ØºÙŠØ± Ù†Øµ â†’ ØªØ±Ù‚ÙŠØªÙ‡ Ù‡Ùˆ
    const member = await ctx.telegram.getChatMember(chatId, userId);
    if (["administrator", "creator"].includes(member.status)) {
      return ctx.reply("âš ï¸ Ø£Ù†Øª Ù…Ø´Ø±Ù Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ±Ù‚ÙŠØªÙƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
    }

    await ctx.telegram.promoteChatMember(chatId, userId, {
      can_change_info: true,
      can_post_messages: true,
      can_edit_messages: true,
      can_delete_messages: true,
      can_invite_users: true,
      can_restrict_members: true,
      can_pin_messages: true,
      can_promote_members: true,
    });

    return ctx.reply("âœ… ØªÙ…Øª ØªØ±Ù‚ÙŠØªÙƒ Ø¥Ù„Ù‰ Ù…Ø´Ø±Ù ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ù†Ø¬Ø§Ø­.");

  } catch (error) {
    console.error("Ø§Ø±ÙØ¹Ù†ÙŠ error:", error);
    return ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ±Ù‚ÙŠØªÙƒ. ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±Ù.");
  }
});

// hidden tag (mention all)
bot.command("ht", async (ctx) => {
  const chatId = ctx.chat.id;

  // ØªØ­Ù‚Ù‚ Ø¥Ù†Ù‡ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ù…Ø±Ø³Ù„ Ø£Ø¯Ù…Ù† Ø£Ùˆ Ù…Ù†Ø´Ø¦
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  try {
    // Ø¬Ù„Ø¨ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    const args = ctx.message.text.split(" ").slice(1).join(" ");
    const messageText = args ? args : "ØµÙ„ÙÙ‘ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ ï·º";

    // Ù†Ø¬ÙŠØ¨ ÙƒÙ„ Ø§Ù„Ø£Ø¯Ù…Ù†Ø² (Ù„Ø£Ù† Bot API Ù…Ø´ Ø¨ÙŠØ±Ø¬Ø¹ ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡)
    const admins = await ctx.telegram.getChatAdministrators(chatId);

    // Ù†ÙƒÙˆÙ‘Ù† Ù‚Ø§Ø¦Ù…Ø© mention IDs
    const mentionIds = admins.map((a) => a.user.id);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ mentions
    await ctx.reply(messageText, {
      reply_to_message_id: ctx.message.message_id,
      allow_sending_without_reply: true,
      entities: mentionIds.map((id) => ({
        type: "mention",
        offset: 0,
        length: 0,
        user: { id },
      })),
    });

  } catch (err) {
    console.error("HT Error:", err);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° Ø£Ù…Ø± ht");
  }
});


// Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ø¹Ø±Ø¨ÙŠ -> Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ)
async function translateToEnglish(text) {
  try {
    const res = await axios.get("https://translate.googleapis.com/translate_a/single", {
      params: {
        client: "gtx",
        sl: "ar", // Ù„ØºØ© Ø§Ù„Ù…ØµØ¯Ø± (Ø¹Ø±Ø¨ÙŠ)
        tl: "en", // Ù„ØºØ© Ø§Ù„Ù‡Ø¯Ù (Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ)
        dt: "t",
        q: text,
      },
    });
    return res.data[0][0][0]; // Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù…
  } catch (err) {
    console.error("ØªØ±Ø¬Ù…Ø© ÙØ´Ù„Øª:", err.message);
    return text; // fallback: ÙŠØ±Ø¬Ø¹ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ùˆ Ø­ØµÙ„ Ø®Ø·Ø£
  }
}

async function generateDeepImage(ctx, style) {
  const text = ctx.message.text.split(" ").slice(1).join(" ");

  if (!text) {
    return ctx.reply(
      `ğŸ“Œ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n/${ctx.message.text.split(" ")[0]} <Ø§Ù„ÙˆØµÙ>\n\nÙ…Ø«Ø§Ù„:\n/${ctx.message.text.split(" ")[0]} Ù…Ø¯ÙŠÙ†Ø© Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ© Ù„ÙŠÙ„Ø§\n\nğŸ’¡ Ø³ØªÙÙˆÙ„Ø¯ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ù…Ø· ${style}.`
    );
  }

  const promptAr = text.trim();
  if (!promptAr) {
    return ctx.reply(`â— Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© ÙˆØµÙ Ù„Ù„ØµÙˆØ±Ø©. Ù…Ø«Ø§Ù„: /${ctx.message.text.split(" ")[0]} ØºØ§Ø¨Ø© Ø³Ø­Ø±ÙŠØ©`);
  }

  await ctx.reply("â³ Ø¬Ø§Ø±Ù ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙˆØµÙ ÙˆØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©...");

  // ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙˆØµÙ Ù…Ù† Ø¹Ø±Ø¨ÙŠ Ø¥Ù„Ù‰ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ
  const promptEn = await translateToEnglish(promptAr);

  const deviceId = `dev-${Math.floor(Math.random() * 1000000)}`;

  try {
    const response = await axios.post(
      "https://api-preview.chatgot.io/api/v1/deepimg/flux-1-dev",
      {
        prompt: `${promptEn} -style ${style}`,
        size: "1024x1024",
        device_id: deviceId,
      },
      {
        headers: {
          accept: "application/json",
          "Content-Type": "application/json",
          Origin: "https://deepimg.ai",
          Referer: "https://deepimg.ai/",
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        },
      }
    );

    const data = response.data;
    if (data?.data?.images?.length > 0) {
      const imageUrl = data.data.images[0].url;
      await ctx.replyWithPhoto(
        { url: imageUrl },
        {
          caption: `âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­!\n\nğŸ“„ Ø§Ù„ÙˆØµÙ (Ø¹Ø±Ø¨ÙŠ): ${promptAr}\nğŸŒ Ø§Ù„ÙˆØµÙ (Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ): ${promptEn}\nğŸ¨ Ø§Ù„Ù†Ù…Ø·: ${style}\n\nØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø© Ø¨ÙˆØ§Ø³Ø·Ø© deepseek.`,
        }
      );
    } else {
      ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©.");
    }
  } catch (err) {
    console.error(err.response ? err.response.data : err.message);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©.");
  }
}

// ğŸ–¼ï¸ Ø§Ù„Ø£ÙˆØ§Ù…Ø±
bot.command("deep_real", (ctx) => 
generateDeepImage(ctx, "realistic"));
bot.command("deep_siber", (ctx) => generateDeepImage(ctx, "cyberpunk"));
bot.command("deep_fanta", (ctx) => generateDeepImage(ctx, "fantasy"));

// kick all members
bot.command("kickall", async (ctx) => {
  const chatId = ctx.chat.id;

  // ØªØ­Ù‚Ù‚ Ø¥Ù†Ù‡ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø£Ø¯Ù…Ù†
  const me = await ctx.telegram.getChatMember(chatId, ctx.botInfo.id);
  if (me.status !== "administrator") {
    return ctx.reply("ğŸ©¸ ÙŠØ¬Ø¨ Ø£Ù† Ø£ÙƒÙˆÙ† Ø£Ø¯Ù…Ù† Ø£ÙˆÙ„Ù‹Ø§ Ù„ÙƒÙŠ Ø£Ø³ØªØ·ÙŠØ¹ Ø·Ø±Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡");
  }

  // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ù…Ø±Ø³Ù„ Ø£Ø¯Ù…Ù† Ø£Ùˆ Ù…Ù†Ø´Ø¦
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  try {
    // Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡
    const admins = await ctx.telegram.getChatAdministrators(chatId);
    const adminIds = admins.map((a) => a.user.id);

    const members = await ctx.telegram.getChat(chatId);
    if (!members || !members.members_count) {
      return ctx.reply("ğŸ•·ï¸ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©");
    }

    const kickableMembers = [];
    for (let admin of admins) {
      // Ø¨Ù†Ø¬Ù…Ø¹ ÙƒÙ„ Ø§Ù„Ø£Ø¯Ù…Ù†Ø² Ø¹Ø´Ø§Ù† Ù†Ø³ØªØ«Ù†ÙŠÙ‡Ù…
      kickableMembers.push(admin.user.id);
    }

    ctx.reply("ğŸš€ Ø¬Ø§Ø±ÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© Ø·Ø±Ø¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ (Ø¹Ø¯Ø§ Ø§Ù„Ø£Ø¯Ù…Ù†Ø² Ùˆ Ø§Ù„Ù…Ø§Ù„Ùƒ)");


    ctx.reply("ğŸ©¸ ØªÙ…Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© (Ù„ÙƒÙ† Ø¨ÙˆØª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„Ø±Ø³Ù…ÙŠ Ù…Ø§ ÙŠÙ‚Ø¯Ø±Ø´ ÙŠØ¬ÙŠØ¨ ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø¥Ù„Ø§ Ø¨Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©)");
  } catch (err) {
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø·Ø±Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡");
  }
});

// Ø£Ù…Ø± /Ø§Ø³ÙƒØ±Ø¨ØªÙŠ
bot.command("cs", async (ctx) => {
  const senderId = ctx.from.id.toString();

  if (!developers.includes(senderId)) {
    return ctx.reply("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±");
  }

  // Ù…Ø³Ø§Ø± Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø¨ÙˆØª (Ø³ÙƒØ±Ø¨)
  const botFolderPath = path.resolve("./"); 
  const zipFilePath = path.join(botFolderPath, "bot_files.zip");

  await ctx.reply("ğŸ“‚ Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙˆØª...");

  try {
    // Ù…Ù„ÙØ§Øª ÙˆÙ…Ø¬Ù„Ø¯Ø§Øª ÙŠØªÙ… Ø§Ø³ØªØ«Ù†Ø§Ø¦Ù‡Ø§
    const excluded = [
      "*.zip",
      "*.tar.gz",
      "*.tar",
      "*.rar",
      "*.7z",
      "*.gz",
      "node_modules/*",
      ".git/*",
      "cache/*",
      ".cache/*",
      ".env",
      "user.json"
    ];

    // Ø£Ù…Ø± Ø§Ù„Ø¶ØºØ·
    const zipCommand = `zip -r "${zipFilePath}" . -x ${excluded
      .map((f) => `"${f}"`)
      .join(" ")}`;

    await ctx.reply("â³ ÙŠØªÙ… Ø§Ù„Ø¢Ù† Ø¶ØºØ· Ø§Ù„Ù…Ù„ÙØ§Øª...");

    exec(zipCommand, { cwd: botFolderPath }, async (error) => {
      if (error) {
        return ctx.reply(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: ${error.message}`);
      }

      if (!fs.existsSync(zipFilePath)) {
        return ctx.reply("âŒ Ù„Ù… ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„Ù.");
      }

      await ctx.reply("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­. ÙŠØªÙ… Ø§Ù„Ø¢Ù† Ø¥Ø±Ø³Ø§Ù„Ù‡...");

      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù
      await ctx.replyWithDocument(
        { source: zipFilePath, filename: "bot_files.zip" },
      );

      // Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
      fs.unlink(zipFilePath, (err) => {
        if (err) {
          return ctx.reply(`âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù: ${err.message}`);
        }
        ctx.reply("ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„.");
      });
    });
  } catch (err) {
    await ctx.reply(`âŒ ÙØ´Ù„ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª: ${err.message}`);
  }
});

// ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨


const base = "https://www.pinterest.com";
const search = "/resource/BaseSearchResource/get/";

// Ø§Ù„Ù‡ÙŠØ¯Ø±Ø²
const reqHeaders = {
  'accept': 'application/json, text/javascript, */*, q=0.01',
  'referer': 'https://www.pinterest.com/',
  'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
  'x-app-version': 'a9522f',
  'x-pinterest-appstate': 'active',
  'x-pinterest-pws-handler': 'www/[username]/[slug].js',
  'x-requested-with': 'XMLHttpRequest'
};

// Ø¬Ù„Ø¨ Ø§Ù„ÙƒÙˆÙƒÙŠØ²
async function getCookies() {
  try {
    const response = await axios.get(base);
    const setHeaders = response.headers['set-cookie'];
    if (setHeaders) {
      return setHeaders.map(c => c.split(';')[0].trim()).join('; ');
    }
    return null;
  } catch (error) {
    console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ÙƒÙˆÙƒÙŠØ²:", error.message);
    return null;
  }
}

// Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Pinterest
async function searchPinterest(query) {
  if (!query) return { status: false, message: "âš ï¸ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ù„Ù„Ø¨Ø­Ø«!" };

  try {
    const cookies = await getCookies();
    if (!cookies) {
      return { status: false, message: "âš ï¸ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙˆÙƒÙŠØ²." };
    }

    const params = {
      source_url: `/search/pins/?q=${query}`,
      data: JSON.stringify({
        options: { isPrefetch: false, query, scope: "pins", bookmarks: [""], page_size: 10 },
        context: {}
      }),
      _: Date.now()
    };

    const { data } = await axios.get(`${base}${search}`, {
      headers: { ...reqHeaders, cookie: cookies },
      params
    });

    const results = data.resource_response.data.results.filter(v => v.images?.orig);
    if (results.length === 0) {
      return { status: false, message: `âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬: *${query}*` };
    }

    return {
      status: true,
      pins: results.map(result => ({
        id: result.id,
        title: result.title || "â€” Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù† â€”",
        description: result.description || "â€” Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ â€”",
        pin_url: `https://pinterest.com/pin/${result.id}`,
        image: result.images.orig.url,
        uploader: {
          username: result.pinner.username,
          full_name: result.pinner.full_name,
          profile_url: `https://pinterest.com/${result.pinner.username}`
        }
      }))
    };
  } catch (error) {
    console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«:", error.message);
    return { status: false, message: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«." };
  }
}

// Ø£Ù…Ø± ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
bot.command(["pinterest", "Ø¨ÙŠÙ†ØªØ±Ø³Øª"], async (ctx) => {
  const query = ctx.message.text.split(" ").slice(1).join(" ");
  if (!query) {
    return ctx.reply("ğŸ“Œ *Ù…Ø«Ø§Ù„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:*\n/pinterest Ø¯ÙŠÙƒÙˆØ± Ù…Ø·Ø¨Ø®");
  }

  await ctx.reply("âŒ› *Ø¬Ù€Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ù€Ø« ÙÙŠ Pinterest...*");

  const result = await searchPinterest(query);
  if (!result.status) {
    return ctx.reply(`âš ï¸ ${result.message}`);
  }

  for (const [i, pin] of result.pins.entries()) {
    await ctx.replyWithPhoto({ url: pin.image }, {
      caption: `ğŸ“· *Ø§Ù„ØµÙˆØ±Ø© ${i + 1}*\n\nğŸ–¼ï¸ *Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:* ${pin.title}\nğŸ“ *Ø§Ù„ÙˆØµÙ:* ${pin.description}\nğŸ‘¤ *Ø§Ù„Ù†Ø§Ø´Ø±:* ${pin.uploader.full_name} (@${pin.uploader.username})\nğŸ”— [ÙØªØ­ ÙÙŠ Pinterest](${pin.pin_url})`,
      parse_mode: "Markdown"
    });
  }
});
// Ø­Ø¬Ù… Ø§Ù„Ø®Ø±ÙŠØ·Ø©
const size = 10;
let playerData = {};

// ğŸ—ºï¸ Ø±Ø³Ù… Ø§Ù„Ø®Ø±ÙŠØ·Ø©
function renderMap(pos, end, finished = false, lost = false) {
  let map = "";
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      if (x === pos.x && y === pos.y) {
        map += "ğŸš–";
      } else if (x === end.x && y === end.y) {
        map += "ğŸ“";
      } else {
        map += "â–«ï¸";
      }
    }
    map += "\n";
  }

  if (finished) {
    map += "\nğŸ©¸ ÙˆØµÙ„Øª Ù„Ù„Ø²Ø¨ÙˆÙ†!";
  } else if (lost) {
    map += "\nâŒ Ø®Ø¨Ø·Øª ÙÙŠ Ø§Ù„Ø­ÙŠØ·Ø© Ùˆ Ø®Ø³Ø±Øª.";
  } else {
    map += "\nğŸš• Ø§ØªØ­Ø±Ùƒ Ø¹Ø´Ø§Ù† ØªÙˆØµÙ„ Ù„Ù„Ø²Ø¨ÙˆÙ† ğŸ“";
  }

  return map;
}

// ğŸš– Ø¨Ø¯Ø¡ Ø§Ù„Ù„
export default function setupTaxi(bot) {
  bot.command("taxi", async (ctx) => {
    const userId = ctx.from.id;

    const end = {
      x: Math.floor(Math.random() * size),
      y: Math.floor(Math.random() * size),
    };

    playerData[userId] = {
      pos: { x: 0, y: 0 },
      end,
      gameOver: false,
    };

    await ctx.reply(
      renderMap(playerData[userId].pos, end),
      Markup.inlineKeyboard([
        [Markup.button.callback("â¬†ï¸", "taxi_up")],
        [
          Markup.button.callback("â¬…ï¸", "taxi_left"),
          Markup.button.callback("â¡ï¸", "taxi_right"),
        ],
        [Markup.button.callback("â¬‡ï¸", "taxi_down")],
      ])
    );
  });

  bot.on("callback_query", async (ctx) => {
    const userId = ctx.from.id;
    const data = ctx.callbackQuery.data;

    if (!data.startsWith("taxi_")) return; // ØªØ¬Ø§Ù‡Ù„ Ø£ÙŠ Ø²Ø±Ø§Ø± Ù…Ø´ Ù„Ù„Ø¹Ø¨Ø©

    if (!playerData[userId] || playerData[userId].gameOver) {
      return ctx.answerCbQuery("âŒ Ù…ÙÙŠØ´ Ù„Ø¹Ø¨Ø© Ø´ØºØ§Ù„Ø© Ø¯Ù„ÙˆÙ‚ØªÙŠ");
    }

    let { pos, end } = playerData[userId];

    // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù„Ø§Ø¹Ø¨
    if (data === "taxi_up") pos.y--;
    if (data === "taxi_down") pos.y++;
    if (data === "taxi_left") pos.x--;
    if (data === "taxi_right") pos.x++;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø®Ø³Ø§Ø±Ø©
    if (pos.x < 0 || pos.y < 0 || pos.x >= size || pos.y >= size) {
      playerData[userId].gameOver = true;
      return ctx.editMessageText(renderMap(pos, end, false, true));
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
    if (pos.x === end.x && pos.y === end.y) {
      playerData[userId].gameOver = true;
      return ctx.editMessageText(renderMap(pos, end, true, false));
    }

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø®Ø±ÙŠØ·Ø©
    await ctx.editMessageText(
      renderMap(pos, end),
      Markup.inlineKeyboard([
        [Markup.button.callback("â¬†ï¸", "taxi_up")],
        [
          Markup.button.callback("â¬…ï¸", "taxi_left"),
          Markup.button.callback("â¡ï¸", "taxi_right"),
        ],
        [Markup.button.callback("â¬‡ï¸", "taxi_down")],
      ])
    );

    ctx.answerCbQuery();
  });
}


// Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø³ÙŠØ·Ø© (Ù…Ù…ÙƒÙ† ØªØºÙŠØ±Ù‡Ø§ Ø­Ø³Ø¨ Ù†Ø¸Ø§Ù…Ùƒ)
const bannedUsers = new Set();

// Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨Ø§Ù† Ùˆ Ø§Ù„Ø¨Ø§Ù†ÙÙƒ
bot.command(["ban", "unban"], async (ctx) => {
  const command = ctx.message.text.split(" ")[0].replace("/", "");
  const replyUser = ctx.message.reply_to_message
    ? ctx.message.reply_to_message.from
    : null;

  // Ù„Ø§Ø²Ù… ØªØ±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø¹Ø´Ø§Ù† ØªØ­Ø¯Ø¯ Ù…ÙŠÙ† ÙŠØªØ¨Ø§Ù†
  if (!replyUser) {
    return ctx.reply("ğŸ“Œ Ø­Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„ØªÙ‡.");
  }

  const targetId = replyUser.id;
  const targetName = replyUser.first_name;

  if (command === "ban") {
    bannedUsers.add(targetId);
    return ctx.replyWithMarkdown(
      `â²ğŸ”’â³ ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… [${targetName}](tg://user?id=${targetId})\n\nâ›Š Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ÙŠØ³ Ù„Ù‡ Ø§Ù„Ø£Ø°Ù† Ù„Ø§Ø³ØªØ¹Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¢Ù†`
    );
  }

  if (command === "unban") {
    bannedUsers.delete(targetId);
    return ctx.replyWithMarkdown(
      `â²ğŸ”“â³ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… [${targetName}](tg://user?id=${targetId})\n\nâ›Š Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù‡ Ø§Ù„Ø£Ø°Ù† Ù„Ø§Ø³ØªØ¹Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¢Ù†`
    );
  }
});

// Ù…Ø«Ø§Ù„: Ù…Ù†Ø¹ Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù…Ù† Ø§Ø³ØªØ¹Ù…Ø§Ù„ Ø£ÙŠ Ø£ÙˆØ§Ù…Ø±
bot.use((ctx, next) => {
  if (bannedUsers.has(ctx.from.id)) {
    return ctx.reply("â›” Ø£Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.");
  }
  return next();
});

const zodiak = [
    { name: "Ø§Ù„Ø¬Ø¯ÙŠ", month: 1, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø¬Ø¯ÙŠ Ø·Ù…ÙˆØ­ ÙˆÙ…Ù†Ø¸Ù…ØŒ ÙŠØ­Ø¨ Ø§Ù„Ø¹Ù…Ù„ ÙˆØ§Ù„Ø§Ø¬ØªÙ‡Ø§Ø¯ Ù„ØªØ­Ù‚ÙŠÙ‚ Ø£Ù‡Ø¯Ø§ÙÙ‡.", positive: "Ø·Ù…ÙˆØ­ØŒ Ù…Ù†Ø¸Ù…ØŒ ØµØ¨ÙˆØ±ØŒ ÙŠØªØ­Ù…Ù„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ©.", negative: "Ø¹Ù†ÙŠØ¯ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ØªØ´Ø§Ø¤Ù…ØŒ ÙŠØ­Ø¨ Ø§Ù„Ø³ÙŠØ·Ø±Ø©." },
    { name: "Ø§Ù„Ø¯Ù„Ùˆ", month: 2, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø¯Ù„Ùˆ Ù…Ø¨ØªÙƒØ± ÙˆÙ…Ø­Ø¨ Ù„Ù„Ø§Ø³ØªÙ‚Ù„Ø§Ù„ÙŠØ©. ÙŠÙ…ØªØ§Ø² Ø¨Ø§Ù„Ø£ÙÙƒØ§Ø± Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ© ÙˆØ­Ø¨ Ø§Ù„Ù…ØºØ§Ù…Ø±Ø©.", positive: "Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØŒ Ù…Ø³ØªÙ‚Ù„ØŒ ÙˆØ¯ÙˆØ¯ØŒ Ù…ØªÙØªØ­ Ø§Ù„Ø°Ù‡Ù†.", negative: "Ø¹Ù†ÙŠØ¯ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø§Ù†Ø¹Ø²Ø§Ù„ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù…ØªÙ…Ø±Ø¯Ù‹Ø§." },
    { name: "Ø§Ù„Ø­ÙˆØª", month: 3, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø­ÙˆØª Ø­Ø³Ø§Ø³ ÙˆØ¹Ø§Ø·ÙÙŠ. ÙŠØªÙ…ÙŠØ² Ø¨Ø®ÙŠØ§Ù„Ù‡ Ø§Ù„ÙˆØ§Ø³Ø¹ ÙˆØªØ¹Ø§Ø·ÙÙ‡ Ø§Ù„ÙƒØ¨ÙŠØ± Ù…Ø¹ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†.", positive: "Ø­Ø³Ø§Ø³ØŒ Ù…Ø¨Ø¯Ø¹ØŒ Ù…ØªØ¹Ø§Ø·ÙØŒ Ù…ØªÙÙ‡Ù….", negative: "Ø³Ø±ÙŠØ¹ Ø§Ù„ØªØ£Ø«Ø±ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù…ØªØ´Ø§Ø¦Ù…Ù‹Ø§." },
    { name: "Ø§Ù„Ø­Ù…Ù„", month: 4, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø­Ù…Ù„ Ø´Ø¬Ø§Ø¹ ÙˆÙ…ØºØ§Ù…Ø±. ÙŠØªÙ…ÙŠØ² Ø¨Ø§Ù„Ø·Ø§Ù‚Ø© ÙˆØ§Ù„Ø­Ù…Ø§Ø³ ÙˆØ§Ù„Ø±ØºØ¨Ø© ÙÙŠ Ù‚ÙŠØ§Ø¯Ø© Ø§Ù„Ù…ÙˆØ§Ù‚Ù.", positive: "Ø´Ø¬Ø§Ø¹ØŒ Ù…Ø¨Ø¯Ø¹ØŒ Ø­ÙŠÙˆÙŠØŒ ØµØ±ÙŠØ­.", negative: "Ø¹ØµØ¨ÙŠØŒ Ù…ØªØ³Ø±Ø¹ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ù†Ø§Ù†ÙŠØ© Ø£Ø­ÙŠØ§Ù†Ù‹Ø§." },
    { name: "Ø§Ù„Ø«ÙˆØ±", month: 5, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø«ÙˆØ± ØµØ¨ÙˆØ± ÙˆØ¹Ù…Ù„ÙŠ. ÙŠØ­Ø¨ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± ÙˆÙŠÙ…ØªÙ„Ùƒ Ø¥Ø±Ø§Ø¯Ø© Ù‚ÙˆÙŠØ© Ù„ØªØ­Ù‚ÙŠÙ‚ Ø£Ù‡Ø¯Ø§ÙÙ‡.", positive: "ØµØ¨ÙˆØ±ØŒ Ù‚ÙˆÙŠ Ø§Ù„Ø¥Ø±Ø§Ø¯Ø©ØŒ Ù…Ø®Ù„ØµØŒ ÙˆØ§Ù‚Ø¹ÙŠ.", negative: "Ø¹Ù†ÙŠØ¯ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ³Ù„ØŒ Ù…Ø§Ø¯ÙŠ Ø£Ø­ÙŠØ§Ù†Ù‹Ø§." },
    { name: "Ø§Ù„Ø¬ÙˆØ²Ø§Ø¡", month: 6, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø¬ÙˆØ²Ø§Ø¡ Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ ÙˆØ°ÙƒÙŠ. ÙŠØªÙ…ÙŠØ² Ø¨Ù…Ø±ÙˆÙ†ØªÙ‡ ÙˆÙ‚Ø¯Ø±ØªÙ‡ Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙŠÙ Ù…Ø¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ù Ø§Ù„Ù…Ø®ØªÙ„ÙØ©.", positive: "Ø°ÙƒÙŠØŒ Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØŒ Ù…Ø±Ù†ØŒ Ù…Ø±Ø­.", negative: "ØºÙŠØ± Ù…Ø³ØªÙ‚Ø±ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ØªØ±Ø¯Ø¯ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø³Ø·Ø­ÙŠÙ‹Ø§." },
    { name: "Ø§Ù„Ø³Ø±Ø·Ø§Ù†", month: 7, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø³Ø±Ø·Ø§Ù† Ø¹Ø§Ø·ÙÙŠ ÙˆÙ…Ø®Ù„Øµ. ÙŠÙ‡ØªÙ… Ø¨Ø¹Ø§Ø¦Ù„ØªÙ‡ ÙˆØ£ØµØ¯Ù‚Ø§Ø¦Ù‡ ÙˆÙŠØ­Ø¨ Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø­ÙˆÙ„Ù‡.", positive: "Ø¹Ø§Ø·ÙÙŠØŒ Ù…Ø®Ù„ØµØŒ Ø­Ù†ÙˆÙ†ØŒ Ù…Ø¨Ø¯Ø¹.", negative: "Ø­Ø³Ø§Ø³ Ø¬Ø¯Ù‹Ø§ØŒ Ù…ØªÙ‚Ù„Ø¨ Ø§Ù„Ù…Ø²Ø§Ø¬ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ØªØ´Ø¨Ø«." },
    { name: "Ø§Ù„Ø£Ø³Ø¯", month: 8, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø£Ø³Ø¯ ÙˆØ§Ø«Ù‚ ÙˆÙ…Ø¨Ø¯Ø¹. ÙŠØªÙ…ÙŠØ² Ø¨Ø§Ù„Ù‚ÙˆØ© ÙˆØ§Ù„ÙƒØ±Ù… ÙˆÙŠØ­Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ÙÙŠ Ù…Ø±ÙƒØ² Ø§Ù„Ø§Ù‡ØªÙ…Ø§Ù….", positive: "ÙˆØ§Ø«Ù‚ØŒ Ù…Ø¨Ø¯Ø¹ØŒ ÙƒØ±ÙŠÙ…ØŒ Ù‚Ø§Ø¦Ø¯ Ø¨Ø§Ù„ÙØ·Ø±Ø©.", negative: "Ù…ØªØ¹Ø¬Ø±ÙØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø³ÙŠØ·Ø±Ø©ØŒ ÙŠØ­Ø¨ Ø§Ù„Ù…Ø¯ÙŠØ­ Ø§Ù„Ø²Ø§Ø¦Ø¯." },
    { name: "Ø§Ù„Ø¹Ø°Ø±Ø§Ø¡", month: 9, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø¹Ø°Ø±Ø§Ø¡ Ø¹Ù…Ù„ÙŠ ÙˆØ¯Ù‚ÙŠÙ‚. ÙŠÙ‡ØªÙ… Ø¨Ø§Ù„ØªÙØ§ØµÙŠÙ„ ÙˆÙŠØ­Ø¨ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†.", positive: "Ù…Ù†Ø¸Ù…ØŒ Ù…Ø­Ù„Ù„ØŒ Ù…Ø¬ØªÙ‡Ø¯ØŒ Ù…Ù‡ØªÙ… Ø¨Ø§Ù„ØªÙØ§ØµÙŠÙ„.", negative: "Ù†Ø§Ù‚Ø¯ Ø¬Ø¯Ù‹Ø§ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ù„Ù‚ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù…ØªØ·Ù„Ø¨Ù‹Ø§." },
    { name: "Ø§Ù„Ù…ÙŠØ²Ø§Ù†", month: 10, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ù…ÙŠØ²Ø§Ù† Ø¹Ø§Ø¯Ù„ ÙˆØ§Ø¬ØªÙ…Ø§Ø¹ÙŠ. ÙŠØ³Ø¹Ù‰ Ù„ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„ØªÙˆØ§Ø²Ù† ÙÙŠ Ø­ÙŠØ§ØªÙ‡ ÙˆÙŠØ­Ø¨ Ø§Ù„Ø¬Ù…Ø§Ù„ ÙˆØ§Ù„ÙÙ†.", positive: "Ø¹Ø§Ø¯Ù„ØŒ Ø¯Ø¨Ù„ÙˆÙ…Ø§Ø³ÙŠØŒ Ø¬Ø°Ø§Ø¨ØŒ Ù…Ø­Ø¨ Ù„Ù„Ø¬Ù…Ø§Ù„.", negative: "Ù…ØªØ±Ø¯Ø¯ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø¥Ø±Ø¶Ø§Ø¡ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ† Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ù†ÙØ³Ù‡ØŒ ØºÙŠØ± Ø­Ø§Ø³Ù…." },
    { name: "Ø§Ù„Ø¹Ù‚Ø±Ø¨", month: 11, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ø¹Ù‚Ø±Ø¨ Ù‚ÙˆÙŠ ÙˆØ´ØºÙˆÙ. ÙŠØªÙ…ÙŠØ² Ø¨Ø§Ù„ØºÙ…ÙˆØ¶ ÙˆØ§Ù„Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù…ÙŠÙ‚.", positive: "Ø´Ø¬Ø§Ø¹ØŒ Ù‚ÙˆÙŠ Ø§Ù„Ø¥Ø±Ø§Ø¯Ø©ØŒ Ù…Ø®Ù„ØµØŒ ØºØ§Ù…Ø¶.", negative: "ØºÙŠÙˆØ±ØŒ Ù…Ø³ÙŠØ·Ø±ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø­Ø§Ù‚Ø¯Ù‹Ø§ Ø£Ø­ÙŠØ§Ù†Ù‹Ø§." },
    { name: "Ø§Ù„Ù‚ÙˆØ³", month: 12, detail: "Ù…ÙˆÙ„ÙˆØ¯ Ø¨Ø±Ø¬ Ø§Ù„Ù‚ÙˆØ³ Ù…ØºØ§Ù…Ø± ÙˆØµØ±ÙŠØ­. ÙŠØ­Ø¨ Ø§Ù„Ø­Ø±ÙŠØ© ÙˆØ§Ù„Ø³ÙØ± ÙˆØ§ÙƒØªØ´Ø§Ù Ø£Ø´ÙŠØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©.", positive: "Ù…ØºØ§Ù…Ø±ØŒ ØµØ±ÙŠØ­ØŒ Ù…ØªÙØ§Ø¦Ù„ØŒ ÙƒØ±ÙŠÙ….", negative: "ØºÙŠØ± ØµØ¨ÙˆØ±ØŒ ÙŠÙ…ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ØªÙ‡ÙˆØ±ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† ØºÙŠØ± Ù…Ù„ØªØ²Ù…." }
];

function getZodiacByMonth(month) {
    return zodiak.find(zodiac => zodiac.month === month) || { name: "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ", detail: "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±.", positive: "Ù„Ø§ Ø´ÙŠØ¡", negative: "Ù„Ø§ Ø´ÙŠØ¡" };
}

bot.command("sign", async (ctx) => {
    const args = ctx.message.text.split(" ").slice(1);
    if (!args[0]) return ctx.reply(`Ù…Ø«Ø§Ù„:\n/Ø¨Ø±Ø¬ÙŠ 3`);

    const month = parseInt(args[0]);
    if (isNaN(month) || month < 1 || month > 12) {
        return ctx.reply('lØ´Ù‡Ø± ØºÙŠØ± ØµØ§Ù„Ø­. Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ø´Ù‡Ø± Ù…Ù† 1 Ø¥Ù„Ù‰ 12.', { parse_mode: "Markdown" });
    }

    const zodiac = getZodiacByMonth(month);

    const teks = `
â”â”â”â”â”â”â°ï½¥ğ“ƒ¦ï½¥â±â”â”â”â”â”â”
â‰¡ â—¡ÌˆâƒğŸ”¥â¯
ğ“ƒ  Ø§Ù„Ø´Ù‡Ø±: ${month}

â‰¡ â—¡ÌˆâƒğŸ”¥â¯
ğ“ƒ  Ø§Ù„Ø¨Ø±Ø¬: ${zodiac.name}

â‰¡ â—¡ÌˆâƒğŸ”¥â¯
ğ“ƒ  Ø§Ù„ØªÙØ§ØµÙŠÙ„:
${zodiac.detail}

â‰¡ â—¡ÌˆâƒğŸ”¥â¯
ğ“ƒ  Ø§Ù„ØµÙØ§Øª Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©:
${zodiac.positive}

â‰¡ â—¡ÌˆâƒğŸ”¥â¯
ğ“ƒ  Ø§Ù„ØµÙØ§Øª Ø§Ù„Ø³Ù„Ø¨ÙŠØ©:
${zodiac.negative}
â”â”â”â”â”â”â°ï½¥ğ“ƒ¦ï½¥â±â”â”â”â”â”â”
`.trim();

    ctx.reply(teks, { parse_mode: "Markdown" });
});


// totag command (forward quoted message with mentions)
bot.command("totag", async (ctx) => {
  const chatId = ctx.chat.id;

  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ù…Ø±Ø³Ù„ Ø£Ø¯Ù…Ù† Ø£Ùˆ Ù…Ù†Ø´Ø¦
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  if (!ctx.message.reply_to_message) {
    return ctx.reply("ğŸ©¸ ÙŠØ¬Ø¨ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: `/totag` Ù…Ø¹ Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©", { parse_mode: "Markdown" });
  }

  try {
    // Ù†Ø­Ø§ÙˆÙ„ Ù†Ø¬ÙŠØ¨ Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ (Ø§Ù„Ù„ÙŠ ÙŠÙ‚Ø¯Ø± Ø§Ù„Ø¨ÙˆØª ÙŠØ´ÙˆÙÙ‡Ù…)
    const admins = await ctx.telegram.getChatAdministrators(chatId);
    const mentionIds = admins.map((a) => a.user.id);

    await ctx.telegram.sendMessage(chatId, ctx.message.reply_to_message.text || "ğŸ©¸", {
      reply_to_message_id: ctx.message.message_id,
      entities: mentionIds.map((id) => ({
        type: "mention",
        offset: 0,
        length: 0,
        user: { id },
      })),
    });

  } catch (err) {
    console.error("totag error:", err);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° totag");
  }
});


// tagall command (mention all with message)
bot.command("tagall", async (ctx) => {
  const chatId = ctx.chat.id;
  const args = ctx.message.text.split(" ").slice(1).join(" ");
  const sender = ctx.from.username || ctx.from.first_name;

  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ù…Ø±Ø³Ù„ Ø£Ø¯Ù…Ù† Ø£Ùˆ Ù…Ù†Ø´Ø¦
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  try {
    const membersCount = await ctx.telegram.getChatMembersCount(chatId);
    let mentions = "";
    let batch = 0;

    for (let i = 0; i < membersCount; i++) {
      try {
        const member = await ctx.telegram.getChatMember(chatId, i);
        if (member.user.is_bot) continue; // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª
        mentions += `[${member.user.first_name}](tg://user?id=${member.user.id}) `;
        
        // ÙƒÙ„ 10 Ù…Ù†Ø´Ù† Ø§Ø¨Ø¹Øª Ø±Ø³Ø§Ù„Ø© Ø¹Ø´Ø§Ù† Ù…ÙŠØªØ­Ø¸Ø±Ø´ Ø§Ù„Ø¨ÙˆØª
        if ((i + 1) % 10 === 0) {
          await ctx.telegram.sendMessage(chatId, mentions, { parse_mode: "Markdown" });
          mentions = "";
          batch++;
        }
      } catch {}
    }

    if (mentions !== "") {
      await ctx.telegram.sendMessage(chatId, mentions, { parse_mode: "Markdown" });
    }

    ctx.reply(`ğŸ©¸ ØªÙ… Ø¹Ù…Ù„ Ù…Ù†Ø´Ù† Ù„Ù„Ø¬Ù…ÙŠØ¹ Ø¨ÙˆØ§Ø³Ø·Ø©: @${sender}\nğŸ“ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: ${args || "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Øµ"}`);

  } catch (err) {
    console.error("tagall error:", err);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° tagall");
  }
});
// set bot bio
bot.command("setbotbio", async (ctx) => {
  const args = ctx.message.text.split(" ").slice(1).join(" ");
  const chatId = ctx.chat.id;

  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ•·ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  if (!args) {
    return ctx.reply("ğŸ©¸ Ø§ÙƒØªØ¨ Ø§Ù„Ø¨Ø§ÙŠÙˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¨ÙˆØª\nÙ…Ø«Ø§Ù„: /setbotbio Ø¨ÙˆØª ØªØ¬Ø±ÙŠØ¨ÙŠ");
  }

  try {
    await ctx.telegram.setMyDescription({ description: args });
    ctx.reply("ğŸ©¸ ØªÙ… ØªØºÙŠÙŠØ± Ø¨Ø§ÙŠÙˆ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­");
  } catch (err) {
    ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ ØªØºÙŠÙŠØ± Ø¨Ø§ÙŠÙˆ Ø§Ù„Ø¨ÙˆØª");
  }
});

// set group name
bot.command(["setname", "setgroupname", "setsubject"], async (ctx) => {
  const args = ctx.message.text.split(" ").slice(1).join(" ");
  const chatId = ctx.chat.id;

  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  if (!args) return ctx.reply("ğŸ©¸ Ø§ÙƒØªØ¨ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©");

  try {
    await ctx.telegram.setChatTitle(chatId, args);
    ctx.reply("ğŸ©¸ ØªÙ… ØªØºÙŠÙŠØ± Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ù†Ø¬Ø§Ø­");
  } catch (err) {
    ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ ØªØºÙŠÙŠØ± Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©");
  }
});



// Ø¯Ø§Ù„Ø© ØªØ­Ù…ÙŠÙ„ ØªÙŠÙƒ ØªÙˆÙƒ
async function tiktok(url) {
  let form = new URLSearchParams()
  form.append('q', url)
  form.append('lang', 'id')

  let { data } = await axios.post('https://tiksave.io/api/ajaxSearch', form, {
    headers: {
      'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
      'origin': 'https://tiksave.io',
      'referer': 'https://tiksave.io/id/download-tiktok-mp3',
      'user-agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36'
    }
  })

  const $ = cheerio.load(data.data)
  let title = $('.tik-left').find('.content').text().trim()
  let thumbnail = $('.tik-left').find('img').attr('src')
  let video = $('.dl-action').find('p').first().find('a').attr('href')
  let audio = $('.dl-action').find('p').last().find('a').attr('href')
  let slide = []

  $('ul.download-box').find('li').each((i, e) => {
    slide.push($(e).find('img').attr('src'))
  })

  return {
    title,
    thumbnail,
    video,
    audio,
    slide
  }
}

// Ø£Ù…Ø± Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
bot.command('ttaudio', async (ctx) => {
  const text = ctx.message.text.split(' ').slice(1).join(' ')
  if (!text) return ctx.reply('âš ï¸ Ø§Ø¨Ø¹Øª Ø±Ø§Ø¨Ø· ØªÙŠÙƒ ØªÙˆÙƒ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±\n\nÙ…Ø«Ø§Ù„:\n/ttaudio https://vm.tiktok.com/xxxx/')

  try {
    const result = await tiktok(text)
    if (!result.audio) return ctx.reply('âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø§Ù„ØµÙˆØª ÙÙŠ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¯Ù‡.')

    await ctx.replyWithAudio({ url: result.audio }, {
      title: result.title || 'tiktok-audio',
      performer: 'TikTok'
    })

  } catch (e) {
    console.error(e)
    ctx.reply('âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª Ù…Ù† ØªÙŠÙƒ ØªÙˆÙƒ.')
  }
});

// set group description
bot.command(["setdesc", "setdesk"], async (ctx) => {
  const args = ctx.message.text.split(" ").slice(1).join(" ");
  const chatId = ctx.chat.id;

  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") {
    return ctx.reply("ğŸ©¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª");
  }

  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["administrator", "creator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  if (!args) return ctx.reply("ğŸ©¸ Ø§ÙƒØªØ¨ Ø§Ù„ÙˆØµÙ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©");

  try {
    await ctx.telegram.setChatDescription(chatId, args);
    ctx.reply("ğŸ©¸ ØªÙ… ØªØºÙŠÙŠØ± ÙˆØµÙ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ù†Ø¬Ø§Ø­");
  } catch (err) {
    ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ ØªØºÙŠÙŠØ± ÙˆØµÙ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©");
  }
});
// Ø£Ù…Ø± Ø§Ù„Ø¨Ø­Ø«
bot.command("xnxxsearch", async (ctx) => {
  const query = ctx.message.text.split(" ").slice(1).join(" ");
  if (!query) return ctx.reply("âŒ Ø§ÙƒØªØ¨ ÙƒÙ„Ù…Ø© Ø§Ù„Ø¨Ø­Ø« Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /xnxxsearch test");

  const data = await xnxxsearch(query, 1);
  if (!data.status) return ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«");

  let text = "ğŸ” Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«:\n\n";
  data.result.forEach((v, i) => {
    text += `l${i + 1}.l ${v.title}\nğŸ‘¤ ${v.author} | â±ï¸ ${v.time} | ğŸ“º ${v.resolution} | ğŸ‘€ ${v.views}\nğŸ”— ${v.link}\n\n`;
  });

  ctx.reply(text, { parse_mode: "Markdown" });
});

// Ø£Ù…Ø± ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ
bot.command("xnxxdl", async (ctx) => {
  const url = ctx.message.text.split(" ").slice(1).join(" ");
  if (!url) return ctx.reply("âŒ Ø§ÙƒØªØ¨ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /xnxxdl https://www.xnxx.com/...");

  const data = await xnxxdl(url);
  if (!data.status) return ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„");

  await ctx.replyWithPhoto({ url: data.result.image }, { caption: `ğŸ¬ ${data.result.title}\nâ±ï¸ ${data.result.duration}` });

  await ctx.reply(`ğŸ¥ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„:\n\nğŸ”¹ Ø¬ÙˆØ¯Ø© Ù…Ù†Ø®ÙØ¶Ø©: ${data.result.files.low}\nğŸ”¹ Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©: ${data.result.files.high}`);
});




bot.command(["rmbg", "Ø­Ø°Ù_Ø§Ù„Ø®Ù„ÙÙŠØ©", "Ø§Ø²Ø§Ù„Ø©_Ø§Ù„Ø®Ù„ÙÙŠØ©"], async (ctx) => {
  try {
    if (!ctx.message.reply_to_message || !ctx.message.reply_to_message.photo) {
      return ctx.reply(
        "ã€ğŸ©¸Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø£Ùˆ Ù‚Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±.ğŸ©¸ã€\n\nÙ…Ø«Ø§Ù„:\n/rmbg (Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø©)"
      );
    }

    await ctx.reply("ğŸ•’ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
    const fileId =
      ctx.message.reply_to_message.photo[
        ctx.message.reply_to_message.photo.length - 1
      ].file_id;

    const fileLink = await ctx.telegram.getFileLink(fileId);
    const imageBuffer = (
      await axios.get(fileLink.href, { responseType: "arraybuffer" })
    ).data;

    const filename = `upload.png`;
    const result = await Uguu(imageBuffer, filename);

    // API Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø®Ù„ÙÙŠØ©
    const { data } = await axios.get(
      `https://www.abella.icu/rmbg?url=${result.url}`,
      { responseType: "arraybuffer" }
    );

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©
    await ctx.replyWithPhoto({ source: Buffer.from(data) });
  } catch (error) {
    console.error(error);
    await ctx.reply(`ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£: ${error.message || error}`);
  }
});

// Ø£Ù…Ø± Ø§Ù„ØªØ­ÙˆÙŠÙ„


// Ø£Ù…Ø± /tourl
bot.command("to_url", async (ctx) => {
  const repliedMsg = ctx.message.reply_to_message;

  // Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠÙ‡ Ø±ÙŠØ¨Ù„Ø§ÙŠ Ø¹Ù„Ù‰ Ù…Ù„Ù/ØµÙˆØ±Ø©/ÙÙŠØ¯ÙŠÙˆ
  if (
    !repliedMsg ||
    (!repliedMsg.document && !repliedMsg.photo && !repliedMsg.video)
  ) {
    return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„Ø§ÙŠ Ø¹Ù„Ù‰ Ù…Ù„Ù / ØµÙˆØ±Ø© / ÙÙŠØ¯ÙŠÙˆ Ù…Ø¹ Ø§Ù„Ø£Ù…Ø± /tourl");
  }

  let fileId, fileName;

  if (repliedMsg.document) {
    fileId = repliedMsg.document.file_id;
    fileName = repliedMsg.document.file_name || `file_${Date.now()}`;
  } else if (repliedMsg.photo) {
    const photos = repliedMsg.photo;
    fileId = photos[photos.length - 1].file_id; // Ø£Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø© ØµÙˆØ±Ø©
    fileName = `photo_${Date.now()}.jpg`;
  } else if (repliedMsg.video) {
    fileId = repliedMsg.video.file_id;
    fileName = `video_${Date.now()}.mp4`;
  }

  try {
    const processingMsg = await ctx.reply("ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¹Ù„Ù‰ Catbox...");

    // Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù„Ù Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
    const file = await ctx.telegram.getFile(fileId);
    const fileLink = `https://api.telegram.org/file/bot${bot.token}/${file.file_path}`;

    const response = await axios.get(fileLink, { responseType: "stream" });

    const form = new FormData();
    form.append("reqtype", "fileupload");
    form.append("fileToUpload", response.data, {
      filename: fileName,
      contentType: response.headers["content-type"],
    });

    const { data: catboxUrl } = await axios.post(
      "https://catbox.moe/user/api.php",
      form,
      {
        headers: form.getHeaders(),
      }
    );

    if (!catboxUrl.startsWith("https://")) {
      throw new Error("Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù„Ù… ÙŠØ±Ø¬Ø¹ Ø±Ø§Ø¨Ø· ØµØ§Ù„Ø­");
    }

    await ctx.telegram.editMessageText(
      ctx.chat.id,
      processingMsg.message_id,
      null,
      `ğŸ©¸ ØªÙ… Ø§Ù„Ø±ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­!\nğŸ“ Ø§Ù„Ø±Ø§Ø¨Ø·: ${catboxUrl}`
    );
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø±ÙØ¹:", error?.response?.data || error.message);
    ctx.reply("âŒ ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Catbox");
  }
});

// Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø²Ø± Ø§Ù„Ù†Ø³Ø®
bot.on("callback_query", async (ctx) => {
  const data = ctx.callbackQuery.data;
  if (data.startsWith("copy_")) {
    const link = data.replace("copy_", "");
    await ctx.answerCbQuery("ğŸ©¸ ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø±Ø§Ø¨Ø·!");
    await ctx.reply(`ğŸ“‹ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†Ø³ÙˆØ®:\n${link}`);
  }
});

// Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª
async function makeEphoto(url, text) {
  const { data: html } = await axios.get(url, {
  headers: {
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "referer": "https://en.ephoto360.com/",
    "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8"
  }
});

  const $ = cheerio.load(html);
  const form = $("form").first();
  let action = form.attr("action");
  if (!action) throw new Error("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙÙˆØ±Ù…");

  // Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø±Ø§Ø¨Ø· (Ù„Ùˆ ÙƒØ§Ù† relative path)
  if (!action.startsWith("http")) {
    action = new URL(action, "https://en.ephoto360.com").href;
  }

  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  const formData = new URLSearchParams();
  form.find("input").each((i, el) => {
    const name = $(el).attr("name");
    const value = $(el).attr("value") || "";
    if (name) formData.append(name, value);
  });
  formData.append("text[]", text);

  // POST Ù„Ù„Ù€ action
  const { data: resultHtml } = await axios.post(action, formData.toString(), {
    headers: {
      "user-agent": "Mozilla/5.0",
      "content-type": "application/x-www-form-urlencoded"
    }
  });

  const $$ = cheerio.load(resultHtml);
  const img = $$(".thumbnail img").attr("src");
  if (!img) throw new Error("âŒ ÙØ´Ù„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØµÙˆØ±Ø©");

  // Ø¥Ø±Ø¬Ø§Ø¹ Ù„ÙŠÙ†Ùƒ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
  return img.startsWith("http") ? img : `https://en.ephoto360.com${img}`;
}

bot.command([
  "glitchtext", "writetext", "advancedglow", "typographytext", "pixelglitch",
  "neonglitch", "flagtext", "flag3dtext", "deletingtext", "blackpinkstyle",
  "glowingtext", "underwatertext", "logomaker", "cartoonstyle", "papercutstyle",
  "watercolortext", "effectclouds", "blackpinklogo", "gradienttext", "summerbeach",
  "luxurygold", "multicoloredneon", "sandsummer", "galaxywallpaper", "1917style",
  "makingneon", "royaltext", "freecreate", "galaxystyle", "lighteffects"
], async (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  const command = ctx.message.text.split(" ")[0].replace("/", "").toLowerCase();

  if (!text) {
    return ctx.reply("âŒ— Ø§ÙƒØªØ¨ Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±.\nÙ…Ø«Ø§Ù„:\n/" + command + " LoliBot");
  }

  await ctx.reply("â±ï¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...");

  // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù„ÙŠÙ†ÙƒØ§Øª (Ø±ÙˆØ§Ø¨Ø· ÙƒØ§Ù…Ù„Ø©)
  const links = {
    glitchtext: "https://en.ephoto360.com/create-digital-glitch-text-effects-online-767.html",
    writetext: "https://en.ephoto360.com/write-text-on-wet-glass-online-589.html",
    advancedglow: "https://en.ephoto360.com/advanced-glow-effects-74.html",
    typographytext: "https://en.ephoto360.com/create-typography-text-effect-on-pavement-online-774.html",
    pixelglitch: "https://en.ephoto360.com/create-pixel-glitch-text-effect-online-769.html",
    neonglitch: "https://en.ephoto360.com/create-impressive-neon-glitch-text-effects-online-768.html",
    flagtext: "https://en.ephoto360.com/nigeria-3d-flag-text-effect-online-free-753.html",
    flag3dtext: "https://en.ephoto360.com/free-online-american-flag-3d-text-effect-generator-725.html",
    deletingtext: "https://en.ephoto360.com/create-eraser-deleting-text-effect-online-717.html",
    blackpinkstyle: "https://en.ephoto360.com/online-blackpink-style-logo-maker-effect-711.html",
    glowingtext: "https://en.ephoto360.com/create-glowing-text-effects-online-706.html",
    underwatertext: "https://en.ephoto360.com/3d-underwater-text-effect-online-682.html",
    logomaker: "https://en.ephoto360.com/free-bear-logo-maker-online-673.html",
    cartoonstyle: "https://en.ephoto360.com/create-a-cartoon-style-graffiti-text-effect-online-668.html",
    papercutstyle: "https://en.ephoto360.com/multicolor-3d-paper-cut-style-text-effect-658.html",
    watercolortext: "https://en.ephoto360.com/create-a-watercolor-text-effect-online-655.html",
    effectclouds: "https://en.ephoto360.com/write-text-effect-clouds-in-the-sky-online-619.html",
    blackpinklogo: "https://en.ephoto360.com/create-blackpink-logo-online-free-607.html",
    gradienttext: "https://en.ephoto360.com/create-3d-gradient-text-effect-online-600.html",
    summerbeach: "https://en.ephoto360.com/write-in-sand-summer-beach-online-free-595.html",
    luxurygold: "https://en.ephoto360.com/create-a-luxury-gold-text-effect-online-594.html",
    multicoloredneon: "https://en.ephoto360.com/create-multicolored-neon-light-signatures-591.html",
    sandsummer: "https://en.ephoto360.com/write-in-sand-summer-beach-online-576.html",
    galaxywallpaper: "https://en.ephoto360.com/create-galaxy-wallpaper-mobile-online-528.html",
    "1917style": "https://en.ephoto360.com/1917-style-text-effect-523.html",
    makingneon: "https://en.ephoto360.com/making-neon-light-text-effect-with-galaxy-style-521.html",
    royaltext: "https://en.ephoto360.com/royal-text-effect-online-free-471.html",
    freecreate: "https://en.ephoto360.com/free-create-a-3d-hologram-text-effect-441.html",
    galaxystyle: "https://en.ephoto360.com/create-galaxy-style-free-name-logo-438.html",
    lighteffects: "https://en.ephoto360.com/create-light-effects-green-neon-online-429.html"
  };

  try {
    const url = links[command];
    if (!url) return ctx.reply("âŒ Ø§Ù„Ø£Ù…Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.");

    const result = await makeEphoto(url, text); // Ù„Ø§Ø²Ù… Ù‡Ù†Ø§ makeEphoto ÙŠØ±Ø¬Ø¹ Ù„ÙŠÙ†Ùƒ ØµÙˆØ±Ø© ÙƒØ§Ù…Ù„
    await ctx.replyWithPhoto({ url: result }, { caption: "ğŸ©¸ ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­" });
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©.");
  }
});


// yespotato telegram bot - supports info / video / mp3 / thumbnail / tags

// config (from your original code)
const SHARED_SECRET = "4W5crB-=A/klR]!";
const ORIGIN = "http://192.168.251.190:3000"; // ÙƒÙ…Ø§ ÙÙŠ ÙƒÙˆØ¯Ùƒ Ø§Ù„Ø£ØµÙ„ÙŠ
const YESP_BASE = "https://yespotato.com";

// helper to build signature & headers
function makeSignaturePayload() {
  const ts = Date.now();
  const payload = `${ts}|${ORIGIN}|${SHARED_SECRET}`;
  const signature = CryptoJS.SHA256(payload).toString();
  return { signature, ts };
}

function baseHeaders() {
  return {
    "Content-Type": "application/json",
    origin: "https://yespotato.com",
    referer: "https://yespotato.com/",
    "User-Agent":
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  };
}

// ----------------- core API helpers -----------------
async function callYoutu999(url) {
  const { signature, ts } = makeSignaturePayload();
  const body = { signature, ts, url };
  const res = await axios.post(`${YESP_BASE}/youtu999`, body, { headers: baseHeaders() });
  return res.data; // expected structure: data.urls, data.title, data.thumbnail, data.tags...
}

async function triggerDownloadOnServer(videoUrl, audioUrl, videoSize = 0, audioSize = 0, fileType = "video", has_audio = "false") {
  // fileType: 'video' or 'audio'
  const body = {
    contentLength: videoSize || 0,
    file_type: fileType,
    has_audio: has_audio,
    url: videoUrl,
    audioSize: audioSize || 0,
    audioURL: audioUrl || ""
  };
  const res = await axios.post(`${YESP_BASE}/download-file`, body, { headers: baseHeaders() });
  return res.data; // expects resp.data.file_name
}

async function pollProgress(fileName, attempts = 40, interval = 2000) {
  if (!fileName) throw new Error("missing file name for progress check");
  for (let i = 0; i < attempts; i++) {
    const res = await axios.get(`${YESP_BASE}/progress/${fileName}`, { headers: baseHeaders() });
    const data = res.data;
    if (data?.status === "done" || data?.status === "100" || data?.status === 2) {
      // return object with paths
      return data;
    }
    await new Promise(r => setTimeout(r, interval));
  }
  throw new Error("progress timeout");
}

async function triggerEncode(videoPath, audioPath) {
  const body = { video_url: videoPath, audio_url: audioPath };
  const res = await axios.post(`${YESP_BASE}/encode`, body, { headers: baseHeaders() });
  return res.data; // should contain data.file_name or similar
}

async function pollMergeProgress(fileName, attempts = 40, interval = 2000) {
  if (!fileName) throw new Error("missing file name for merge-progress");
  for (let i = 0; i < attempts; i++) {
    const res = await axios.get(`${YESP_BASE}/merge-progress/${fileName}`, { headers: baseHeaders() });
    const data = res.data;
    if (data?.status === "done" || data?.status === "100" || data?.status === 2) {
      return data;
    }
    await new Promise(r => setTimeout(r, interval));
  }
  throw new Error("merge timeout");
}

// helper to send file to telegram (tries file upload; fallback to sending link)
async function safeSendFile(ctx, url, filename, caption = "") {
  try {
    // Try as document first (more universal)
    await ctx.replyWithDocument({ url, filename }, { caption });
  } catch (err1) {
    try {
      // try as video
      await ctx.replyWithVideo({ url }, { caption });
    } catch (err2) {
      // fallback: send direct link
      await ctx.reply(`${caption}\n\nğŸ”— Direct link: ${url}`);
    }
  }
}

// ----------------- Commands -----------------

// /ytinfo <url>
bot.command("ytinfo", async (ctx) => {
  try {
    const args = ctx.message.text.split(" ").slice(1);
    const url = args[0];
    if (!url) return ctx.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /ytinfo <YouTube URL>");

    await ctx.reply("â³ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...");

    const res = await callYoutu999(url);
    const data = res?.data || res; // sometimes wrapper or raw

    // build response
    const title = data?.title || data?.video_title || "Unknown title";
    const thumbnail = data?.thumbnail || data?.thumb || data?.poster;
    const urls = data?.urls || [];
    const tags = data?.tags || data?.keywords || [];

    let qualities = "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬ÙˆØ¯Ø§Øª Ù…ØªØ§Ø­Ø©";
    if (Array.isArray(urls) && urls.length) {
      qualities = urls.map(u => `${u.qualityLabel || u.format || u.quality || "unknown"} (${u.mimeType || ""})`).join("\n");
    }

    let reply = `*${title}*\n\n*Available formats:*\n${qualities}\n\n`;
    if (tags && tags.length) reply += `*Tags:* ${Array.isArray(tags) ? tags.join(", ") : tags}\n`;
    if (thumbnail) reply += `\nğŸ”— Thumbnail: ${thumbnail}`;

    await ctx.replyWithMarkdown(reply);
  } catch (e) {
    console.error("ytinfo error:", e?.toString ? e.toString() : e);
    ctx.reply("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.");
  }
});

// /ytdl <url> [quality]
bot.command("ytdl", async (ctx) => {
  try {
    const parts = ctx.message.text.split(" ").slice(1);
    const url = parts[0];
    const wantedQuality = parts[1] || "480p";
    if (!url) return ctx.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /ytdl <YouTube URL> [quality]");

    await ctx.reply("â³ Ø¬Ø§Ø±ÙŠ ØªØ¬Ù‡ÙŠØ² Ø§Ù„ÙÙŠØ¯ÙŠÙˆ â€” Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ ÙˆÙ‚ØªÙ‹Ø§...");

    const infoRes = await callYoutu999(url);
    const data = infoRes?.data || infoRes;
    const urls = data?.urls || [];

    // find chosen quality video stream (video-only) and audio stream
    const videoItem =
      urls.find(
        (u) =>
          u.qualityLabel === wantedQuality ||
          (u.format && u.format.includes(wantedQuality))
      ) ||
      urls.find((u) => u.qualityLabel && u.qualityLabel.includes(wantedQuality)) ||
      urls.find((u) => u.mimeType && u.mimeType.includes("video"));

    const audioItem =
      urls.find((u) => u.mimeType && u.mimeType.includes("audio")) ||
      urls.find(
        (u) =>
          u.qualityLabel && u.qualityLabel.toLowerCase().includes("audio")
      );

    if (!videoItem) return ctx.reply("âš ï¸ Ù„Ù… Ø£Ø¬Ø¯ Ø¨Ø«Ù‘ ÙÙŠØ¯ÙŠÙˆ Ø¨Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©.");

    // trigger server download
    const downloadResp = await triggerDownloadOnServer(
      videoItem.url,
      audioItem?.url || "",
      videoItem.contentLength || 0,
      audioItem?.contentLength || 0,
      "video",
      "false"
    );
    const fileName =
      downloadResp?.file_name || downloadResp?.data?.file_name;
    if (!fileName) return ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±.");

    // poll for progress
    const progress = await pollProgress(fileName);

    // encode (merge)
    const encodeResp = await triggerEncode(
      progress.video_path ||
        progress.data?.video_path ||
        progress?.video_path,
      progress.audio_path ||
        progress.data?.audio_path ||
        progress?.audio_path
    );
    const encFileName =
      encodeResp?.file_name || encodeResp?.data?.file_name;
    if (!encFileName) return ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ù…ÙŠØ²/Ø§Ù„Ø¯Ù…Ø¬.");

    const merge = await pollMergeProgress(encFileName);
    const outputLink = merge?.outputLink || merge?.data?.outputLink;
    const downloadUrl = outputLink
      ? outputLink.startsWith("http")
        ? outputLink
        : `${YESP_BASE}${outputLink}`
      : null;

    if (!downloadUrl)
      return ctx.reply("âŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„ØªØ­Ù…ÙŠÙ„.");

    const title = data?.title || "video";

    try {
      // Ù†Ø¬Ø±Ø¨ ÙƒÙ€ video
      await ctx.replyWithVideo(
        { url: downloadUrl },
        { caption: `âœ… ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ â€” *${title}*`, parse_mode: "Markdown" }
      );
    } catch (e1) {
      try {
        // Ù„Ùˆ ÙØ´Ù„ Ù†Ø¨Ø¹ØªÙ‡ ÙƒÙ€ document
        await ctx.replyWithDocument(
          { url: downloadUrl, filename: `${title}.mp4` },
          { caption: `âœ… ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ â€” *${title}*`, parse_mode: "Markdown" }
        );
      } catch (e2) {
        // Ø¢Ø®Ø± Ø­Ù„ Ù†Ø¯ÙŠ Ø§Ù„Ù„ÙŠÙ†Ùƒ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await ctx.reply(
          `âš ï¸ Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙƒØªÙ„ÙŠØ¬Ø±Ø§Ù….\n\nğŸ”— Ø­Ù…Ù„Ù‡ Ù…Ù† Ù‡Ù†Ø§: ${downloadUrl}`
        );
      }
    }
  } catch (err) {
    console.error("âŒ ytdl command error:", err);
    await ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ.");
  }
});
    // try to send fil

// /ytmp3 <url>
bot.command("yt", async (ctx) => {
  try {
    const args = ctx.message.text.split(" ").slice(1);
    const url = args[0];
    if (!url) return ctx.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /ytmp3 <YouTube URL>");

    await ctx.reply("â³ Ø¬Ø§Ø±ÙŠ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ...");

    const infoRes = await callYoutu999(url);
    const data = infoRes?.data || infoRes;
    const urls = data?.urls || [];

    // pick audio stream
    const audioItem = urls.find(u => u.mimeType && u.mimeType.includes('audio')) || urls.find(u => (u.format && u.format.includes('audio')));

    if (!audioItem) return ctx.reply("âš ï¸ Ù„Ù… Ø£Ø¬Ø¯ Ø¨Ø« ØµÙˆØªÙŠ Ù…ØªØ§Ø­.");

    // Try to trigger server to prepare audio-only
    const downloadResp = await triggerDownloadOnServer(audioItem.url, "", 0, audioItem.contentLength || 0, "audio", "true");
    const fileName = downloadResp?.file_name || downloadResp?.data?.file_name;
    if (!fileName) return ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±.");

    const progress = await pollProgress(fileName);
    // for audio maybe no encode needed; check progress data for audio_path or output
    let finalLink = progress?.audio_path || progress?.outputLink || progress?.data?.outputLink;
    if (!finalLink) {
      // if server gives video/audio paths then try encode with only audio -> sometimes API provides output after merge-progress
      try {
        const maybeEnc = await triggerEncode(progress.video_path || "", progress.audio_path || "");
        const merge = await pollMergeProgress(maybeEnc?.file_name || maybeEnc?.data?.file_name);
        finalLink = merge?.outputLink || (merge?.data?.outputLink) || finalLink;
      } catch (e) {
        // ignore
      }
    }

    const downloadUrl = finalLink ? (finalLink.startsWith('http') ? finalLink : `${YESP_BASE}${finalLink}`) : null;
    if (!downloadUrl) return ctx.reply("âŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„ØµÙˆØª.");

    const title = data?.title || "audio";
    // try send as audio
    try {
      await ctx.replyWithAudio({ url: downloadUrl, filename: `${title}.mp3` }, { caption: `âœ… ${title}` });
    } catch (e) {
      // fallback to document
      await safeSendFile(ctx, downloadUrl, `${title}.mp3`, `âœ… ${title}`);
    }
  } catch (e) {
    console.error("ytmp3 error:", e?.toString ? e.toString() : e);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ.");
  }
});

// /ytthumb <url>
bot.command("ytthumb", async (ctx) => {
  try {
    const args = ctx.message.text.split(" ").slice(1);
    const url = args[0];
    if (!url) return ctx.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /ytthumb <YouTube URL>");
    await ctx.reply("â³ Ø¬Ù„Ø¨ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…ØµØºØ±Ø©...");

    const res = await callYoutu999(url);
    const data = res?.data || res;
    const thumb = data?.thumbnail || data?.thumb || data?.poster;
    if (!thumb) return ctx.reply("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ thumbnail.");
    await ctx.replyWithPhoto(thumb);
  } catch (e) {
    console.error("ytthumb error:", e?.toString ? e.toString() : e);
    ctx.reply("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…ØµØºØ±Ø©.");
  }
});

// /yttags <url>
bot.command("yttags", async (ctx) => {
  try {
    const args = ctx.message.text.split(" ").slice(1);
    const url = args[0];
    if (!url) return ctx.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /yttags <YouTube URL>");

    await ctx.reply("â³ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...");
    const res = await callYoutu999(url);
    const data = res?.data || res;
    const tags = data?.tags || data?.keywords || [];
    const desc = data?.description || data?.desc || "";

    let reply = "";
    if (Array.isArray(tags) && tags.length) reply += `*Tags:* ${tags.join(", ")}\n\n`;
    if (desc) reply += `*Description:*\n${desc}`;

    if (!reply) reply = "âš ï¸ Ù„Ù… ØªØªÙˆÙØ± tags Ø£Ùˆ ÙˆØµÙ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.";
    await ctx.replyWithMarkdown(reply);
  } catch (e) {
    console.error("yttags error:", e?.toString ? e.toString() : e);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù€ tags.");
  }
});

// ------------- start bot -------------

bot.command(['Ø§Ø­Ø³Ø¨', 'calc', 'calcular', 'calculadora'], async (ctx) => {
  const text = ctx.message.text.split(' ').slice(1).join(' ')
  if (!text) {
    return ctx.reply('ğŸ“Œ Ù‡Ø§Øª Ù…Ø¹Ø§Ø¯Ù„Ø© Ù„Ù„Ø­Ø³Ø§Ø¨ØŒ Ù…Ø«Ø§Ù„:\n`/Ø§Ø­Ø³Ø¨ 5+5` Ø£Ùˆ `/Ø§Ø­Ø³Ø¨ 5Ã—5`', { parse_mode: 'Markdown' })
  }

  let val = text
    .replace(/[^0-9\-\/+*Ã—Ã·Ï€Ee()piPI/]/g, '')
    .replace(/Ã—/g, '*')
    .replace(/Ã·/g, '/')
    .replace(/Ï€|pi/gi, 'Math.PI')
    .replace(/e/gi, 'Math.E')
    .replace(/\/+/g, '/')
    .replace(/\++/g, '+')
    .replace(/-+/g, '-')

  let format = val
    .replace(/Math\.PI/g, 'Ï€')
    .replace(/Math\.E/g, 'e')
    .replace(/\//g, 'Ã·')
    .replace(/\*/g, 'Ã—')

  try {
    let result = (new Function('return ' + val))()
    if (result === undefined) throw result
    ctx.reply(`${format} = _${result}_`, { parse_mode: 'Markdown' })
  } catch (e) {
    if (e == undefined) {
      return ctx.reply('ğŸ“Œ Ù‡Ø§Øª Ø¹Ø¯Ø¯ Ø£Ùˆ Ù…Ø¹Ø§Ø¯Ù„Ø© ØµØ­ÙŠØ­Ø©ØŒ Ù…Ø«Ø§Ù„:\n`/Ø§Ø­Ø³Ø¨ 5+5` Ø£Ùˆ `/Ø§Ø­Ø³Ø¨ 5Ã—5`', { parse_mode: 'Markdown' })
    }
    return ctx.reply('âŒ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ­ÙŠØ­.\nØ§Ø³ØªØ®Ø¯Ù… ÙÙ‚Ø·: 0-9 Ùˆ -, +, *, /, Ã—, Ã·, Ï€, e, (, )')
  }
})

// ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª()


bot.command(["toanime", "Ø§Ù†Ù…ÙŠ"], async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;
    if (!reply || !reply.photo) {
      return ctx.reply("âŒ— âœ§ï¸™Ù‚Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ù„Ù„ØªØ­ÙˆÙŠÙ„ âœ¨ğŸ­");
    }

    await ctx.reply("â±ï¸ Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ø£Ù†Ù…ÙŠ...");

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª WebSocket
    const WS_URL = "wss://pixnova.ai/demo-photo2anime/queue/join";
    const IMAGE_URL = "https://oss-global.pixnova.ai/";
    const SESSION = crypto.randomBytes(5).toString("hex").slice(0, 9);

    let wss;
    let promise;

    function _connect() {
      return new Promise((resolve, reject) => {
        wss = new WebSocket(WS_URL);
        wss.on("open", () => resolve());
        wss.on("error", reject);
        wss.on("message", (chunk) => {
          const data = JSON.parse(chunk.toString());
          if (promise && promise.once) {
            promise.call(data);
            promise = null;
          } else if (promise && !promise.once) {
            if (data?.code == 200 && data?.success) {
              data.output.result = data.output.result.map(r => IMAGE_URL + r);
              promise.call(data);
              promise = null;
            }
          }
        });
      });
    }

    function _send(payload, pr) {
      return new Promise(resolve => {
        wss.send(JSON.stringify(payload));
        promise = { once: pr, call: resolve };
      });
    }

    async function PixNova(data, buffer) {
      const base64Image = buffer.toString("base64");
      await _connect();
      await _send({ session_hash: SESSION }, true);
      const payload = {
        data: {
          source_image: `data:image/jpeg;base64,${base64Image}`,
          strength: data.strength || 0.6,
          prompt: data.prompt,
          negative_prompt: data.negative,
          request_from: 2
        }
      };
      return await _send(payload, false);
    }

    // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ÙÙˆÙ„Ø¯Ø± temp
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const tempDir = path.join(__dirname, "temp");

    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);

    // ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ temp
    const fileId = reply.photo[reply.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const res = await fetch(fileLink.href);
    const buffer = Buffer.from(await res.arrayBuffer());

    const tempPath = path.join(tempDir, `toanime_${Date.now()}.jpg`);
    fs.writeFileSync(tempPath, buffer);

    try {
      const DATA = {
        prompt: "(masterpiece), best quality",
        negative: "(worst quality, low quality:1.4), blurry, watermark, text, cropped",
        strength: 0.6
      };

      const result = await PixNova(DATA, buffer);

      await ctx.replyWithPhoto({ url: result.output.result[0] }, { caption: "âœ¨ âŒ— ØªÙ… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø£Ù†Ù…ÙŠ Ø¨Ù†Ø¬Ø§Ø­ ğŸ­" });

    } catch (e) {
      console.error(e);
      ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© âŒ");
    } finally {
      // Ù…Ø³Ø­ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† temp
      fs.unlinkSync(tempPath);
    }

  } catch (err) {
    console.error(err);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹");
  }
});

// Ø¯Ø§Ù„Ø© Ø±ÙØ¹ Ø¹Ù„Ù‰ file.io
async function uploadFileIO(fileUrl) {
  const response = await axios.get(fileUrl, { responseType: "arraybuffer" });
  const buffer = Buffer.from(response.data);

  const form = new FormData();
  form.append("file", buffer, "file.jpg");

  const upload = await axios.post("https://file.io", form, {
    headers: form.getHeaders(),
  });

  if (upload.data.success) {
    return upload.data.link; // Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ù† file.io
  } else {
    throw new Error("ÙØ´Ù„ Ø§Ù„Ø±ÙØ¹: " + JSON.stringify(upload.data));
  }
}

// Ø¯Ø§Ù„Ø© Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø±Ø§Ø¨Ø·
async function shortUrl(url) {
  try {
    let res = await fetch(`https://tinyurl.com/api-create.php?url=${url}`);
    if (!res.ok) throw new Error("Failed to shorten URL");
    return await res.text();
  } catch (e) {
    console.error(e);
    return url;
  }
}

const LimitAud = 725 * 1024 * 1024; // 725MB
const LimitVid = 425 * 1024 * 1024; // 425MB
const youtubeRegexID = /(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/))([a-zA-Z0-9_-]{11})/;

const userRequests = {};

async function searchYT(query, options = {}) {
  const search = await yts.search({ query, hl: "es", gl: "ES", ...options });
  return search.videos;
}

async function getFileSize(url) {
  try {
    const response = await fetch(url, { method: "HEAD" });
    return parseInt(response.headers.get("content-length") || 0);
  } catch {
    return 0;
  }
}

// ğŸµ Ø£ÙˆØ§Ù…Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª / Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
bot.command(["p", "play2", "play3", "play4", "musica", "video"], async (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  const command = ctx.message.text.split(" ")[0].replace("/", "");

  if (!text) {
    return ctx.reply(
      `ğŸ¤” Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„ÙŠ Ø¨ØªØ¯ÙˆØ± Ø¹Ù„ÙŠÙ‡ ØŸ`
    );
  }

  if (userRequests[ctx.from.id]) {
    return ctx.reply(`ğŸ©¸ Hey @${ctx.from.username || ctx.from.id}, espera ğŸ™„`);
  }
  userRequests[ctx.from.id] = true;

  try {
    let videoIdToFind = text.match(youtubeRegexID) || null;
    const yt_play = await searchYT(text);
    let ytplay2 = await yts(
      videoIdToFind === null ? text : "https://youtu.be/" + videoIdToFind[1]
    );

    if (videoIdToFind) {
      const videoId = videoIdToFind[1];
      ytplay2 =
        ytplay2.all.find((item) => item.videoId === videoId) ||
        ytplay2.videos.find((item) => item.videoId === videoId);
    }
    ytplay2 = ytplay2.all?.[0] || ytplay2.videos?.[0] || ytplay2;

    // Ø£Ù†Ø¸Ù…Ø© Ø­Ø³Ø¨ Ø§Ù„Ø£Ù…Ø±
    switch (command) {
      case "p":
      case "musica": {
        const data = await mohnd.download(yt_play[0].url, "mp3");
        const fileSize = await getFileSize(data.result.download);
        if (fileSize > LimitAud) {
          await ctx.replyWithDocument({ url: data.result.download }, { caption: yt_play[0].title });
        } else {
          await ctx.replyWithAudio({ url: data.result.download }, { caption: yt_play[0].title });
        }
        break;
      }

      case "play2":
      case "video": {
        const data = await mohnd.download(yt_play[0].url, "720");
        const fileSize = await getFileSize(data.result.download);
        if (fileSize > LimitVid) {
          await ctx.replyWithDocument({ url: data.result.download }, { caption: yt_play[0].title });
        } else {
          await ctx.replyWithVideo({ url: data.result.download }, { caption: yt_play[0].title });
        }
        break;
      }

      case "play3": {
        const data = await mohnd.download(yt_play[0].url, "mp3");
        await ctx.replyWithDocument({ url: data.result.download }, { caption: yt_play[0].title });
        break;
      }

      case "play4": {
        const data = await mohnd.download(yt_play[0].url, "720");
        await ctx.replyWithDocument({ url: data.result.download }, { caption: yt_play[0].title });
        break;
      }
    }
  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„.");
  } finally {
    delete userRequests[ctx.from.id];
  }
});

// Ø¯Ø§Ù„Ø© Ù…Ù†Ø´Ù†
function mention(user) {
  return `<a href="tg://user?id=${user.user.id}">${user.user.first_name}</a>`;
}

bot.command("mary", async (ctx) => {
  try {
    const chatId = ctx.chat.id;

    // Ù‡Ø§Øª ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ (Ø£Ø¯Ù…Ù† + Ø£Ø¹Ø¶Ø§Ø¡ Ø¹Ø§Ø¯ÙŠÙŠÙ†)
    const admins = await ctx.telegram.getChatAdministrators(chatId);

    if (!admins || admins.length < 2) {
      return ctx.reply("âŒ Ù…ÙÙŠØ´ Ø£Ø¹Ø¶Ø§Ø¡ ÙƒÙØ§ÙŠØ© ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ Ù„Ù„Ø¹Ø¨Ø©.");
    }

    // Ù†Ø®ØªØ§Ø± Ø´Ø®ØµÙŠÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠÙŠÙ†
    let a = admins[Math.floor(Math.random() * admins.length)];
    let b;
    do {
      b = admins[Math.floor(Math.random() * admins.length)];
    } while (b.user.id === a.user.id);

    // Ø§Ù„Ø±Ø¯
    const text = `
	${mention(a)}
	Ø§Ø¯ÙŠÙ„Ùˆ Ø§Ø¯ÙŠ ğŸ™ƒğŸ˜‚
	${mention(b)}
	Ø¹Ù‚Ø¨Ø§Ù„ Ù…Ø§ ØªØ¬ÙŠØ¨Ùˆ ÙƒØªØ§ÙƒÙŠØª ØªÙ…Ù„Ø§ Ø§Ù„Ø¨Ø§Ø± Ø¨ØªØ§Ø¹Ù†Ø§ ğŸ¥¹ğŸ˜‚

`;

    await ctx.reply(text, { parse_mode: "HTML" });
  } catch (err) {
    console.error(err);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ØŒ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
  }
});


const tmpDir = path.join(process.cwd(), "tmp");
if (!fs.existsSync(tmpDir)) {
  fs.mkdirSync(tmpDir);
}

// Ø£Ù…Ø± Ø§Ù„Ù‡Ø¬Ø§Ø¨
bot.command("hijab", async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;

    // Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠÙ‡ ØµÙˆØ±Ø©
    if (!reply || !reply.photo || reply.photo.length === 0) {
      return ctx.reply(
        "ğŸ“¸ *Ù…Ù† ÙØ¶Ù„Ùƒ Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø±* `/hijab`",
        { parse_mode: "Markdown" }
      );
    }

    await ctx.reply("â³ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©ØŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† ØªÙ„ÙŠØ¬Ø±Ø§Ù…
    const fileId = reply.photo[reply.photo.length - 1].file_id;
    const fileUrl = await ctx.telegram.getFileLink(fileId);
    const imgRes = await axios.get(fileUrl.href, { responseType: "arraybuffer" });

    // ØªØ¬Ù‡ÙŠØ² Ø§Ù„ÙÙˆØ±Ù… Ø¯Ø§ØªØ§
    const form = new FormData();
    form.append("image", imgRes.data, {
      filename: "upload.jpg",
      contentType: "image/jpeg",
    });

    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API
    const response = await axios.post("https://xyro.site/fun/hijabkan", form, {
      headers: form.getHeaders(),
      responseType: "arraybuffer",
    });

    // Ø­ÙØ¸ Ù…Ø¤Ù‚Øª
    const tempPath = path.join(tmpDir, `result_${Date.now()}.jpg`);
    fs.writeFileSync(tempPath, response.data);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©
    await ctx.replyWithPhoto(
      { source: tempPath },
      { caption: "âœ… ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ù†Ø¬Ø§Ø­" }
    );

    // Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ 30 Ø«Ø§Ù†ÙŠØ©
    setTimeout(() => {
      try {
        fs.unlinkSync(tempPath);
      } catch (e) {
        console.error("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø³Ø­ Ø§Ù„Ù…Ù„Ù:", e);
      }
    }, 30000);

  } catch (error) {
    console.error("[HIJABKAN ERROR]", error);

    let errorMessage = "âŒ ÙØ´Ù„ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©";
    if (error.response) {
      try {
        errorMessage =
          error.response.data?.message ||
          error.response.statusText ||
          "Ø®Ø·Ø£ Ù…Ù† API";
      } catch {
        errorMessage = "Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ÙÙ‡ÙˆÙ…Ø© Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±";
      }
    } else if (error.message) {
      errorMessage = error.message;
    }

    ctx.reply(`âš ï¸ ${errorMessage}`);
  }
});


// Ù…ØµÙÙˆÙØ© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠØ©
const searchQueries = ["Ø­Ø¯ÙŠØ«", "Ø§Ù„Ø±Ø³ÙˆÙ„ ØµÙ„Ù‰ Ø§Ù„Ù„Ù‡ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù…", "Ø­Ø¯ÙŠØ« Ø´Ø±ÙŠÙ", "Ø­Ø¯ÙŠØ« Ù†Ø¨ÙˆÙŠ"];

// Ø¯Ø§Ù„Ø© ØªØ¬ÙŠØ¨ ÙÙŠØ¯ÙŠÙˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
async function fetchRandomVideo() {
  const searchQuery =
    searchQueries[Math.floor(Math.random() * searchQueries.length)];

  let { data: response } = await axios.get(
    "https://apis-starlights-team.koyeb.app/starlight/tiktoksearch?text=" +
      searchQuery
  );

  const searchResults = response.data;
  if (!searchResults || searchResults.length === 0) return null;

  // Ø§Ø®ØªÙŠØ§Ø± ÙÙŠØ¯ÙŠÙˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
  const randomResult =
    searchResults[Math.floor(Math.random() * searchResults.length)];

  return {
    url: randomResult.nowm,
    title: randomResult.title || "ğŸ¥ ÙÙŠØ¯ÙŠÙˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ",
    query: searchQuery,
  };
}

// Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
bot.command(["Ø¯ÙŠÙ†", "ahades", "ØªØµÙØ­2"], async (ctx) => {
  const video = await fetchRandomVideo();
  if (!video) return ctx.reply("âŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¢Ù†.");

  await ctx.replyWithVideo(
    { url: video.url },
    {
      caption: `ğŸ” ${video.query}\n\nğŸ“Œ ${video.title}`,
      parse_mode: "Markdown",
      ...Markup.inlineKeyboard([
        [Markup.button.callback("ğŸ¬ ÙÙŠØ¯ÙŠÙˆ ÙƒÙ…Ø§Ù†", "more_video")],
      ]),
    }
  );
});

// Ø²Ø± "ÙÙŠØ¯ÙŠÙˆ ÙƒÙ…Ø§Ù†"
bot.action("more_video", async (ctx) => {
  await ctx.answerCbQuery(); // Ø¹Ø´Ø§Ù† ÙŠØ®ØªÙÙŠ Ø§Ù„Ù„ÙˆØ¯ÙŠÙ†Ø¬
  const video = await fetchRandomVideo();
  if (!video) return ctx.reply("âŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¢Ù†.");

  await ctx.replyWithVideo(
    { url: video.url },
    {
      caption: `ğŸ” ${video.query}\n\nğŸ“Œ ${video.title}`,
      parse_mode: "Markdown",
      ...Markup.inlineKeyboard([
        [Markup.button.callback("ğŸ¬ ÙÙŠØ¯ÙŠÙˆ ÙƒÙ…Ø§Ù†", "more_video")],
      ]),
    }
  );
});

const rednoteDownloader = {
  getToken: async function () {
    const req = await fetch("https://anydownloader.com/en/xiaohongshu-videos-and-photos-downloader");
    if (!req.ok) return null;

    const res = await req.text();
    const $ = cheerio.load(res);
    const token = $("#token").val();

    return { token };
  },

  calculateHash: function (url, salt) {
    return Buffer.from(url).toString("base64") + (url.length + 1000) + Buffer.from(salt).toString("base64");
  },

  download: async function (url) {
    const conf = await rednoteDownloader.getToken();
    if (!conf) return { error: "âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹.", result: {} };

    const { token } = conf;
    const hash = rednoteDownloader.calculateHash(url, "aio-dl");

    const data = new URLSearchParams();
    data.append("url", url);
    data.append("token", token);
    data.append("hash", hash);

    const req = await fetch(`https://anydownloader.com/wp-json/aio-dl/video-data/`, {
      method: "POST",
      headers: {
        "Accept": "*/*",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "Origin": "https://anydownloader.com",
        "Referer": "https://anydownloader.com/en/xiaohongshu-videos-and-photos-downloader",
        "User-Agent": "Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36",
        "X-Requested-With": "XMLHttpRequest"
      },
      body: data
    });

    if (!req.ok) return { error: "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨.", result: {} };

    try {
      const json = await req.json();
      return {
        input_url: url,
        source: json.source,
        result: {
          title: json.title,
          duration: json.duration,
          thumbnail: json.thumbnail,
          downloadUrls: json.medias
        },
        error: null
      };
    } catch (e) {
      return { error: "âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø¥Ù„Ù‰ JSON", result: {} };
    }
  }
};

// ========== Telegram Command ==========
bot.command("anydownloader", async (ctx) => {
  const args = ctx.message.text.split(" ").slice(1);
  const url = args[0];

  if (!url) {
    return ctx.reply(
`â— *Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:*
Ø§ÙƒØªØ¨ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ¨ÙˆØ¹Ù‹Ø§ Ø¨Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ:

Ù…Ø«Ø§Ù„:
\`/anydownloader https://xhslink.com/a/xxxxx\`

ğŸŒ *Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:*
- Instagram
- Facebook
- Pinterest
- TikTok
- Twitter
- Likee
- Roposo
- ShareChat
- SnackVideo
- Vimeo
- YouTube Shorts
- Douyin
- Xiaohongshu (RED)
- IMDB
- Reddit`, { parse_mode: "Markdown" });
  }

  await ctx.reply("ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ØŒ Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹...");

  try {
    const res = await rednoteDownloader.download(url);
    if (res.error) return ctx.reply(`âŒ Ø®Ø·Ø£: ${res.error}`);

    let message = `âœ… *ØªÙ… Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ*\n\n`;
    message += `ğŸ“„ *Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:* ${res.result.title}\n`;
    message += `â± *Ø§Ù„Ù…Ø¯Ø©:* ${res.result.duration}\n`;

    const media = res.result.downloadUrls?.[0];
    if (!media?.url) return ctx.reply("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„.");

    await ctx.replyWithVideo({ url: media.url }, { caption: message, parse_mode: "Markdown" });
  } catch (err) {
    console.error(err);
    ctx.reply("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„.");
  }
});

// Ù‡Ù†Ø®Ø²Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© Ù‡Ù†Ø§
// Ø£Ù…Ø±: /Ø­Ø¨ @username
bot.command("love", async (ctx) => {
  const reply = ctx.message.reply_to_message;
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  let userId;

  // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‡Ø¯Ù (mention, reply, id)
  if (reply) {
    userId = reply.from.id;
  } else if (ctx.message.entities && ctx.message.entities[1]?.type === "mention") {
    userId = text.replace("@", "");
  } else if (!isNaN(text)) {
    userId = text;
  }

  if (!userId) {
    return ctx.reply("ğŸ“Œ Ù„Ø§Ø²Ù… ØªØ±Ø¯ Ø¹Ù„Ù‰ Ø´Ø®Øµ Ø£Ùˆ ØªØ°ÙƒØ±Ù‡ Ø£Ùˆ ØªÙƒØªØ¨ Ø§Ù„Ù€ ID.");
  }

  const senderId = ctx.from.id;

  // Ù„Ùˆ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨ÙŠØ­Ø§ÙˆÙ„ ÙŠØ­Ø¨ Ù†ÙØ³Ù‡
  if (userId == senderId) {
    return ctx.reply("âŒ Ù…ÙŠÙ†ÙØ¹Ø´ ØªØ­Ø¨ Ù†ÙØ³Ùƒ ğŸ˜‚");
  }

  // Ù„Ùˆ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨ÙŠØ­Ø§ÙˆÙ„ ÙŠØ­Ø¨ Ø§Ù„Ø¨ÙˆØª
  if (userId == ctx.botInfo.id) {
    return ctx.reply("ğŸ˜³ Ø§Ù†Ø§ Ø¨ÙˆØª Ù…Ø´ ÙŠÙ†ÙØ¹ Ù†Ø±ØªØ¨Ø· ğŸ¥²");
  }

  // Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ Ù…Ø¹ Ø²Ø±Ø§Ø±ÙŠÙ†
  await ctx.replyWithMarkdown(
    `ğŸ’Œ [${ctx.from.first_name}](tg://user?id=${senderId}) Ø¨ÙŠÙ‚ÙˆÙ„: Ù‡Ù„ ØªÙ‚Ø¨Ù„ Ø£Ù† ØªÙƒÙˆÙ† Ø´Ø±ÙŠÙƒ Ø­ÙŠØ§ØªÙŠØŸ`,
    Markup.inlineKeyboard([
      [Markup.button.callback("ğŸŸ¢ Ù…ÙˆØ§ÙÙ‚Ø©", `accept_${senderId}_${userId}`)],
      [Markup.button.callback("ğŸ”´ Ø±ÙØ¶", `reject_${senderId}_${userId}`)],
    ])
  );
});

// ğŸ“ Ø²Ø± Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø©
bot.action(/accept_(\d+)_(\d+)/, async (ctx) => {
  const senderId = ctx.match[1];
  const userId = ctx.match[2];

  if (ctx.from.id.toString() !== userId) {
    return ctx.answerCbQuery("âš ï¸ Ù…Ø´ Ø¥Ù†Øª Ø§Ù„Ù„ÙŠ Ø§ØªØ·Ù„Ø¨ Ù…Ù†Ùƒ!");
  }

  global.db.data.users[userId] ??= {};
  global.db.data.users[senderId] ??= {};

  global.db.data.users[userId].pasangan = senderId;
  global.db.data.users[senderId].pasangan = userId;

  await ctx.editMessageText(
    `ğŸ’– [${ctx.from.first_name}](tg://user?id=${userId}) ÙˆØ§ÙÙ‚/Øª Ø¹Ù„Ù‰ Ø·Ù„Ø¨ [${senderId}](tg://user?id=${senderId})! ğŸ‰`
  );
});

// ğŸ“ Ø²Ø± Ø§Ù„Ø±ÙØ¶
bot.action(/reject_(\d+)_(\d+)/, async (ctx) => {
  const senderId = ctx.match[1];
  const userId = ctx.match[2];

  if (ctx.from.id.toString() !== userId) {
    return ctx.answerCbQuery("âš ï¸ Ù…Ø´ Ø¥Ù†Øª Ø§Ù„Ù„ÙŠ Ø§ØªØ·Ù„Ø¨ Ù…Ù†Ùƒ!");
  }

  global.db.data.users[userId] ??= {};
  global.db.data.users[senderId] ??= {};

  global.db.data.users[userId].pasangan = "";
  global.db.data.users[senderId].pasangan = "";

  await ctx.editMessageText(
    `ğŸ’” [${ctx.from.first_name}](tg://user?id=${userId}) Ø±ÙØ¶/Øª Ø·Ù„Ø¨ [${senderId}](tg://user?id=${senderId}) ğŸ˜¢`
  );
});
// Ù†Ø®Ø²Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©

// ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£Ø³

bot.command("to_mp3", async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;

    if (!reply || (!reply.video && !reply.voice && !reply.audio)) {
      return ctx.reply("âŒ Ø§Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„Ø§ÙŠ Ù„Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ùˆ Ø§Ù„Ø±ÙŠÙƒ Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙˆØ² ØªØ­ÙˆÙ„Ùˆ Ù„ØµÙˆØª ğŸ©¸");
    }

    // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù„Ù
    let fileId;
    if (reply.video) fileId = reply.video.file_id;
    else if (reply.voice) fileId = reply.voice.file_id;
    else if (reply.audio) fileId = reply.audio.file_id;

    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = Buffer.from(await response.arrayBuffer());

    // Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª (UUID Ø¹Ø´Ø§Ù† Ù…ÙŠØ­ØµÙ„Ø´ ØªØ¶Ø§Ø±Ø¨)
    const tempDir = "./temp";
    const filePath = path.join(tempDir, `temp_${Date.now()}.mp3`);

    // Ø¥Ù†Ø´Ø§Ø¡ ÙÙˆÙ„Ø¯Ø± temp Ù„Ùˆ Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯
    try {
      await fs.mkdir(tempDir, { recursive: true });
    } catch {}

    // Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù
    await fs.writeFile(filePath, buffer);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª ÙƒÙ€ MP3 Ù…Ù† Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­Ù„ÙŠ
    await ctx.replyWithAudio(
      { source: filePath },
      { caption: "ğŸ©¸ ØªÙ… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ MP3", title: "Converted Audio", performer: "Bot" }
    );

    // Ù…Ø³Ø­ Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
    await fs.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­ÙˆÙŠÙ„.");
  }
});

bot.command(["toimg", "ØªØ­ÙˆÙŠÙ„_Ù„ØµÙˆØ±Ø©"], async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;

    if (!reply || !reply.sticker) {
      return ctx.reply("âŒ— Ù…Ù† ÙØ¶Ù„Ùƒ Ù‚Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ø³ØªÙŠÙƒØ± ğŸ­");
    }

    if (!fs.existsSync("./temp")) fs.mkdirSync("./temp");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø§Ø³ØªÙŠÙƒØ±
    const fileId = reply.sticker.file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const res = await fetch(fileLink.href);
    const buffer = Buffer.from(await res.arrayBuffer());

    // Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
    const rand = Math.floor(Math.random() * 1000000 + 1);
    const pathWebp = `./temp/${rand}.webp`;
    const pathImg = `./temp/${rand}.jpg`;

    fs.writeFileSync(pathWebp, buffer);

    // ØªØ­ÙˆÙŠÙ„ webp â†’ jpg
    exec(`convert ${pathWebp} ${pathImg}`, async (err) => {
      try {
        if (err || !fs.existsSync(pathImg)) {
          fs.unlinkSync(pathWebp);
          return ctx.reply("âŒ ÙØ´Ù„ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØµÙˆØ±Ø©!");
        }

        await ctx.replyWithPhoto(
          { source: fs.createReadStream(pathImg) },
          { caption: "ğŸ©¸ ØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø§Ø³ØªÙŠÙƒØ± Ø¥Ù„Ù‰ ØµÙˆØ±Ø©" }
        );

        // Ø­Ø°Ù Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        fs.unlinkSync(pathWebp);
        fs.unlinkSync(pathImg);
      } catch (e) {
        console.error(e);
        ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©.");
      }
    });
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­ÙˆÙŠÙ„.");
  }
});
// Ø£Ù…Ø± "Ø²ÙˆØ§Ø¬"

bot.command("to_mp3", async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;

    if (!reply || (!reply.video && !reply.voice && !reply.audio)) {
      return ctx.reply("âŒ Ø§Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„Ø§ÙŠ Ù„Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ùˆ Ø§Ù„Ø±ÙŠÙƒ Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙˆØ² ØªØ­ÙˆÙ„Ùˆ Ù„ØµÙˆØª ğŸ©¸");
    }

    // Ø¬Ù„Ø¨ file_id
    let fileId;
    if (reply.video) fileId = reply.video.file_id;
    else if (reply.voice) fileId = reply.voice.file_id;
    else if (reply.audio) fileId = reply.audio.file_id;

    // Ù‡Ù†Ø§ Ø¨Ù†Ø³ØªØ¹Ù…Ù„ Ø§Ù„ÙÙ†ÙƒØ´Ù† Ø§Ù„Ø¬Ø§Ù‡Ø²Ø©
    const buffer = await getBuffer(ctx, fileId)

    // Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù
    const link = await uploadFile(buffer)

    if (!link) {
      return ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±ÙØ¹.");
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª
    await ctx.replyWithAudio(
      { url: link, filename: "shawaza_zizo_2024.mp3" },
      { caption: "ğŸ©¸ ØªÙ… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ MP3" }
    );

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­ÙˆÙŠÙ„.");
  }
});


// ========= Helpers =========
function randomIP() {
  return Array(4).fill(0).map(() => Math.floor(Math.random() * 256)).join('.')
}

function randomUserAgent() {
  const userAgents = [
    'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Android 12; Mobile; rv:102.0) Gecko/102.0 Firefox/102.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15'
  ]
  return userAgents[Math.floor(Math.random() * userAgents.length)]
}

const sessionIP = randomIP()
const sessionUA = randomUserAgent()

function getBaseHeaders() {
  return {
    'origin': 'https://pixnova.ai',
    'referer': 'https://pixnova.ai/',
    'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
    'accept': 'application/json, text/plain, */*',
    'user-agent': sessionUA,
    'X-Forwarded-For': sessionIP,
    'Client-IP': sessionIP
  }
}

async function uploadImageFromBuffer(buffer) {
  const stream = Readable.from(buffer)
  const form = new FormData()
  form.append('file', stream, { filename: 'image.jpg' })
  form.append('fn_name', 'demo-photo2anime')
  form.append('request_from', '2')
  form.append('origin_from', '111977c0d5def647')

  const upload = await axios.post('https://api.pixnova.ai/aitools/upload-img', form, {
    headers: { ...getBaseHeaders(), ...form.getHeaders() }
  })
  return upload.data?.data?.path
}

async function createTask(sourceImage) {
  const payload = {
    fn_name: 'demo-photo2anime',
    call_type: 3,
    input: {
      source_image: sourceImage,
      strength: 0.6,
      prompt: 'use anime style, hd, 8k, smooth, aesthetic',
      negative_prompt: '(worst quality, low quality:1.4), blurry, watermark, text, extra arm, extra leg'
    },
    request_from: 2,
    origin_from: '111977c0d5def647'
  }

  const res = await axios.post('https://api.pixnova.ai/aitools/of/create', payload, {
    headers: { ...getBaseHeaders(), 'content-type': 'application/json' }
  })
  return res.data?.data?.task_id
}

async function waitForResult(taskId) {
  const payload = {
    task_id: taskId,
    fn_name: 'demo-photo2anime',
    call_type: 3,
    request_from: 2,
    origin_from: '111977c0d5def647'
  }

  const delay = ms => new Promise(resolve => setTimeout(resolve, ms))

  for (let i = 1; i <= 30; i++) {
    const check = await axios.post('https://api.pixnova.ai/aitools/of/check-status', payload, {
      headers: { ...getBaseHeaders(), 'content-type': 'application/json' }
    })

    const data = check.data?.data
    if (data?.status === 2 && data?.result_image) {
      return data.result_image.startsWith('http')
        ? data.result_image
        : `https://oss-global.pixnova.ai/${data.result_image}`
    }

    await delay(2000)
  }

  return null
}

async function convertToPNG(url) {
  const res = await fetch(url)
  const arrayBuffer = await res.arrayBuffer()
  const webpBuffer = Buffer.from(arrayBuffer)
  return await sharp(webpBuffer).png().toBuffer()
}

// ========= Telegram Command =========
bot.command("photo2anime", async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message
    if (!reply || !reply.photo) {
      return ctx.reply("ğŸ“Œ Ù…Ù† ÙØ¶Ù„Ùƒ Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¨Ø§Ù„Ø£Ù…Ø± `/photo2anime`", { parse_mode: "Markdown" })
    }

    ctx.reply("ğŸ¨ Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„ ØµÙˆØ±ØªÙƒ Ø¥Ù„Ù‰ Ø£Ù†Ù…ÙŠ...")

    // Ø­Ù…Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
    const fileId = reply.photo[reply.photo.length - 1].file_id
    const fileLink = await ctx.telegram.getFileLink(fileId)
    const res = await fetch(fileLink.href)
    const buffer = Buffer.from(await res.arrayBuffer())

    // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© + Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ù…Ø©
    const sourceImage = await uploadImageFromBuffer(buffer)
    const taskId = await createTask(sourceImage)
    const resultUrl = await waitForResult(taskId)

    if (!resultUrl) return ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©.")

    const pngBuffer = await convertToPNG(resultUrl)

    await ctx.replyWithPhoto({ source: pngBuffer }, { caption: "âœ¨ Ù‡Ø§ Ù‡ÙŠ ØµÙˆØ±ØªÙƒ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø£Ù†Ù…ÙŠ!" })
  } catch (err) {
    console.error("âŒ Ø®Ø·Ø£:", err)
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©.")
  }
});

let currentPage = 1;

// ğŸ” Ø£Ù…Ø± Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£ÙÙ„Ø§Ù…
bot.command(["film"], async (ctx) => {
  const query = ctx.message.text.split(" ").slice(1).join(" ");
  if (!query) {
    return ctx.reply("ğŸ”± Ù‚Ù… Ø¨Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„ÙÙŠÙ„Ù… Ù„Ù„Ø¨Ø­Ø«.\n\nğŸ“Œ Ù…Ø«Ø§Ù„:\n/Ø³ÙŠÙ†Ù…Ø§_Ø¨Ù„Ø³ avatar");
  }

  await ctx.reply("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙÙŠÙ„Ù…...");

  let Ù†ØªØ§Ø¦Ø¬;
  try {
    Ù†ØªØ§Ø¦Ø¬ = await searchC(query);
  } catch {
    Ù†ØªØ§Ø¦Ø¬ = await searchTMDB(query);
  }

  if (!Ù†ØªØ§Ø¦Ø¬ || Ù†ØªØ§Ø¦Ø¬.length === 0) {
    return ctx.reply("ğŸ”± Ù„Ù… Ø£Ø¬Ø¯ Ù…Ø§ Ø·Ù„Ø¨ØªÙ‡ Ø£Ùˆ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø£Ø®Ø±Ù‰ Ù„Ù„ÙÙŠÙ„Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.");
  }

  const result = Ù†ØªØ§Ø¦Ø¬[0];
  const ØµÙˆØ±Ø© = result.poster_path
    ? `https://image.tmdb.org/t/p/w500/${result.poster_path}`
    : "https://elcomercio.pe/resizer/RJM30xnujgfmaODGytH1rRVOrAA=/400x0/smart/filters:format(jpeg):quality(75)/arc-anglerfish-arc2-prod-elcomercio.s3.amazonaws.com/public/BJ2L67XNRRGHTFPKPDOEQ2AH5Y.jpg";

  const caption = `*ğŸ¬ â€¢ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:* ${result.title}\n\nğŸ”— *Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠÙ„Ù…:* ${result.link}`;

  await ctx.replyWithPhoto(
    { url: ØµÙˆØ±Ø© },
    {
      caption,
      parse_mode: "Markdown",
      ...Markup.inlineKeyboard([
        [
          Markup.button.callback(
            "ğŸ”± Ø¨Ø­Ø« Ø¢Ø®Ø±",
            `search_more_${query}_${currentPage + 1}`
          ),
        ],
        [Markup.button.url("ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠÙ„Ù…", result.link)],
        [
          Markup.button.url(
            "ğŸ©¸ Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙˆØª",
            "https://t.me/Terbo888xxx"
          ),
        ],
      ]),
    }
  );

  currentPage++;
});

// ğŸŒ€ Ù‡Ø§Ù†Ø¯Ù„Ø± Ù„Ø²Ø±Ø§Ø± "Ø¨Ø­Ø« Ø¢Ø®Ø±"
bot.action(/search_more_(.+)_(\d+)/, async (ctx) => {
  const query = ctx.match[1];
  const page = parseInt(ctx.match[2]);

  let Ù†ØªØ§Ø¦Ø¬;
  try {
    Ù†ØªØ§Ø¦Ø¬ = await searchC(query, page);
  } catch {
    Ù†ØªØ§Ø¦Ø¬ = await searchTMDB(query, page);
  }

  if (!Ù†ØªØ§Ø¦Ø¬ || Ù†ØªØ§Ø¦Ø¬.length === 0) {
    return ctx.answerCbQuery("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø¥Ø¶Ø§ÙÙŠØ©.");
  }

  const result = Ù†ØªØ§Ø¦Ø¬[0];
  const ØµÙˆØ±Ø© = result.poster_path
    ? `https://image.tmdb.org/t/p/w500/${result.poster_path}`
    : "https://elcomercio.pe/resizer/RJM30xnujgfmaODGytH1rRVOrAA=/400x0/smart/filters:format(jpeg):quality(75)/arc-anglerfish-arc2-prod-elcomercio.s3.amazonaws.com/public/BJ2L67XNRRGHTFPKPDOEQ2AH5Y.jpg";

  await ctx.replyWithPhoto(
    { url: ØµÙˆØ±Ø© },
    {
      caption: `*ğŸ¬ â€¢ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:* ${result.title}\n\nğŸ”— *Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠÙ„Ù…:* ${result.link}`,
      parse_mode: "Markdown",
      ...Markup.inlineKeyboard([
        [
          Markup.button.callback(
            "ğŸ”± Ø¨Ø­Ø« Ø¢Ø®Ø±",
            `search_more_${query}_${page + 1}`
          ),
        ],
        [Markup.button.url("ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠÙ„Ù…", result.link)],
      ]),
    }
  );
  ctx.answerCbQuery();
});

// ğŸ› ï¸ Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¨Ø­Ø«
async function safeLoad(url, options = {}) {
  try {
    const { data: pageData } = await axios.get(url, options);
    const $ = load(pageData);
    return $;
  } catch (err) {
    throw err;
  }
}

async function searchC(query, numberPage = 1) {
  const $ = await safeLoad(`https://cuevana3.mu/page/${numberPage}/`, {
    params: { s: query },
  });
  const resultSearch = [];
  $(".results-post > article").each((_, e) => {
    const element = $(e);
    const title = element.find("header > h2").text();
    const link = element.find(".lnk-blk").attr("href");
    resultSearch.push({ title, link });
  });
  return resultSearch;
}

async function searchTMDB(query, page = 1) {
  const apiKey = "90f6e472836201538985de05c8bbd385";
  const response = await axios.get(
    `https://api.themoviedb.org/3/search/movie`,
    {
      params: { api_key: apiKey, query, page },
    }
  );
  return response.data.results.map((movie) => ({
    title: movie.title,
    link: `https://www.themoviedb.org/movie/${movie.id}`,
    poster_path: movie.poster_path,
  }));
}

// Ù…ØµÙÙˆÙØ© Ù†Ø®Ø²Ù† ÙÙŠÙ‡Ø§ ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù„ÙŠ Ø¸Ù‡Ø±ÙˆØ§ ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨


const Murottal = {
  async list() {
    try {
      let res = await axios.get("https://www.assabile.com/yasser-al-dosari-52/yasser-al-dosari.htm", {
        headers: {
          "user-agent": "Mozilla/5.0",
        },
      });

      const $ = cheerio.load(res.data);
      let list = [];

      $(".playlist li a").each((i, el) => {
        const name = $(el).text().trim();
        const href = $(el).attr("href");
        if (href && name) list.push({ span_name: name, href });
      });

      return list;
    } catch (error) {
      console.error("âŒ Error fetching list:", error.message);
      return [];
    }
  },

  async audio(href) {
    try {
      let res = await axios.get(`https://www.assabile.com${href}`, {
        headers: {
          "user-agent": "Mozilla/5.0",
        },
      });

      const $ = cheerio.load(res.data);
      const audioUrl = $("#recitation source").attr("src");
      return audioUrl || null;
    } catch (error) {
      console.error("âŒ Error fetching audio:", error.message);
      return null;
    }
  },
};

bot.command("quran", async (ctx) => {
  try {
    const list = await Murottal.list();
    if (list.length === 0) return ctx.reply("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ Ø³ÙˆØ±.");

    const buttons = list.slice(0, 15).map((s) =>
      [Markup.button.callback(s.span_name, `play_${s.href}`)]
    );

    await ctx.reply("ğŸ“– Ø§Ø®ØªØ± Ø§Ù„Ø³ÙˆØ±Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:", Markup.inlineKeyboard(buttons));
  } catch (e) {
    console.error(e);
    ctx.reply("ğŸš¨ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.");
  }
});

bot.on("callback_query", async (ctx) => {
  const data = ctx.callbackQuery.data;

  if (data.startsWith("play_")) {
    const href = data.replace("play_", "");
    const audioUrl = await Murottal.audio(href);

    if (!audioUrl) return ctx.answerCbQuery("âŒ ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ø§ÙˆØ©.");

    await ctx.replyWithAudio({ url: audioUrl });
    ctx.answerCbQuery();
  }
});



bot.command(["divorce", "Ø§Ù„Ø·Ù„Ø§Ù‚"], async (ctx) => {
  try {
    const chatId = ctx.chat.id;

    // Ù†Ø¬ÙŠØ¨ Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø¬Ø±ÙˆØ¨ (Ù„Ø§Ø²Ù… Ø§Ù„Ø¨ÙˆØª ÙŠÙƒÙˆÙ† Ø£Ø¯Ù…Ù†)
    const members = await ctx.telegram.getChatAdministrators(chatId);
    let participants = members.map((m) => m.user);

    if (participants.length < 2) {
      return ctx.reply("âŒ Ù…Ø´ ÙƒÙØ§ÙŠØ© Ø£Ø¹Ø¶Ø§Ø¡ Ù„Ù„Ø·Ù„Ø§Ù‚ ğŸ˜‚");
    }

    // Ù†Ø®ØªØ§Ø± Ø§ØªÙ†ÙŠÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠ
    let a = participants[Math.floor(Math.random() * participants.length)];
    let b;
    do {
      b = participants[Math.floor(Math.random() * participants.length)];
    } while (b.id === a.id);

    // Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ù†Ø´Ù† Ø¨Ø§Ù„Ø§Ø³Ù… + id
    let toM = (user) => `[${user.first_name}](tg://user?id=${user.id})`;

    await ctx.replyWithMarkdown(
      `ğŸ’” Ø®Ø¨Ø± Ø¹Ø§Ø¬Ù„: ${toM(a)} Ø·Ù„Ù‚ ${toM(b)} ğŸ™ƒğŸ˜‚Ø¯\n\n` +
      `ğŸ˜¢ Ù…Ø­Ø¯Ø´ ÙŠØ²Ø¹Ù„ ÙŠØ§ Ø¬Ù…Ø§Ø¹Ø©ØŒ Ø¯ÙŠ Ù…Ø¬Ø±Ø¯ Ù„Ø¹Ø¨Ø© ğŸ‘¾`
    );
  } catch (err) {
    console.error(err);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ØŒ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
  }
});


function getRandom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

bot.command("marry_me", async (ctx) => {
  if (ctx.chat.type !== "supergroup") {
    return ctx.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª.");
  }

  // Ù†Ø¬Ù…Ø¹ ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ (Ù„Ø§Ø²Ù… Ø§Ù„Ø¨ÙˆØª ÙŠÙƒÙˆÙ† Ø¹Ù†Ø¯Ù‡ ØµÙ„Ø§Ø­ÙŠØ© getChatMember)
  const memberCount = await ctx.getChatMembersCount();
  const members = [];

  for (let i = 0; i < memberCount; i++) {
    try {
      const member = await ctx.getChatMember(i);
      if (member && member.user && !member.user.is_bot) {
        members.push(member.user);
      }
    } catch (e) {
      continue;
    }
  }

  if (members.length < 2) {
    return ctx.reply("âš ï¸ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©.");
  }

  let a = getRandom(members);
  let b;
  do {
    b = getRandom(members);
  } while (b.id === a.id);

  const user = ctx.from;

  ctx.reply(
    `@${user.username || user.id}  \`ã€ Ø§ÙŠ Ø±Ø§ÙŠÙƒ ÙÙŠ Ø§Ù„Ù…Ø²Ù‡ Ø¯ÙŠ ğŸ˜¹ğŸ’— ã€\`Ø¯  @${b.username || b.id}, ğŸ¥º`,
    {
      parse_mode: "Markdown",
      reply_to_message_id: ctx.message.message_id
    }
  );
});
bot.command("link", async (ctx) => {
  try {
    const chat = await ctx.getChat();

    if (chat.type !== "supergroup" && chat.type !== "group" && chat.type !== "channel") {
      return ctx.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø£Ùˆ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª");
    }

    const chatTitle = chat.title || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
    const chatDesc = chat.description || "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ Ù…ØªØ§Ø­";
    const chatUsername = chat.username ? `@${chat.username}` : "âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±";

    // Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    let photoUrl = "https://files.catbox.moe/xsplj9.jpg";

    try {
      if (chat.photo) {
        const file = await ctx.telegram.getFile(chat.photo.big_file_id);
        photoUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
      }
    } catch (e) {
      console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„Ø¬Ø±ÙˆØ¨:", e);
    }

    // Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø£Ùˆ Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©
    let inviteLink;
    if (chat.type === "supergroup" || chat.type === "group") {
      try {
        inviteLink = await ctx.telegram.exportChatInviteLink(chat.id);
      } catch {
        inviteLink = "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· (Ø§Ù„Ø¨ÙˆØª Ù„ÙŠØ³ Ø£Ø¯Ù…Ù†)";
      }
    } else {
      inviteLink =
        chat.username != null
          ? `https://t.me/${chat.username}`
          : "âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ø§Ø¨Ø· Ù…Ø¨Ø§Ø´Ø±";
    }

    const caption = `
â”â”â”â”â”â”â”â°ï½¥ğ“ƒ¦ï½¥â±â”â”â”â”â”â”â”“
> â‰¡ â—¡Ìˆâƒâ¯ ã€ Ø§Ù„Ø§Ø³Ù… ã€: ${chatTitle}
> â‰¡ â—¡Ìˆâƒâ¯ ã€ Ø§Ù„ÙŠÙˆØ²Ø± ã€: ${chatUsername}
> â‰¡ â—¡Ìˆâƒâ¯ ã€ Ø§Ù„ÙˆØµÙ ã€: ${chatDesc}
â”—â”â”â”â”â”â”â°ï½¥ğ“ƒ ï½¥â±â”â”â”â”â”â”â”›
    `;

    await ctx.replyWithPhoto(photoUrl, {
      caption,
      parse_mode: "Markdown",
      ...Markup.inlineKeyboard([[Markup.button.url("ğŸ“„ Ø§Ù„Ø±Ø§Ø¨Ø·", inviteLink)]])
    });
  } catch (e) {
    console.error("Ø§Ù„Ø®Ø·Ø£:", e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ø¬Ø±ÙˆØ¨");
  }
});



// Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù€ Catbox
const uploadToCatbox = async (buffer) => {
  const { ext } = await fileTypeFromBuffer(buffer);
  const form = new FormData();
  form.append("fileToUpload", buffer, `file.${ext}`);
  form.append("reqtype", "fileupload");

  try {
    const response = await fetch("https://catbox.moe/user/api.php", {
      method: "POST",
      body: form,
    });

    const text = await response.text();
    if (text.startsWith("https://")) {
      return text;
    } else {
      throw new Error("ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù: " + text);
    }
  } catch (error) {
    throw new Error(`Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±ÙØ¹: ${error.message}`);
  }
};

bot.command("zengy", async (ctx) => {
  try {
    if (!ctx.message.reply_to_message || !ctx.message.reply_to_message.photo) {
      return ctx.reply("âš ï¸ Ù…Ù† ÙØ¶Ù„Ùƒ Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¹Ø´Ø§Ù† Ø£Ø²Ù†Ø¬Ù‡Ø§ ğŸ¦â€â¬›");
    }

    await ctx.reply("â³ ÙŠØªÙ… Ø§Ù„ØªØ²Ù†ÙŠØ¬...");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
    const fileId = ctx.message.reply_to_message.photo.pop().file_id;
    const file = await ctx.telegram.getFile(fileId);
    const fileUrl = `https://api.telegram.org/file/bot${bot.token}/${file.file_path}`;

    const buffer = await fetch(fileUrl).then((res) => res.buffer());

    // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù€ Catbox
    const img = await uploadToCatbox(buffer);

    // Ø§Ù„Ø¨Ù€Ø±ÙˆÙ…Ø¨Øª (Ù…Ù…ÙƒÙ† ØªØ®Ù„ÙŠÙ‡ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¯Ù„ Ø§Ù„Ø«Ø§Ø¨Øª)
    const prompt =
      "Change only the skin color to black while keeping all other elements exactly same including facial features, lighting, hair, clothing, pose, background and style. Make skin tone look natural with realistic texture.";

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
    const processResponse = await axios.get(
      "https://emam-x-api.vercel.app/home/sections/Tools/api/api/process-image",
      {
        params: { imageUrl: img, prompt: prompt },
      }
    );

    const rid = processResponse.data.recordId;
    if (!rid) throw new Error("âŒ ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ record ID");

    let resultUrl = null;
    while (!resultUrl) {
      await new Promise((resolve) => setTimeout(resolve, 3000));

      const checkResponse = await axios.get(
        "https://emam-x-api.vercel.app/home/sections/Tools/api/api/check-result",
        { params: { rid: rid } }
      );

      if (checkResponse.data?.completed === true && checkResponse.data?.resultUrl) {
        resultUrl = checkResponse.data.resultUrl;
      }
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù†Ø§ØªØ¬Ø©
    await ctx.replyWithPhoto({ url: resultUrl }, { caption: "âœ… ØªÙ… Ø§Ù„ØªØ²Ù†ÙŠØ¬ ğŸ§‘ğŸ¿â€ğŸ¦²ğŸ‘ğŸ¿" });

  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: " + e.message);
  }
});

bot.command("eye", async (ctx) => {
  const chatId = ctx.chat.id;

  // Ù‡Ù†Ø§ Ø¨ØªØ­Ø· Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ§Ù„Ø§Ø®ØªÙŠØ§Ø±Ø§Øª
  const question = "â“ Ù…Ù† ØªÙƒÙˆÙ† Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø®ØµÙŠØ©ØŸ";
  const options = ["Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­", "ÙƒØ±ÙŠØ³ØªÙŠØ§Ù†Ùˆ", "Ù…ÙŠØ³ÙŠ", "Ø²ÙŠØ²Ùˆ"];
  const correct = "Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­";

  await ctx.reply(
    `ğŸ® Ù„Ø¹Ø¨Ø© Ø§Ø­Ø²Ø± Ø§Ù„Ø´Ø®ØµÙŠØ©\n\n${question}\n\nâ° Ø¹Ù†Ø¯Ùƒ 60 Ø«Ø§Ù†ÙŠØ©.`,
    {
      parse_mode: "Markdown",
      ...Markup.inlineKeyboard(
        options.map((opt) => [Markup.button.callback(opt, `guess:${opt}:${chatId}`)])
      ),
    }
  );

  // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© (Ù…Ù…ÙƒÙ† ØªØ³ØªØ®Ø¯Ù… Ù…Ø§Ø¨ Ø£Ùˆ DB Ø­Ø³Ø¨ ÙƒÙˆØ¯Ùƒ)
  ctx.session = ctx.session || {};
  ctx.session[chatId] = correct;
});

bot.action(/guess:(.+):(.+)/, async (ctx) => {
  const choice = ctx.match[1];
  const chatId = ctx.match[2];

  if (ctx.session && ctx.session[chatId]) {
    if (choice === ctx.session[chatId]) {
      await ctx.reply("ğŸ©¸ Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø© ÙŠØ§ Ù†Ø¬Ù… ğŸ‰");
    } else {
      await ctx.reply("âŒ Ø¥Ø¬Ø§Ø¨Ø© ØºÙ„Ø·ØŒ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ!");
    }
    delete ctx.session[chatId];
  } else {
    await ctx.reply("â° Ø§Ù„ÙˆÙ‚Øª Ø®Ù„Øµ Ø£Ùˆ Ù…ÙÙŠØ´ Ù„Ø¹Ø¨Ø© Ø´ØºØ§Ù„Ø©.");
  }
});

const colorOptions = [
  { name: "Ø£Ø­Ù…Ø±", color: "#FF0000" },
  { name: "Ø£Ø®Ø¶Ø±", color: "#00FF00" },
  { name: "Ø£Ø²Ø±Ù‚", color: "#0000FF" },
  { name: "Ø£ØµÙØ±", color: "#FFFF00" },
  { name: "Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ", color: "#FFA500" },
  { name: "Ø¨Ù†ÙØ³Ø¬ÙŠ", color: "#800080" },
  { name: "Ø±Ù…Ø§Ø¯ÙŠ", color: "#808080" },
];

const operations = [
  { name: "ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø¬Ù…", operation: (image) => image.resize(800, Jimp.AUTO) },
  { name: "Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø¯Ø©", operation: (image) =>
      image.convolute([
        [0, -1, 0],
        [-1, 5, -1],
        [0, -1, 0],
      ])
  },
  { name: "ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø³Ø·ÙˆØ¹", operation: (image) => image.brightness(0.1) },
  { name: "ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ¨Ø§ÙŠÙ†", operation: (image) => image.contrast(0.3) },
  { name: "ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø£Ø¨ÙŠØ¶ ÙˆØ£Ø³ÙˆØ¯", operation: (image) => image.grayscale() },
  { name: "ØªÙ†Ø¹ÙŠÙ… Ø§Ù„ØµÙˆØ±Ø©", operation: (image) => image.blur(5) },
  { name: "ØªØ¯ÙˆÙŠØ± Ø§Ù„ØµÙˆØ±Ø©", operation: (image) => image.rotate(90) },
  { name: "ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù„ÙˆØ§Ù†", operation: null },
  { name: "ØªØºÙŠÙŠØ± Ø§Ù„Ø´ÙØ§ÙÙŠØ©", operation: (image) => image.opacity(0.8) },
  { name: "Ø¥Ø¶Ø§ÙØ© Ù†Øµ", operation: null },
  { name: "Ù‚Øµ Ø§Ù„ØµÙˆØ±Ø©", operation: null },
  { name: "ÙˆØ¶Ø¹ Ø¥Ø·Ø§Ø± Ù…Ø´ÙˆØ´", operation: null },
  { name: "ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¨ÙˆØ±ØªØ±ÙŠÙ‡", operation: null },
  { name: "ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ HD", operation: (image) =>
      image.resize(Jimp.AUTO, 1080)
  },
  { name: "Ø¶Ø¨Ø§Ø¨ÙŠØ©", operation: (image) => image.blur(10) },
  { name: "ÙƒØ±ØªÙˆÙ†ÙŠ", operation: (image) =>
      image.convolute([
        [-1, -1, -1],
        [-1, 9, -1],
        [-1, -1, -1],
      ])
  },
  { name: "Ø¸Ù„", operation: (image) => {
      const shadow = image.clone().opacity(0.5).blur(5);
      return image.composite(shadow, 10, 10);
    }
  },
  { name: "Ø²ÙŠØªÙŠ", operation: (image) =>
      image.color([{ apply: "mix", params: ["#8B4513", 100] }])
  },
  { name: "HDR", operation: (image) =>
      image
        .convolute([
          [0, -1, 0],
          [-1, 5, -1],
          [0, -1, 0],
        ])
        .contrast(0.3)
        .brightness(0.1)
  },
  { name: "ÙÙŠÙ„Ù…", operation: (image) =>
      image.color([{ apply: "mix", params: ["#000000", 50] }])
  },
  { name: "ØªØ´ÙˆÙŠØ´", operation: (image) => image.blur(3) },
  { name: "ØªØ¹ØªÙŠÙ…", operation: (image) => image.opacity(0.5) },
];

// Ø§Ù„Ø£Ù…Ø± /buti
bot.command("buti", async (ctx) => {
  try {
    const text = ctx.message.text.split(" ").slice(1).join(" ");

    // Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† ÙÙŠÙ‡ ØµÙˆØ±Ø© (Ø¥Ù…Ø§ Ø¨Ø§Ù„Ø±Ø¯ Ø£Ùˆ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø±Ø³Ø§Ù„Ø©)
    let fileId;
    if (ctx.message.reply_to_message?.photo) {
      fileId = ctx.message.reply_to_message.photo.slice(-1)[0].file_id;
    } else if (ctx.message.photo) {
      fileId = ctx.message.photo.slice(-1)[0].file_id;
    } else {
      return ctx.reply("ğŸ©¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ù…Ø¹ Ø±Ù‚Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.");
    }

    // Ù„Ùˆ Ù…ÙÙŠØ´ Ø±Ù‚Ù… Ù…Ø¯Ø®Ù„ â†’ Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
    if (!text) {
      let operationsList = operations
        .map((op, index) => `${index + 1}. ${op.name}`)
        .join("\n");
      return ctx.reply(`ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­:\n\nÙ…Ø«Ø§Ù„: /buti 12\n\n${operationsList}`);
    }

    const inputArray = text.split(" ");
    const operationNumber = parseInt(inputArray[0]) - 1;
    const secondInput = inputArray.slice(1).join(" ");

    if (
      isNaN(operationNumber) ||
      operationNumber < 0 ||
      operationNumber >= operations.length
    ) {
      return ctx.reply("ğŸ©¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.");
    }

    await ctx.reply("â™»ï¸ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const imageBuffer = (
      await axios.get(fileLink.href, { responseType: "arraybuffer" })
    ).data;

    let image = await Jimp.read(imageBuffer);

    // Ø¹Ù…Ù„ÙŠØ§Øª Ø®Ø§ØµØ©
    if (operations[operationNumber].name === "ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¨ÙˆØ±ØªØ±ÙŠÙ‡") {
      const portraitWidth = image.bitmap.height * (9 / 16);
      image.resize(portraitWidth, image.bitmap.height);
      image.crop(0, 0, portraitWidth, image.bitmap.height);
    }

    if (operations[operationNumber].name === "ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù„ÙˆØ§Ù†") {
      if (secondInput) {
        const colorIndex = parseInt(secondInput) - 1;
        if (colorIndex < 0 || colorIndex >= colorOptions.length) {
          return ctx.reply("ğŸ©¸ Ø§Ø®ØªØ± Ø±Ù‚Ù… Ù„ÙˆÙ† ØµØ­ÙŠØ­.");
        }
        const selectedColor = colorOptions[colorIndex].color;
        image.color([{ apply: "mix", params: [selectedColor, 100] }]);
      } else {
        const colorList = colorOptions
          .map((col, index) => `${index + 1}. ${col.name}`)
          .join("\n");
        return ctx.reply(`Ø§Ø®ØªØ± Ø§Ù„Ù„ÙˆÙ†:\n\n${colorList}`);
      }
    }

    if (operations[operationNumber].name === "Ø¥Ø¶Ø§ÙØ© Ù†Øµ") {
      if (!secondInput) {
        return ctx.reply("ğŸ©¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.");
      }
      const font = await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE);
      const textWidth = Jimp.measureText(font, secondInput);
      const textHeight = Jimp.measureTextHeight(font, secondInput);
      image.print(
        font,
        image.bitmap.width / 2 - textWidth / 2,
        image.bitmap.height - textHeight - 10,
        secondInput
      );
    }

    if (operations[operationNumber].name === "ÙˆØ¶Ø¹ Ø¥Ø·Ø§Ø± Ù…Ø´ÙˆØ´") {
      const blurredImage = image.clone().blur(10);
      const blurredWidth = image.bitmap.width * 2;
      const blurredHeight = image.bitmap.height * 2;
      blurredImage.resize(blurredWidth, blurredHeight);
      blurredImage.composite(
        image,
        (blurredWidth - image.bitmap.width) / 2,
        (blurredHeight - image.bitmap.height) / 2
      );
      image = blurredImage;
    }

    if (operations[operationNumber].name === "Ù‚Øµ Ø§Ù„ØµÙˆØ±Ø©") {
      const width = image.bitmap.width;
      const height = image.bitmap.height;
      const cropWidth = height / 2;
      const cropHeight = height;
      const x = width / 2 - cropWidth / 2;
      const y = height / 2 - cropHeight / 2;
      image.crop(x, y, cropWidth, cropHeight);
    }

    // Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
    const operationFunction = operations[operationNumber].operation;
    if (operationFunction && typeof operationFunction === "function") {
      await operationFunction(image);
    }

    const processedImageBuffer = await image.getBufferAsync(Jimp.MIME_JPEG);

    await ctx.replyWithPhoto(
      { source: processedImageBuffer },
      { caption: `ğŸ©¸ ØªÙ… ØªØ·Ø¨ÙŠÙ‚ "${operations[operationNumber].name}"` }
    );
  } catch (error) {
    console.error(error);
    ctx.reply(`ğŸ©¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ${error.message}`);
  }
});

bot.command(["google", "Ø¨Ø­Ø«", "Ø¬ÙˆØ¬Ù„"], async (ctx) => {
  const query = ctx.message.text.split(" ").slice(1).join(" ");
  if (!query) {
    return ctx.reply("â—ğŸ•·ï¸ Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ¨Ø­Ø« Ø¹Ù†Ù‡Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø± ğŸ©¸");
  }

  await ctx.reply("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...");

  try {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù„Ù‰ DuckDuckGo
    const url = `https://lite.duckduckgo.com/lite/?q=${encodeURIComponent(query)}`;
    const { data } = await axios.get(url, {
      headers: { "User-Agent": "Mozilla/5.0" },
    });

    const $ = cheerio.load(data);
    let results = [];

    $("a.result-link").each((i, el) => {
      const link = $(el).attr("href");
      const title = $(el).text().trim();
      const parent = $(el).parent();
      const description = parent.find("br").next().text().trim();

      if (title && link) {
        results.push({
          title,
          description: description || "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ ØªÙØµÙŠÙ„ÙŠ.",
          link,
        });
      }
    });

    if (!results.length) {
      return ctx.reply("âŒ Ù…Ø´ Ù„Ø§Ù‚ÙŠ Ø£ÙŠ Ù†ØªÙŠØ¬Ø© Ù„Ù„Ø¨Ø­Ø« Ø¯Ù‡.");
    }

    // Ø¬Ù„Ø¨ ØµÙˆØ±Ø©
    async function fetchImage(q) {
      try {
        const imgUrl = `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(q)}`;
        const { data } = await axios.get(imgUrl, {
          headers: { "User-Agent": "Mozilla/5.0" },
        });
        const $ = cheerio.load(data);
        const imageUrl = $("img").first().attr("src");
        return imageUrl?.startsWith("http") ? imageUrl : null;
      } catch {
        return null;
      }
    }

    // Ø¹Ø±Ø¶ Ø£ÙˆÙ„ 5 Ù†ØªØ§Ø¦Ø¬
    for (let i = 0; i < Math.min(results.length, 5); i++) {
      const res = results[i];
      const img = (await fetchImage(res.title)) || "https://files.catbox.moe/ggxx14.jpg";

      await ctx.replyWithPhoto(
        { url: img },
        {
          caption: `â² Ë¼Ù†ØªÙŠØ¬Ø© Ø±Ù‚Ù… ${i + 1}Ë¹ â³\n\n*${res.title}*\n${res.description}`,
          parse_mode: "Markdown",
          ...Markup.inlineKeyboard([
            Markup.button.url("ğŸ”— ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø·", res.link),
          ]),
        }
      );
    }
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«.");
  }
});


const istighfar = `
Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø°Ù†Ø¨ Ø£Ø°Ù†Ø¨ØªÙ€Ù€Ù€Ù€Ù€Ù‡ 
Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ÙØ±Ø¶ ØªØ±ÙƒØªÙ€Ù€Ù€Ù‡ 
Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¥Ù†Ø³Ø§Ù† Ø¸Ù„Ù…ØªÙ€Ù€Ù‡ 
Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ØµØ§Ù„Ø­ Ø¬ÙÙˆØªÙ€Ù€Ù‡ 
Ø¯Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¸Ø§Ù„Ù… ØµØ§Ø­Ø¨ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¨Ø± Ø£Ø¬Ù„ØªÙ€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù†Ø§ØµØ­ Ø£Ù‡Ù†ØªÙ€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù…Ø­Ù…ÙˆØ¯ Ø³Ø¦Ù…ØªÙ€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø²ÙˆØ± Ù†Ø·Ù‚Ù€Øª Ø¨Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø­Ù‚ Ø§Ø¶Ø¹ØªÙ€Ù€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¨Ø§Ø·Ù„ Ø¥ØªØ¨Ø¹ØªÙ€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ÙˆÙ‚Øª Ø£Ù‡Ø¯Ø±ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¶Ù…ÙŠØ± Ù‚ØªÙ„ØªÙ€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø³Ø± Ø£ÙØ´ÙŠØªÙ€Ù€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø£Ù…ÙŠÙ† Ø®Ø¯Ø¹ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ÙˆØ¹Ø¯ Ø£Ø®Ù„ÙØªÙ€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¹Ù‡Ø¯ Ø®Ù†ØªÙ€Ù€Ù€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø§Ù…Ø±Ø¦ Ø®Ø°Ù„ØªÙ€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ØµÙˆØ§Ø¨ ÙƒØªÙ…ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø®Ø·Ø£ ØªÙÙˆÙ‡Ù€Øª Ø¨Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¹Ø±Ø¶ Ù‡ØªÙƒØªÙ€Ù€Ù‡ 
Ø¯Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø³ØªØ± ÙØ¶Ø­ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù„ØºÙˆ Ø³Ù…Ø¹ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø­Ø±Ø§Ù… Ù†Ø¸Ø±Øª Ø¥Ù„ÙŠÙ€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ÙƒÙ„Ø§Ù… Ù„Ù‡ÙˆØª Ø¨Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¥Ø«Ù€Ù… ÙØ¹Ù„ØªÙ€Ù€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù†ØµØ­ Ø®Ø§Ù„ÙØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¹Ù„Ù… Ù†Ø³ÙŠØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø´Ùƒ Ø£Ø·Ø¹ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¸Ù† Ù„Ø§Ø²Ù…ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¶Ù„Ø§Ù„ Ø¹Ø±ÙØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¯ÙŠÙ† Ø£Ù‡Ù…Ù„ØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ… 
Ù…Ù† ÙƒÙ„ Ù…Ø¹ØµÙŠØ© Ø¹ØµÙŠØª Ø¨Ù‡Ø§ Ø±Ø¨ÙŠ
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù…Ø§ ÙˆØ¹Ø¯ØªÙƒ Ø¨Ù‡ Ø«Ù… Ø¹Ø¯Øª ÙÙŠÙ‡ Ù…Ù† Ù†ÙØ³ÙŠ ÙˆÙ„Ù… Ø£ÙˆÙ Ø¨Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¹Ù…Ù„ Ø£Ø±Ø¯Øª Ø¨Ù‡ ÙˆØ¬Ù‡Ùƒ ÙØ®Ø§Ù„Ø·Ù†ÙŠ Ø¨Ù‡ ØºÙŠØ±Ùƒ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù†Ø¹Ù…Ø© Ø£Ù†Ø¹Ù…Øª Ø¹Ù„ÙŠ Ø¨Ù‡Ø§ ÙØ§Ø³ØªØ¹Ù†Øª Ø¨Ù‡Ø§ Ø¹Ù„Ù‰ Ù…Ø¹ØµÙŠØªÙƒ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø°Ù†Ø¨ Ø£Ø°Ù†Ø¨ØªÙ‡ ÙÙŠ Ø¶ÙŠØ§Ø¡ Ø§Ù„Ù†Ù‡Ø§Ø± Ø£Ùˆ Ø³ÙˆØ§Ø¯ Ø§Ù„Ù„ÙŠÙ„ ÙÙŠ Ù…Ù„Ø£ Ø£Ùˆ Ø®Ù„Ø§ Ø£Ùˆ Ø³Ø± Ø£Ùˆ Ø¹Ù„Ø§Ù†ÙŠØ© 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù…Ø§Ù„ Ø¥ÙƒØªØ³Ø¨ØªÙ‡ Ø¨ØºÙŠØ± Ø§Ù„Ø­Ù‚ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ø¹Ù„Ù… Ø³Ø¦Ù„Øª Ø¹Ù†Ù‡ ÙÙƒØªÙ…ØªÙ‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ Ù‚ÙˆÙ„ ØµØ§Ù„Ø­ Ù„Ù… Ø£Ø¹Ù…Ù„ Ø¨Ù‡ ÙˆØ®Ø§Ù„ÙØªÙ€Ù€Ù‡ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…
Ù…Ù† ÙƒÙ„ ÙØ±Ø¶ Ø®Ø§Ù„ÙØªÙ‡ ÙˆÙ…Ù† ÙƒÙ„ Ø¨Ø¯Ø¹Ø© Ø¥ØªØ¨Ø¹ØªÙ‡Ù€Ù€Ø§ 
Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù‚ÙŠÙˆÙ… ÙˆØ£ØªÙˆØ¨ Ø¥Ù„ÙŠÙ‡ 
Ø§Ø³ØªØºÙØ±Ùƒ Ø±Ø¨ÙŠ Ù„ØªÙ‚ØµÙŠØ±ÙŠÙ‘ ÙˆÙ‚Ù„Ø© ØµØ¨Ø±ÙŠ 
Ø·Ø§Ø³ØªØºÙØ±Ùƒ Ø±Ø¨ÙŠ Ø­ØªÙ‰ ØªØºÙØ± Ù„ÙŠÙ‘ ÙˆØªØ±Ø­Ù… Ø¶Ø¹ÙÙŠÙ‘
Ø§Ø³ØªØºÙØ±Ùƒ Ø±Ø¨ÙŠ Ø­ØªÙ‰ ØªØ±Ø¶Ù‰ Ø¹Ù†ÙŠ ÙˆØªØ¯Ø®Ù„Ù†ÙŠ Ø¬Ù†ØªÙƒ Ø¥Ù†Ùƒ Ø£Ù†Øª Ø§Ù„ØªÙˆÙ‘Ø§Ø¨ Ø§Ù„ØºÙÙˆØ±
`;

// ğŸŸ¢ Ø£Ù…Ø± Ø§Ù„Ø§Ø³ØªØºÙØ§Ø±
bot.command(["Ø§Ø³ØªØºÙØ§Ø±", "Ø§Ø³ØªØºÙØ§Ø±Ø§Øª"], async (ctx) => {
  await ctx.reply(istighfar, { parse_mode: "Markdown" });
});



bot.command("to_text", async (ctx) => {
  try {
    if (!ctx.message.reply_to_message || !ctx.message.reply_to_message.voice) {
      return ctx.reply("ğŸ“ Ù„Ø§Ø²Ù… ØªØ±Ø¯ Ø¹Ù„Ù‰ Ù…Ù‚Ø·Ø¹ ØµÙˆØªÙŠ!");
    }

    await ctx.reply("ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­ÙˆÙŠÙ„...");

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
    const fileId = ctx.message.reply_to_message.voice.file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const audioBuffer = (await axios.get(fileLink.href, { responseType: "arraybuffer" })).data;

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ù…Ø¤Ù‚Øª
    await fs.mkdir("./tmp", { recursive: true });
    const inputPath = path.join("./tmp", `input_${Date.now()}.ogg`);
    const outputPath = path.join("./tmp", `output_${Date.now()}.mp3`);

    await fs.writeFile(inputPath, audioBuffer);

    // ØªØ­ÙˆÙŠÙ„ ogg â†’ mp3
    await new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .setFfmpegPath(ffmpegStatic)
        .noVideo()
        .audioCodec("libmp3lame")
        .format("mp3")
        .output(outputPath)
        .on("end", () => resolve())
        .on("error", (err) => reject(err))
        .run();
    });

    const mp3Buffer = await fs.readFile(outputPath);

    // Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¹Ù„Ù‰ catbox
    const form = new FormData();
    form.append("reqtype", "fileupload");
    form.append("fileToUpload", mp3Buffer, "audio.mp3");

    const catboxRes = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders(),
    });

    const catboxUrl = catboxRes.data;
    if (!catboxUrl.includes("catbox.moe")) {
      throw new Error("ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¹Ù„Ù‰ catbox");
    }

    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØª Ù„Ù†Øµ
    const apiUrl = `https://api.ubed.my.id/ai/audio-analyze-ui?q=Ø­ÙˆÙ„%20Ù‡Ø°Ø§%20Ø§Ù„ØµÙˆØª%20Ø§Ù„Ù‰%20ÙƒÙ„Ù…Ø§Øª&url=${encodeURIComponent(catboxUrl)}&apikey=free1`;
    const { data } = await axios.get(apiUrl);

    if (data.status !== "Success" || !data.result) {
      throw new Error("ÙØ´Ù„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØµÙˆØª");
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ ÙÙŠ Ø§Ù„Ø´Ø§Øª
    await ctx.reply(`ğŸ§ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬:\n\n${data.result}`);

    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ù„ÙØ§Øª
    await fs.unlink(inputPath).catch(() => {});
    await fs.unlink(outputPath).catch(() => {});
  } catch (err) {
    console.error(err);
    await ctx.reply(`âŒ Ø­ØµÙ„ Ø®Ø·Ø£: ${err.message || err}`);
  }
});



bot.command(["out", "leavegc", "Ø§Ø®Ø±Ø¬", "Ø¨Ø±Ø§"], async (ctx) => {
  const chatId = ctx.chat.id;
  const userId = String(ctx.from.id);

  // Ø§Ù„Ø³Ù…Ø§Ø­ ÙÙ‚Ø· Ù„Ù„Ù…Ø·ÙˆØ± Ø£Ùˆ Ø§Ù„Ø¯ÙŠÙÙŠÙ„ÙˆØ¨Ø±
  if (!OWNER_ID.includes(userId) && !DEVELOPERS.includes(userId)) {
    return ctx.reply("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·!");
  }

  await ctx.reply("ã€ Ø­Ø§Ø¶Ø± ÙŠØ§ Ù…Ø·ÙˆØ±ÙŠ Ø§Ù†Ø§ Ø®Ø§Ø±Ø¬ Ø¨Ø§ÙŠ ğŸ¥ºğŸ’— ã€");

  try {
    await ctx.telegram.leaveChat(chatId);
  } catch (err) {
    console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ø¬Ø±ÙˆØ¨:", err);
    await ctx.reply("âš ï¸ Ø­ØµÙ„ Ø®Ø·Ø£ ÙˆÙ…Ù‚Ø¯Ø±ØªØ´ Ø£Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø¬Ø±ÙˆØ¨");
  }
});

// ğŸŸ¢ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙˆÙ‚Øª Ø¥Ù„Ù‰ Ù†Ø¸Ø§Ù… 12 Ø³Ø§Ø¹Ø©*


// ğŸŸ¢ ØªØ­ÙˆÙŠÙ„ Ù…Ù† 24 Ø³Ø§Ø¹Ø© â†’ 12 Ø³Ø§Ø¹Ø©
function format12HourTime(time24) {
  const [hours, minutes] = time24.split(":");
  let period = "AM";
  let hours12 = parseInt(hours, 10);

  if (hours12 >= 12) {
    period = "PM";
    if (hours12 > 12) hours12 -= 12;
  }

  return `${hours12}:${minutes} ${period}`;
}

// ğŸŸ¢ Ø§Ù„Ù…Ø¯Ù† + Ø§Ù„Ø¯ÙˆÙ„Ø©
const cityCountryMap = {
  "c": "EG",
  "Ø§Ù„Ø±ÙŠØ§Ø¶": "SA",
  "Ø¯Ø¨ÙŠ": "AE",
  "Ø¨ÙŠØ±ÙˆØª": "LB",
  "ØªÙˆÙ†Ø³": "TN",
  "Ø¨ØºØ¯Ø§Ø¯": "IQ",
  "Ø¹Ù…Ø§Ù†": "JO",
  "Ù…Ø³Ù‚Ø·": "OM",
  "Ø§Ù„Ø¯ÙˆØ­Ø©": "QA",
  "Ø§Ù„ÙƒÙˆÙŠØª": "KW",
  "Ù…ÙƒØ©": "SA",
  "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©": "SA",
};

// ğŸŸ¢ ØµÙˆØ± Ø®Ù„ÙÙŠØ©
const images = [
  "https://raw.githubusercontent.com/Mohnd32145/Media/master/menus/a6.jpg",
  "https://raw.githubusercontent.com/Mohnd32145/Media/master/menus/a4.jpg",
  "https://raw.githubusercontent.com/Mohnd32145/Media/master/menus/a5.jpg",
];

// ğŸŸ¢ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯
const cityKeyboard = [
  [
    { text: "ğŸ•Œ Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©", callback_data: "salah_c" },
    { text: "ğŸ•Œ Ø§Ù„Ø±ÙŠØ§Ø¶", callback_data: "salah_Ø§Ù„Ø±ÙŠØ§Ø¶" },
  ],
  [
    { text: "ğŸ•Œ Ø¯Ø¨ÙŠ", callback_data: "salah_Ø¯Ø¨ÙŠ" },
    { text: "ğŸ•Œ Ø¨ÙŠØ±ÙˆØª", callback_data: "salah_Ø¨ÙŠØ±ÙˆØª" },
  ],
  [
    { text: "ğŸ•Œ ØªÙˆÙ†Ø³", callback_data: "salah_ØªÙˆÙ†Ø³" },
    { text: "ğŸ•Œ Ø¨ØºØ¯Ø§Ø¯", callback_data: "salah_Ø¨ØºØ¯Ø§Ø¯" },
  ],
  [
    { text: "ğŸ•Œ Ø¹Ù…Ø§Ù†", callback_data: "salah_Ø¹Ù…Ø§Ù†" },
    { text: "ğŸ•Œ Ù…Ø³Ù‚Ø·", callback_data: "salah_Ù…Ø³Ù‚Ø·" },
  ],
  [
    { text: "ğŸ•Œ Ø§Ù„Ø¯ÙˆØ­Ø©", callback_data: "salah_Ø§Ù„Ø¯ÙˆØ­Ø©" },
    { text: "ğŸ•Œ Ø§Ù„ÙƒÙˆÙŠØª", callback_data: "salah_Ø§Ù„ÙƒÙˆÙŠØª" },
  ],
  [
    { text: "ğŸ•‹ Ù…ÙƒØ©", callback_data: "salah_Ù…ÙƒØ©" },
    { text: "ğŸ•Œ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©", callback_data: "salah_Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" },
  ],
];

// ğŸŸ¢ Ø£Ù…Ø± Ø§Ù„ØµÙ„Ø§Ø©
function setupPrayer(bot) {
  bot.command(["salah", "azan"], async (ctx) => {
    const randomImage = images[Math.floor(Math.random() * images.length)];

    return ctx.replyWithPhoto(
      { url: randomImage },
      {
        caption: `ğŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§ ${ctx.from.first_name}\n\nğŸ“Œ Ø§Ø®ØªØ± Ù…Ø¯ÙŠÙ†ØªÙƒ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:`,
        reply_markup: {
          inline_keyboard: cityKeyboard,
        },
      }
    );
  });

  // ğŸŸ¢ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
  bot.on("callback_query", async (ctx) => {
    const data = ctx.callbackQuery.data;
    if (!data.startsWith("salah_")) return; // ØªØ¬Ø§Ù‡Ù„ ØºÙŠØ± Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØµÙ„Ø§Ø©

    const city = data.replace("salah_", "");
    const country = cityCountryMap[city] || "EG";
    const randomImage = images[Math.floor(Math.random() * images.length)];

    try {
      const prayerResponse = await axios.get(
        `http://api.aladhan.com/v1/timingsByCity?city=${encodeURIComponent(
          city
        )}&country=${country}`
      );
      const prayerData = prayerResponse.data.data.timings;

      const fajr = format12HourTime(prayerData.Fajr);
      const sunrise = format12HourTime(prayerData.Sunrise);
      const dhuhr = format12HourTime(prayerData.Dhuhr);
      const asr = format12HourTime(prayerData.Asr);
      const maghrib = format12HourTime(prayerData.Maghrib);
      const isha = format12HourTime(prayerData.Isha);

      const prayerMessage = `ğŸ•Œ Ù…ÙˆØ§Ù‚ÙŠØª Ø§Ù„ØµÙ„Ø§Ø© ÙÙŠ ${city} Ø§Ù„ÙŠÙˆÙ…:\n\n- Ø§Ù„ÙØ¬Ø±: ${fajr}\n- Ø§Ù„Ø´Ø±ÙˆÙ‚: ${sunrise}\n- Ø§Ù„Ø¸Ù‡Ø±: ${dhuhr}\n- Ø§Ù„Ø¹ØµØ±: ${asr}\n- Ø§Ù„Ù…ØºØ±Ø¨: ${maghrib}\n- Ø§Ù„Ø¹Ø´Ø§Ø¡: ${isha}`;

      await ctx.replyWithPhoto(
        { url: randomImage },
        { caption: prayerMessage, parse_mode: "Markdown" }
      );
    } catch (error) {
      console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ù…ÙˆØ§Ù‚ÙŠØª Ø§Ù„ØµÙ„Ø§Ø©:", error);
      ctx.reply("âŒ Ø¹Ø°Ø±Ù‹Ø§ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…ÙˆØ§Ù‚ÙŠØª Ø§Ù„ØµÙ„Ø§Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©.");
    }

    await ctx.answerCbQuery();
  });
}

// ğŸŸ¢ Ø´ØºÙ‘Ù„ Ø§Ù„ÙØ§Ù†ÙƒØ´Ù†
setupPrayer(bot);

// ğŸŸ¢ Ø´ØºÙ„ Ø§

// ğŸŸ¢ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª




// ØµÙˆØ± Ø§Ù„Ù…ÙŠÙ…Ø²
const dir = [
"https://telegra.ph/file/bdbdda3294d2f65bd5c23.jpg",
"https://telegra.ph/file/79472b6a1ae9208339e8d.jpg",
"https://telegra.ph/file/04f1cbac5342f631306b1.jpg",
"https://telegra.ph/file/a1cae6b105bf11c5cd35f.jpg",
"https://telegra.ph/file/855eb59de3efa1c343852.jpg",
"https://telegra.ph/file/b778d3e166d015744f803.jpg",
"https://telegra.ph/file/522cba3b013deb912b670.jpg",
"https://telegra.ph/file/bbb2a3c02e5c0e3b44b46.jpg",
"https://telegra.ph/file/fec2c6bb18eb55b706ebf.jpg",
"https://telegra.ph/file/10e1e9742c20f2b472b85.jpg",
"https://telegra.ph/file/d2632bd14d4f58ad4d2a5.jpg",
"https://telegra.ph/file/1c8ffe52df95f982a4479.jpg",
"https://telegra.ph/file/1d31d899d32fcde8a1917.jpg",
"https://telegra.ph/file/eeda4919ca224672e531c.jpg",
"https://telegra.ph/file/a92695904d1afbeacefe1.jpg",
"https://telegra.ph/file/77abbc4d8857b07ec2975.jpg",
"https://telegra.ph/file/d14581c30c22882ed5bdd.jpg",
"https://telegra.ph/file/bd3d0cdb1001a95ecb23a.jpg",
"https://telegra.ph/file/691b4f81349158ea567b3.jpg",
"https://telegra.ph/file/d51e27f968ddfe9355b37.jpg",
"https://telegra.ph/file/8304d127b062df9a30211.jpg",
"https://telegra.ph/file/c0b210e135bba30d0d98c.jpg",
"https://telegra.ph/file/262246248cf2fc2ec8c15.jpg",
"https://telegra.ph/file/b02afc8cc380e77d9bd46.jpg",
"https://telegra.ph/file/8e20dcd2f3eafbfa8959f.jpg",
"https://telegra.ph/file/8e26a3c5a3ce6ce5494b9.jpg",
"https://telegra.ph/file/caa5ab0534291faebc2ac.jpg",
"https://telegra.ph/file/33ea0c1803e1876b1a446.jpg",
"https://telegra.ph/file/367b322fbbfc9bd59ec67.jpg",
"https://telegra.ph/file/d9127ea1389abaacb5ffa.jpg",
"https://telegra.ph/file/260f66ab9627e34d25135.jpg",
"https://telegra.ph/file/a646c2e04149e51a0b1f7.jpg",
"https://telegra.ph/file/6f0eb3f5c166e3424641a.jpg",
"https://telegra.ph/file/bc4d7e99023bd9081eed8.jpg",
"https://telegra.ph/file/d96eb83dbeb9acb2cc724.jpg",
"https://telegra.ph/file/63f9e43cecddb02030639.jpg",
"https://telegra.ph/file/50eb92b1f92e8fd3eddfe.jpg",
"https://telegra.ph/file/1d635087d4323a5cc13e2.jpg",
"https://telegra.ph/file/17e1eeb1cac42a2c4c980.jpg",
"https://telegra.ph/file/6e28ba52901ebe9329466.jpg",
"https://telegra.ph/file/e8cab17d03a4a70fb6a7d.jpg",
"https://telegra.ph/file/464f69ff5a2e5b360be90.jpg",
"https://telegra.ph/file/f2b4a547cde3104d465d6.jpg",
"https://telegra.ph/file/5104c56e322f21061cb88.jpg",
"https://telegra.ph/file/226225ea7df934f81c06a.jpg",
"https://telegra.ph/file/4554e95993f0a68e3c1e4.jpg",  
"https://telegra.ph/file/f92b992ec5778364a53e2.jpg",
"https://telegra.ph/file/7cb8c62a834c725e4f9d8.jpg",
"https://telegra.ph/file/52685cf01fc3b883dcf21.jpg",
"https://telegra.ph/file/985846b2beffc26e1686a.jpg",
"https://telegra.ph/file/40951997ad53141cd99cb.jpg",
"https://telegra.ph/file/4c027d0666c5513634a83.jpg",
"https://telegra.ph/file/25a14cd4fff811de1475f.jpg",
"https://telegra.ph/file/645de7e8ce68ade591bb2.jpg",
"https://telegra.ph/file/4b540ca77c8b2a1d1ec57.jpg",
"https://telegra.ph/file/53a5a6a5b2d71c6d3c163.jpg",
"https://telegra.ph/file/48571aa7be63a3de59ff2.jpg",
"https://telegra.ph/file/553bca98fe9dec4270ad7.jpg",
"https://telegra.ph/file/87a7bda3cfde01d2348ed.jpg",
"https://telegra.ph/file/7c24e7540548c2d74d424.jpg",
"https://telegra.ph/file/60eeedd13a6bb5be507b5.jpg",
"https://telegra.ph/file/328d7865de1bd1971a557.jpg",
"https://telegra.ph/file/e4b0461725fc22520eda9.jpg",
"https://telegra.ph/file/9bb6046502993d6ce6518.jpg",
"https://telegra.ph/file/8890c73047805cf78c00a.jpg",
"https://telegra.ph/file/dc81295351494c2a1c472.jpg",
"https://telegra.ph/file/4232a1c385ff9da68aef6.jpg",
"https://telegra.ph/file/ea550661d8ab4b84c6296.jpg",
"https://telegra.ph/file/8b2190dc849e24972152c.jpg",
"https://telegra.ph/file/f207b57a1f51412a203e7.jpg",
"https://telegra.ph/file/cf2fccd900ff2d0d131a1.jpg",
"https://telegra.ph/file/940e82466ed78e975a745.jpg",
"https://telegra.ph/file/b0c749d5e802332dcc11f.jpg",
"https://telegra.ph/file/769d89ef7f7336bd05a80.jpg",
"https://telegra.ph/file/f9138226511b3a30e958b.jpg",
"https://telegra.ph/file/8281fdf957ebca93aec0f.jpg",
"https://telegra.ph/file/3c6dd91466c9ed89d2bf7.jpg",
"https://telegra.ph/file/8bcad0c566c5f51ffe5bb.jpg",
"https://telegra.ph/file/4ac11fe77b659d5168b1e.jpg",
"https://telegra.ph/file/c3fcd3e486c6a3bee6f4f.jpg",
"https://telegra.ph/file/31de70933034c724b74f1.jpg",
"https://telegra.ph/file/2d249ca2b62c18af6baa3.jpg",
"https://telegra.ph/file/ef8ebed7d971ce6de5ee9.jpg",
"https://telegra.ph/file/777fb5cb0f6be330f9b8a.jpg",
"https://telegra.ph/file/20aef78978a92b8b0444b.jpg",
"https://telegra.ph/file/20bc0e05daf3272ea89b9.jpg",
"https://telegra.ph/file/a915d3752bac387b81adf.jpg",
"https://telegra.ph/file/c20048814324dd1a1bb77.jpg",
"https://telegra.ph/file/3b945a8a14851ece29de7.jpg",
"https://telegra.ph/file/abf7e03745ca2d298a9c1.jpg",
"https://telegra.ph/file/13e4a77349596c5ab8a79.jpg",
"https://telegra.ph/file/32bc65b3c0baa1eb6c284.jpg",
"https://telegra.ph/file/1c231e0675b7f6edd579a.jpg",
"https://telegra.ph/file/c564473a41ab8405dc3b9.jpg",
"https://telegra.ph/file/aa8bd2a777b01d0b24f4d.jpg",
"https://telegra.ph/file/a915d3752bac387b81adf.jpg",
"https://telegra.ph/file/59c075e64bdd0e17b659f.jpg",
"https://telegra.ph/file/f7c59f1787705d36043ca.jpg",
"https://telegra.ph/file/c20048814324dd1a1bb77.jpg",
"https://telegra.ph/file/d9153d75fc60d64026525.jpg",
"https://telegra.ph/file/3b945a8a14851ece29de7.jpg",
"https://telegra.ph/file/1c678a25b8b6482bc3cba.jpg",
"https://telegra.ph/file/cbc63680e04511756d57a.jpg",
"https://telegra.ph/file/f7c59f1787705d36043ca.jpg",
"https://telegra.ph/file/58081f8a94dbd1d1caf40.jpg",
"https://telegra.ph/file/e1539e82d5bc96bc9f15e.jpg",
"https://telegra.ph/file/36efa93ee22207c36ad2d.jpg",
"https://telegra.ph/file/6df3e879dd9c2e908859f.jpg",
"https://telegra.ph/file/cbc63680e04511756d57a.jpg",
"https://telegra.ph/file/65dc15eb996d69742fcb9.jpg",
"https://telegra.ph/file/986928ae97ba48c5f54be.jpg",
"https://telegra.ph/file/92379479bbe99f312f13f.jpg",
"https://telegra.ph/file/c46fda1ffbbaa3c406a29.jpg",
"https://telegra.ph/file/0d32e11e4a0dae13dac3d.jpg",
"https://telegra.ph/file/13a65df594224f0c46561.jpg",
"https://telegra.ph/file/17d2fd7d6e0fbfe0d74dd.jpg",
"https://telegra.ph/file/98acc5caa337ba06407b5.jpg",
"https://telegra.ph/file/102561f89b0967f27ce63.jpg",
"https://telegra.ph/file/e4f06eb175994ef6ebd41.jpg",
"https://telegra.ph/file/bf3a36c8f30e56dcbbfa5.jpg",
"https://telegra.ph/file/3a5b3ea59347b2f8fb805.jpg",
"https://telegra.ph/file/60262d7d56b4352993e88.jpg",
"https://telegra.ph/file/efbcd6bd3cd12b210d77c.jpg",
"https://telegra.ph/file/2d692d315587805dde1a9.jpg",
"https://telegra.ph/file/e51a3c070b031ccefb801.jpg",
"https://telegra.ph/file/a0a8e70592a5b2ccd2987.jpg",
"https://telegra.ph/file/5e1fc88c8803a0fc31523.jpg",
"https://telegra.ph/file/1f54bdd48b568aa05d593.jpg",
"https://telegra.ph/file/62ac12702441491e0c73b.jpg",
"https://telegra.ph/file/fa537428bb58b297e3ed3.jpg",
"https://telegra.ph/file/3155c1dc08fa26970d858.jpg",
"https://telegra.ph/file/e926a13e06728028d860d.jpg",
"https://telegra.ph/file/71e8a40317d9dd6dce50f.jpg",
"https://telegra.ph/file/1c9f11a44ac8ed88e073e.jpg",
"https://telegra.ph/file/271155de61db260ef09ba.jpg",
"https://telegra.ph/file/d898b26a10495e8c6792b.jpg",
"https://telegra.ph/file/f6b71e125dd4971253c39.jpg",
"https://telegra.ph/file/73e9f8a1692c470e63d04.jpg",
"https://telegra.ph/file/6c72d75cbb596fd757aba.jpg",
"https://telegra.ph/file/ede1c654d4c218c0b263b.jpg",
"https://telegra.ph/file/078671b7aee6dd8c4ae09.jpg",
"https://telegra.ph/file/04f6a1c2c271e3d0d9b08.jpg",
"https://telegra.ph/file/e1f3bc35cb2b201ec12e4.jpg",
"https://telegra.ph/file/0d6fb4189e171d90505f8.jpg",
"https://telegra.ph/file/efa364c3e60769ba75743.jpg",
"https://telegra.ph/file/65bf5dbc42b5c43fc5d2f.jpg",
"https://telegra.ph/file/03fd2e33eef17aa189e5a.jpg",
"https://telegra.ph/file/03fd2e33eef17aa189e5a.jpg",
"https://telegra.ph/file/855054f8f233540b8bdc7.jpg",
"https://telegra.ph/file/9c5e03843b07195c0e6d2.jpg",
"https://telegra.ph/file/5040ad2d3824e605df811.jpg",
  "https://telegra.ph/file/37654136d433cda49ddb5.jpg",
  "https://telegra.ph/file/4e5fae97ae4b8c2ada150.jpg",,
  "https://telegra.ph/file/967127100f10b8ecc6742.jpg",
  "https://telegra.ph/file/a0823ec4d76263f622bdb.jpg",
  "https://telegra.ph/file/0c52413904c09dfd2c811.jpg",
  "https://telegra.ph/file/07523b69ef4b36beb72d8.jpg",
  "https://telegra.ph/file/59afbca42e21f65f8cc15.jpg",
  "https://telegra.ph/file/2647f82b1a7e234a7809b.jpg",
  "https://telegra.ph/file/fd083fff3325929f0cdfd.jpg",
  "https://telegra.ph/file/be68121fa84422176bb28.jpg",
  "https://telegra.ph/file/969f822a24b4cd282cf76.jpg",
  "https://telegra.ph/file/aeecfb155e3cf7f0f5947.jpg",
  "https://telegra.ph/file/c678efc3ef7a1bc493119.jpg",
  "https://telegra.ph/file/fe2b8457c71bff359507e.jpg",
  "https://telegra.ph/file/e4a66bf21e84f4621414b.jpg",
  "https://telegra.ph/file/3bc11661292338b406b3e.jpg",
  "https://telegra.ph/file/c5b202989866b8846602a.jpg",
  "https://telegra.ph/file/503e51ef861e759700453.jpg",
  "https://telegra.ph/file/31c8c3e15a9746027c350.jpg",
  "https://telegra.ph/file/fbcffd3f0382ef3c1e7fd.jpg",
  "https://telegra.ph/file/6c14f8480ab9e8ed83612.jpg",
  "https://telegra.ph/file/910adda99f8a81b5a65e7.jpg",
  "https://telegra.ph/file/ab8dea1ffd87d9c179f14.jpg",
  "https://telegra.ph/file/220aaf3e0ead25c0ce553.jpg",
  "https://telegra.ph/file/8a8cc247936eec334cc42.jpg",
  "https://telegra.ph/file/6f46305f0816b1412298c.jpg",
  "https://telegra.ph/file/6fcb3f6c4c239c8d32859.jpg",
  "https://telegra.ph/file/6f46305f0816b1412298c.jpg",
  "https://telegra.ph/file/845f75cbae119f3115ddb.jpg",
  "https://telegra.ph/file/70bdf0c76dd30d80fa73f.jpg",
  "https://telegra.ph/file/7e6e1bcab1f6617dcf982.jpg",
  "https://telegra.ph/file/6c550192023fa2a255619.jpg",
  "https://telegra.ph/file/048847a5b87dd894abbca.jpg",
  "https://telegra.ph/file/048847a5b87dd894abbca.jpg",
  "https://telegra.ph/file/941bb9cff3d6634507a9a.jpg",
  "https://telegra.ph/file/dd85e81b3966b592b8b9f.jpg",
  "https://telegra.ph/file/e3ecf74b8eae3b6369cdc.jpg",
  "https://telegra.ph/file/23cae8ea8f0d46ff4b54c.jpg",
  "https://telegra.ph/file/e6e87fb7b23930a18d50d.jpg",
  "https://telegra.ph/file/bcbbc1465bf83e3459741.jpg",
  "https://telegra.ph/file/c4b972ad9cc53478f5aed.jpg",
  "https://telegra.ph/file/d766ef3af433954f1e119.jpg",
  "https://telegra.ph/file/bd6eef071257e8f72729f.jpg",
  "https://telegra.ph/file/4c81f511853ef00d4f678.jpg",
  "https://telegra.ph/file/114f0676e58f727f37420.jpg",
  "https://telegra.ph/file/95f8c93dfe10faf881386.jpg",
  "https://telegra.ph/file/68e6576943e747c17b2b8.jpg",
  "https://telegra.ph/file/c546ada04886aa58bfa58.jpg",
  "https://telegra.ph/file/523f47a50a6b2e9c9d01d.jpg",
  "https://telegra.ph/file/b8980fdb0ded2e35cf1f8.jpg",
  "https://telegra.ph/file/b91d6994d92fb14ffb9d9.jpg",
  "https://telegra.ph/file/c24b4695d44f40689da53.jpg",
  "https://telegra.ph/file/ad97b118591b7800ab9d8.jpg",
  "https://telegra.ph/file/eb044c75d915030c690f7.jpg",
  "https://telegra.ph/file/85a3272990ae3d20e4582.jpg",
  "https://telegra.ph/file/ee15d32656ea7ea87b4bc.jpg",
  "https://telegra.ph/file/c30181ddef746cc853314.jpg",
  "https://telegra.ph/file/2ba48ee78f824d27cac27.jpg",
  "https://telegra.ph/file/2ba48ee78f824d27cac27.jpg",
  "https://telegra.ph/file/56f7306292f4ee781f09f.jpg",
  "https://telegra.ph/file/56f7306292f4ee781f09f.jpg",
  "https://telegra.ph/file/50fa0a6787f9b106df01c.jpg",
  "https://telegra.ph/file/32d4406ee5e1cc0f7163a.jpg",
  "https://telegra.ph/file/ded3d5f549f7b29fb5e0f.jpg",
  "https://telegra.ph/file/b9bf5ad89caa694ce7c73.jpg",
  "https://telegra.ph/file/52dd626ac44ac15e47fc8.jpg",
  "https://telegra.ph/file/dd60db0990cd505a4e50b.jpg",
  "https://telegra.ph/file/03d21c2ce1b06c4c23bf7.jpg",
  "https://telegra.ph/file/03d21c2ce1b06c4c23bf7.jpg",
  "https://telegra.ph/file/be83fa88e290369c97882.jpg",
  "https://telegra.ph/file/740ad1859c315fc322191.jpg",
  "https://telegra.ph/file/184bf10e5c1897c6a7adf.jpg",
  "https://telegra.ph/file/ec213ff76cb27ff975fea.jpg",
  "https://telegra.ph/file/557dd9b675438f6948187.jpg",
  "https://telegra.ph/file/c05adb1f1c4b6200f9f4b.jpg",
  "https://telegra.ph/file/748aca5e8ce87270a66c3.jpg",
  "https://telegra.ph/file/1f7212c1f0bfcb4c13104.jpg",
  "https://telegra.ph/file/ca5941dee6d67cbc97ce0.jpg",
  "https://telegra.ph/file/ecf7eef2f09000ef8a97f.jpg",
  "https://telegra.ph/file/52830c9088c96b2f2d9dc.jpg",
  "https://telegra.ph/file/48e1e809ee4a9801a31c0.jpg",
  "https://telegra.ph/file/8b7bc75df501d1aac9999.jpg",
  "https://telegra.ph/file/bfbd6dffb9cdd75c4565f.jpg",
  "https://telegra.ph/file/3ea1374109d9ea837c712.jpg",
  "https://telegra.ph/file/b83bb4de0cb6975393801.jpg",
  "https://telegra.ph/file/d4f04d317996ddbbcfa49.jpg",
  "https://telegra.ph/file/da7a7a09047bb3f77dd1e.jpg",
  "https://telegra.ph/file/45dfd7ef7f7780a3c1f83.jpg",
  "https://telegra.ph/file/ee405de996dd3e52e6feb.jpg",
  "https://telegra.ph/file/6f7860201f620215a1bd3.jpg",
  "https://telegra.ph/file/1fc7a06845f91cc3dbf17.jpg",
  "https://telegra.ph/file/6f2d56a83c667198645f3.jpg",
  "https://telegra.ph/file/f9435fd259a10eb3d4a2f.jpg",
  "https://telegra.ph/file/6f8cb1247e92ebaec48d4.jpg",
  "https://telegra.ph/file/5241d93b0d25644ed4a57.jpg",
  "https://telegra.ph/file/5241d93b0d25644ed4a57.jpg",
  "https://telegra.ph/file/b4076988422ce25d58dae.jpg",
  "https://telegra.ph/file/26b43b07faac626cf5e04.jpg",
  "https://telegra.ph/file/69e0a1a2f58757f132abd.jpg",
  "https://telegra.ph/file/9161c4becc39958ddec42.jpg",
  "https://telegra.ph/file/c529e024dd3b704a43fb6.jpg",
  "https://telegra.ph/file/9567e4783f0fa58c17fd5.jpg",
  "https://telegra.ph/file/0437e79f988ef2e8ce093.jpg",
  "https://telegra.ph/file/ffdf22318450354dc8d3c.jpg",
  "https://telegra.ph/file/c6b1ebb8aa4e23ee9150f.jpg",
"htps://telegra.ph/file/25a14cd4fff811de1475f.jpg",
"https://telegra.ph/file/645de7e8ce68ade591bb2.jpg",
"https://telegra.ph/file/4b540ca77c8b2a1d1ec57.jpg",
"https://telegra.ph/file/53a5a6a5b2d71c6d3c163.jpg",
"https://telegra.ph/file/48571aa7be63a3de59ff2.jpg",
"https://telegra.ph/file/553bca98fe9dec4270ad7.jpg",
"https://telegra.ph/file/87a7bda3cfde01d2348ed.jpg",
"https://telegra.ph/file/7c24e7540548c2d74d424.jpg",
"https://telegra.ph/file/60eeedd13a6bb5be507b5.jpg",
"https://telegra.ph/file/328d7865de1bd1971a557.jpg",
"https://telegra.ph/file/e4b0461725fc22520eda9.jpg",
"https://telegra.ph/file/9bb6046502993d6ce6518.jpg",
"https://telegra.ph/file/8890c73047805cf78c00a.jpg",
"https://telegra.ph/file/dc81295351494c2a1c472.jpg",
"https://telegra.ph/file/4232a1c385ff9da68aef6.jpg",
"https://telegra.ph/file/ea550661d8ab4b84c6296.jpg",
"https://telegra.ph/file/8b2190dc849e24972152c.jpg",
"https://telegra.ph/file/f207b57a1f51412a203e7.jpg",
"https://telegra.ph/file/cf2fccd900ff2d0d131a1.jpg",
"https://telegra.ph/file/940e82466ed78e975a745.jpg",
"https://telegra.ph/file/b0c749d5e802332dcc11f.jpg",
"https://telegra.ph/file/769d89ef7f7336bd05a80.jpg",
"https://telegra.ph/file/f9138226511b3a30e958b.jpg",
"https://telegra.ph/file/8281fdf957ebca93aec0f.jpg",
"https://telegra.ph/file/3c6dd91466c9ed89d2bf7.jpg",
"https://telegra.ph/file/8bcad0c566c5f51ffe5bb.jpg",
"https://telegra.ph/file/4ac11fe77b659d5168b1e.jpg",
"https://telegra.ph/file/c3fcd3e486c6a3bee6f4f.jpg",
"https://telegra.ph/file/31de70933034c724b74f1.jpg",
"https://telegra.ph/file/2d249ca2b62c18af6baa3.jpg",
"https://telegra.ph/file/ef8ebed7d971ce6de5ee9.jpg",
"https://telegra.ph/file/777fb5cb0f6be330f9b8a.jpg",
"https://telegra.ph/file/20aef78978a92b8b0444b.jpg",
"https://telegra.ph/file/20bc0e05daf3272ea89b9.jpg",
"https://telegra.ph/file/a915d3752bac387b81adf.jpg",
"https://telegra.ph/file/c20048814324dd1a1bb77.jpg",
"https://telegra.ph/file/3b945a8a14851ece29de7.jpg",
"https://telegra.ph/file/abf7e03745ca2d298a9c1.jpg",
"https://telegra.ph/file/13e4a77349596c5ab8a79.jpg",
"https://telegra.ph/file/32bc65b3c0baa1eb6c284.jpg",
"https://telegra.ph/file/1c231e0675b7f6edd579a.jpg",
"https://telegra.ph/file/c564473a41ab8405dc3b9.jpg",
"https://telegra.ph/file/aa8bd2a777b01d0b24f4d.jpg",
"https://telegra.ph/file/a915d3752bac387b81adf.jpg",
"https://telegra.ph/file/59c075e64bdd0e17b659f.jpg",
"https://telegra.ph/file/f7c59f1787705d36043ca.jpg",
"https://telegra.ph/file/c20048814324dd1a1bb77.jpg",
"https://telegra.ph/file/d9153d75fc60d64026525.jpg",
"https://telegra.ph/file/3b945a8a14851ece29de7.jpg",
"https://telegra.ph/file/1c678a25b8b6482bc3cba.jpg",
"https://telegra.ph/file/cbc63680e04511756d57a.jpg",
"https://telegra.ph/file/f7c59f1787705d36043ca.jpg",
"https://telegra.ph/file/58081f8a94dbd1d1caf40.jpg",
"https://telegra.ph/file/e1539e82d5bc96bc9f15e.jpg",
"https://telegra.ph/file/36efa93ee22207c36ad2d.jpg",
"https://telegra.ph/file/6df3e879dd9c2e908859f.jpg",
"https://telegra.ph/file/cbc63680e04511756d57a.jpg",
"https://telegra.ph/file/65dc15eb996d69742fcb9.jpg",
"https://telegra.ph/file/986928ae97ba48c5f54be.jpg",
"https://telegra.ph/file/92379479bbe99f312f13f.jpg",
"https://telegra.ph/file/c46fda1ffbbaa3c406a29.jpg",
"https://telegra.ph/file/0d32e11e4a0dae13dac3d.jpg",
"https://telegra.ph/file/13a65df594224f0c46561.jpg",
"https://telegra.ph/file/17d2fd7d6e0fbfe0d74dd.jpg",
"https://telegra.ph/file/98acc5caa337ba06407b5.jpg",
"https://telegra.ph/file/102561f89b0967f27ce63.jpg",
"https://telegra.ph/file/e4f06eb175994ef6ebd41.jpg",
"https://telegra.ph/file/bf3a36c8f30e56dcbbfa5.jpg",
"https://telegra.ph/file/3a5b3ea59347b2f8fb805.jpg",
"https://telegra.ph/file/60262d7d56b4352993e88.jpg",
];

bot.command(["mem", "Ø§Ù„Ù…ÙŠÙ…Ø²"], async (ctx) => {
  try {
    const randomImg = dir[Math.floor(Math.random() * dir.length)];

    await ctx.replyWithPhoto(randomImg, {
      caption: "ğŸ˜‚ğŸ•·ï¸ Ù…ÙŠÙ… Ø¹Ø´ÙˆØ§Ø¦ÙŠ ğŸ©¸",
    });

    // ØªÙØ§Ø¹Ù„ Ø±Ù…Ø²ÙŠ (Ù…ÙÙŠØ´ react emojis ÙÙŠ Telegram API Ø²ÙŠ ÙˆØ§ØªØ³Ø§Ø¨)
    await ctx.reply("");
  } catch (e) {
    console.error(e);
    ctx.reply("Ù„Ø§");
  }
});
// Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
const tips = [
  "ØªØªÙˆÙ‚Ø¹ Ø­Ø¯ ÙŠØ³Ø£Ù„ Ø¹Ù„ÙŠÙƒ Ù„Ùˆ Ù‚ÙÙ„Øª ÙØªØ±Ø© ØŸ",
  "Ø§ÙƒØªØ± ÙƒØ°Ø¨Ø© Ù…Ø´Ù‡ÙˆØ±Ù‡ Ø¹Ù†Ø¯Ùƒ",
  "Ø­Ø§Ø¬Ø© Ù…Ø³ØªØ­ÙŠÙ„ ØªØ§ÙƒÙ„Ù‡Ø§ ",
  "Ø§ÙŠÙ‡ Ø§Ù„ÙˆØ­Ø´ Ù Ø§Ù„Ø­ÙŠØ§Ø© ØŸ",
  "Ø§Ø¹Ù„ÙŠ Ù…Ø¬Ù…ÙˆØ¹ Ø¬Ø¨ØªÙ‡ ÙØ­ÙŠØ§ØªÙƒ ØŸ",
  "Ø§ÙƒØªØ± Ø­Ø§Ø¬Ø© Ø®Ø§ÙŠÙ ØªØ®Ø³Ø±Ù‡Ø§ ØŸ",
  "Ù„Ùˆ Ù‚Ø¯Ø§Ù…Ùƒ ØªØºÙŠØ± Ø­Ø§Ø¬Ù‡ Ù Ø§Ù„Ø­ÙŠØ§Ø© Ù Ø§ÙŠÙ‡ Ù‡ÙŠ ØŸ",
  "Ø¹Ù…Ø±Ùƒ Ø¹Ù…Ù„Øª Ø®Ø¯Ù…Ø© Ù„Ø´Ø®Øµ ÙˆÙ‡Ùˆ Ø§ØªØ¨Ø±ÙŠ Ù…Ù†Ùƒ ØŸ",
  "Ø§ÙƒØªØ± Ù‡Ø¯ÙŠØ© Ù†ÙØ³Ùƒ Ø¨ÙŠÙ‡Ø§ ØŸ",
  "Ù„Ùˆ ÙƒØ³Ø¨Øª Ø®Ù…Ø³Ù‡ Ù…Ù„ÙŠÙˆÙ† Ø¯ÙˆÙ„Ø§Ø± Ù‡ØªØ¹Ù…Ù„ Ø§ÙŠÙ‡ ØŸ",
  "ØµÙ„ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¨ÙŠØ¨ ğŸ¥¹"
];

// Ø¯Ø§Ù„Ø© ØªØ¬ÙŠØ¨ Ø³Ø¤Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
function getRandomTip() {
  return tips[Math.floor(Math.random() * tips.length)];
}

// Ù„Ù…Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙƒØªØ¨ "Ø§Ø®ØªØ¨Ø±Ù†ÙŠ" Ø£Ùˆ "/Ø§Ø®ØªØ¨Ø±Ù†ÙŠ"
bot.hears(/^\/?Ø§Ø®ØªØ¨Ø±Ù†ÙŠ$/, async (ctx) => {
  const randomTip = getRandomTip();

  await ctx.replyWithPhoto(
    "https://telegra.ph/file/086ac84a0dec87b4b1561.jpg",
    {
      caption: `${randomTip}\nâŠ±â”€â•âª¨à¼»ğ“†©âš¡ğ“†ªà¼ºâª©â•â”€âŠ°`,
      parse_mode: "Markdown",
      reply_markup: {
        inline_keyboard: [
          [
            { text: "â¤¸ Ø§Ù„ØªØ§Ù„ÙŠğŸ· â¤¹", callback_data: "Ø§Ø®ØªØ¨Ø±Ù†ÙŠ" },
            { text: "âŸ¦ Ø§Ù„Ø¯Ø¹Ù…ğŸ§šâ€â™€ï¸ âŸ§", callback_data: "Ø§Ù„Ø¯Ø¹Ù…" }
          ]
        ]
      }
    }
  );
});

// Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
bot.on("callback_query", async (ctx) => {
  const query = ctx.callbackQuery.data;

  if (query === "Ø§Ø®ØªØ¨Ø±Ù†ÙŠ") {
    const randomTip = getRandomTip();
    await ctx.replyWithPhoto(
      "https://telegra.ph/file/086ac84a0dec87b4b1561.jpg",
      {
        caption: `${randomTip}\nâŠ±â”€â•âª¨à¼»ğ“†©âš¡ğ“†ªà¼ºâª©â•â”€âŠ°`,
        parse_mode: "Markdown",
        reply_markup: {
          inline_keyboard: [
            [
              { text: "â¤¸ Ø§Ù„ØªØ§Ù„ÙŠğŸ· â¤¹", callback_data: "Ø§Ø®ØªØ¨Ø±Ù†ÙŠ" },
              { text: "âŸ¦ Ø§Ù„Ø¯Ø¹Ù…ğŸ§šâ€â™€ï¸ âŸ§", callback_data: "Ø§Ù„Ø¯Ø¹Ù…" }
            ]
          ]
        }
      }
    );
  }

  if (query === "Ø§Ù„Ø¯Ø¹Ù…") {
    await ctx.reply("ğŸ§šâ€â™€ï¸ Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…ØŒ Ø±Ø§Ø³Ù„: @T_T9_A");
  }

  await ctx.answerCbQuery();
});





bot.command("group", async (ctx) => {
  try {
    if (!ctx.chat || ctx.chat.type !== "supergroup") {
      return ctx.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª!");
    }

    const groupKeyboard = [
      [
        { text: "ã€ ğŸ•·ï¸ÙØªØ­ Ø§Ù„Ø¬Ø±ÙˆØ¨ğŸ©¸ ã€", callback_data: "open_group" },
        { text: "ã€ ğŸ•·ï¸Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨ğŸ©¸ ã€", callback_data: "close_group" }
      ]
    ];

    await ctx.reply(
      "â€¹ğŸ”“â— Ø§Ø®ØªØ± Ø®ÙŠØ§Ø±Ø§Ù‹ Ù„ÙØªØ­ Ø£Ùˆ Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨ â†¬ğŸ”’âŒ¯",
      Markup.inlineKeyboard(groupKeyboard)
    );
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±");
  }
});

// Ø­Ø¯Ø« Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± ÙØªØ­
bot.action("open_group", async (ctx) => {
  try {
    await ctx.telegram.setChatPermissions(ctx.chat.id, {
      can_send_messages: true,
    });

    await ctx.editMessageText(
      "ğŸ©¸ ØªÙ… ÙØªØ­ Ø§Ù„Ø¬Ø±ÙˆØ¨ ğŸ•·ï¸ğŸ©¸",
      Markup.inlineKeyboard([
        [{ text: "â†©ï¸ Ø±Ø¬ÙˆØ¹", callback_data: "back_group" }]
      ])
    );
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙØªØ­");
  }
});

// Ø­Ø¯Ø« Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ù‚ÙÙ„
bot.action("close_group", async (ctx) => {
  try {
    await ctx.telegram.setChatPermissions(ctx.chat.id, {
      can_send_messages: false,
    });

    await ctx.editMessageText(
      "ğŸ©¸ ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨ ğŸ•·ï¸ğŸ©¸",
      Markup.inlineKeyboard([
        [{ text: "â†©ï¸ Ø±Ø¬ÙˆØ¹", callback_data: "back_group" }]
      ])
    );
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù‚ÙÙ„");
  }
});

// Ø²Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©
bot.action("back_group", async (ctx) => {
  const groupKeyboard = [
    [
      { text: "ã€ ğŸ•·ï¸ÙØªØ­ Ø§Ù„Ø¬Ø±ÙˆØ¨ğŸ©¸ ã€", callback_data: "open_group" },
      { text: "ã€ ğŸ•·ï¸Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨ğŸ©¸ ã€", callback_data: "close_group" }
    ]
  ];

  await ctx.editMessageText(
    "â€¹ğŸ”“â— Ø§Ø®ØªØ± Ø®ÙŠØ§Ø±Ø§Ù‹ Ù„ÙØªØ­ Ø£Ùˆ Ù‚ÙÙ„ Ø§Ù„Ø¬Ø±ÙˆØ¨ â†¬ğŸ”’âŒ¯",
    Markup.inlineKeyboard(groupKeyboard)
  );
});
bot.command(["bald", "botakkan"], async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;

    // Ù„Ùˆ Ù…ÙÙŠØ´ ØµÙˆØ±Ø© Ø£Ùˆ Ù…Ø´ Ø¹Ø§Ù…Ù„ Ø±ÙŠØ¨Ù„Ø§ÙŠ Ø¹Ù„Ù‰ ØµÙˆØ±Ø©
    if (!ctx.message.photo && !(reply && reply.photo)) {
      return ctx.reply(
        `ğŸ· ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø£Ù…Ø± Ø£Ùˆ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¨Ø§Ù„Ø£Ù…Ø±.\n\n` +
        `ğŸ· Ù…Ø«Ø§Ù„:\n- Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ù…Ø¹ ØªØ¹Ù„ÙŠÙ‚: /Ø§ØµÙ„Ø¹\n- Ø£Ùˆ Ø±Ø¯ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¨Ø§Ù„Ø£Ù…Ø±: /Ø§ØµÙ„Ø¹\n\n` +
        `ğŸ·`
      );
    }

    // Ø¬Ù„Ø¨ Ø§Ù„ØµÙˆØ±Ø© (Ø§Ù„Ø£Ø®ÙŠØ±Ø© = Ø£Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø©)
    const photo =
      (ctx.message.photo && ctx.message.photo.slice(-1)[0]) ||
      (reply && reply.photo && reply.photo.slice(-1)[0]);

    if (!photo) return ctx.reply("âŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©.");

    await ctx.reply("ğŸ§‘â€ğŸ¦² Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...");

    // ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
    const fileLink = await ctx.telegram.getFileLink(photo.file_id);
    const imgBuffer = (await axios.get(fileLink.href, { responseType: "arraybuffer" })).data;

    // Ø±ÙØ¹ Ø¹Ù„Ù‰ catbox
    const form = new FormData();
    form.append("reqtype", "fileupload");
    form.append("fileToUpload", imgBuffer, {
      filename: "image.jpg",
      contentType: "image/jpeg",
    });

    const catboxRes = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders(),
    });

    const imageUrl = catboxRes.data;
    if (!imageUrl.includes("catbox.moe")) throw new Error("ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Catbox.");

    // API Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
    const defaultText = "ØªÙ… Ø¬Ø¹Ù„ Ø§Ù„Ø±Ø£Ø³ Ø£ØµÙ„Ø¹";
    const apiUrl = `https://api.ubed.my.id/maker/Jadi-Apa-Aja?apikey=free1&imageUrl=${encodeURIComponent(
      imageUrl
    )}&text=${encodeURIComponent(defaultText)}`;

    const { data: resultBuffer } = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!resultBuffer || resultBuffer.byteLength < 100) {
      throw new Error("ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† API.");
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    await ctx.replyWithPhoto({ source: Buffer.from(resultBuffer) }, {
      caption: `ğŸ· Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${defaultText} ğŸ·\n\n `,
      parse_mode: "Markdown",
    });

    await ctx.reply("ğŸ©¸ ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ù†Ø¬Ø§Ø­!");

  } catch (err) {
    console.error("ğŸ· Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± Ø£ØµÙ„Ø¹:", err);
    ctx.reply("ğŸ· âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©. ğŸ§\n\n ");
  }
});


// Ø£Ù…Ø± Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„
bot.command(["my_pro"], async (ctx) => {
  try {
    const user = ctx.message.reply_to_message
      ? ctx.message.reply_to_message.from
      : ctx.from;

    // Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const username = user.username
      ? `@${user.username}`
      : user.first_name || "Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¬Ù‡ÙˆÙ„";

    // Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø«Ø§Ø¨ØªØ©
    const photoUrl = "https://files.catbox.moe/eb7wk8.jpg";

    // Ø§Ù„Ù†Øµ Ø§Ù„Ù„ÙŠ Ù‡ÙŠØªØ¨Ø¹Øª
    const caption = `
â‰ªâ”â”€â”ã€” Ø§Ù„Ø¨Ù€Ù€Ø±ÙˆÙÙ€Ù€Ø§ÙŠÙ€Ù€Ù„ ã€•â”â”€â”â‰«

â§‰ââ”‡ğŸ·âŒª  âŸ¦ Ø§Ù„Ø£Ø³Ù€Ù€Ù€Ù€Ù€Ù… âŸ§ â¤º ${username}
â§‰ââ”‡ğŸ”—âŒª  âŸ¦ Ø§Ù„Ø£ÙŠÙ€Ù€Ø¯ÙŠ âŸ§ â¤º ${user.id}
â§‰ââ”‡ğŸªâŒª  âŸ¦ Ø§Ù„Ø¨ÙˆØª âŸ§ â¤º SPAM BOT ğŸ•·ï¸ğŸ©¸

â‰ªâ”â”€â”ã€” Ø§Ù„Ø¨Ù€Ù€Ø±ÙˆÙÙ€Ù€Ø§ÙŠÙ€Ù€Ù„ ã€•â”â”€â”â‰«
    `;

    await ctx.replyWithPhoto(photoUrl, { caption, parse_mode: "Markdown" });
  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„.");
  }
});

// Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ùˆ Ø§Ù„Ù…Ø§Ù„Ùƒ

// Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª Ø§Ù„Ù„ÙŠ Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡Ø§

// ğŸŸ¢ ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø¨ÙˆØª Ø¬Ø±ÙˆØ¨
bot.on("chat_member", async (ctx) => {
  const chat = ctx.chat;
  const newStatus = ctx.update.chat_member.new_chat_member.status;
  const oldStatus = ctx.update.chat_member.old_chat_member.status;

  if (!global.groups) global.groups = [];

  // Ø¯Ø®Ù„ Ø¬Ø±ÙˆØ¨
  if (newStatus === "member" || newStatus === "administrator") {
    if (!global.groups.find((g) => g.id === chat.id)) {
      global.groups.push({ id: chat.id, title: chat.title || "Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…" });
    }
  }

  // Ø®Ø±Ø¬ Ù…Ù† Ø¬Ø±ÙˆØ¨
  if (newStatus === "left" || newStatus === "kicked") {
    global.groups = global.groups.filter((g) => g.id !== chat.id);
  }
});

// ğŸŸ¢ Ø£Ù…Ø± Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª
bot.command(["gr", "Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª"], async (ctx) => {
  try {
    if (!global.groups || global.groups.length === 0) {
      return ctx.reply("âŒ Ø§Ù„Ø¨ÙˆØª Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø£ÙŠ Ø¬Ø±ÙˆØ¨ Ø­Ø§Ù„ÙŠØ§Ù‹.");
    }

    let buttons = global.groups.map((g) => [
      Markup.button.callback(`ğŸ“› ${g.title}`, `group_${g.id}`)
    ]);

    await ctx.reply(
      `ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù„ÙŠ Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡Ø§:\nØ§Ù„Ø¹Ø¯Ø¯: ${global.groups.length}`,
      Markup.inlineKeyboard(buttons)
    );
  } catch (err) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª:", err);
    ctx.reply("âš ï¸ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª.");
  }
});

// ğŸŸ¢ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… (Ø³Ø­Ø¨ / ØªØµÙÙŠØ© / Ù…ØºØ§Ø¯Ø±Ø©)
bot.action(/group_(.+)/, async (ctx) => {
  const groupId = ctx.match[1];
  const userId = String(ctx.from.id);

  if (!OWNER_ID.includes(userId) && !DEVELOPERS.includes(userId)) {
    return ctx.reply("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·!");
  }

  await ctx.reply(
    `Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø±ÙˆØ¨ ID: ${groupId}`,
    Markup.inlineKeyboard([
      [Markup.button.callback("ğŸ›¡ï¸ Ø³Ø­Ø¨", `pull_${groupId}`)],
      [Markup.button.callback("ğŸ”¥ ØªØµÙÙŠØ©", `clean_${groupId}`)],
      [Markup.button.callback("ğŸšª Ù…ØºØ§Ø¯Ø±Ø©", `leave_${groupId}`)],
      [Markup.button.callback("â†©ï¸ Ø±Ø¬ÙˆØ¹", "back_groups")]
    ])
  );
});

// ğŸŸ¢ ØªÙ†ÙÙŠØ° Ø§Ù„Ø£ÙˆØ§Ù…Ø±
bot.action(/pull_(.+)/, async (ctx) => {
  const groupId = ctx.match[1];
  await ctx.reply(`ğŸ›¡ï¸ ØªÙ… ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© "Ø³Ø­Ø¨" ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ ${groupId} (ØªØ¬Ø±ÙŠØ¨ÙŠ).`);
});

bot.action(/clean_(.+)/, async (ctx) => {
  const groupId = ctx.match[1];
  await ctx.reply(`ğŸ”¥ ØªÙ… ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© "ØªØµÙÙŠØ©" ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨ ${groupId} (ØªØ¬Ø±ÙŠØ¨ÙŠ).`);
});

bot.action(/leave_(.+)/, async (ctx) => {
  const groupId = ctx.match[1];
  await ctx.reply(`ğŸšª Ø¬Ø§Ø±ÙŠ Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ø¬Ø±ÙˆØ¨ ${groupId} ...`);
  try {
    await ctx.telegram.leaveChat(groupId);
    global.groups = global.groups.filter((g) => g.id !== Number(groupId));
  } catch (err) {
    console.error(err);
    await ctx.reply("âš ï¸ Ù…Ù‚Ø¯Ø±ØªØ´ Ø£Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø¬Ø±ÙˆØ¨.");
  }
});

// ğŸŸ¢ Ø²Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©
bot.action("back_groups", async (ctx) => {
  if (!global.groups || global.groups.length === 0) {
    return ctx.editMessageText("âŒ Ø§Ù„Ø¨ÙˆØª Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø£ÙŠ Ø¬Ø±ÙˆØ¨ Ø­Ø§Ù„ÙŠØ§Ù‹.");
  }

  let buttons = global.groups.map((g) => [
    Markup.button.callback(`ğŸ“› ${g.title}`, `group_${g.id}`)
  ]);

  await ctx.editMessageText(
    `ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù„ÙŠ Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡Ø§:\nØ§Ù„Ø¹Ø¯Ø¯: ${global.groups.length}`,
    Markup.inlineKeyboard(buttons)
  );
});

// ÙØ±Ø¶Ù‹Ø§ Ø£Ù†Ùƒ ØªØ³ØªØ®Ø¯Ù… Telegraf Ø£Ùˆ Ø´ÙŠØ¡ Ù…Ø´Ø§Ø¨Ù‡
const developerId = ['7708820857','7819888120']; // Ø§Ø³ØªØ¨Ø¯Ù„ Ø¨Ø§Ù„Ù€ user_id Ø§Ù„Ø®Ø§Øµ Ø¨ÙŠÙƒ


bot.command(["kick", "Ø§Ù†Ø·Ø±"], async (ctx) => {
  const chatId = ctx.chat.id;

  // Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type === "private") {
    return ctx.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª.");
  }

  // ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„ÙŠ ÙƒØ§ØªØ¨ Ø§Ù„Ø£Ù…Ø±
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["creator", "administrator"].includes(member.status)) {
    return ctx.reply(
      "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\n" +
      "â”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ø§Ø¯Ù…Ù† ÙÙ‚Ø·\n" +
      "â”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†Øª Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ\n" +
      "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£"
    );
  }

  // ğŸŸ¢ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù‡Ø¯Ù (Ù…Ù† Ø±ÙŠØ¨Ù„Ø§ÙŠ Ø£Ùˆ Ù…Ù†Ø´Ù† Ø£Ùˆ ID Ù…Ø¨Ø§Ø´Ø±)
  let targetUser = null;

  // Ù„Ùˆ ÙÙŠÙ‡ Ø±ÙŠØ¨Ù„Ø§ÙŠ
  if (ctx.message.reply_to_message) {
    targetUser = ctx.message.reply_to_message.from;
  }

  // Ù„Ùˆ ÙÙŠÙ‡ Ù…Ù†Ø´Ù†
  if (!targetUser && ctx.message.entities) {
    const mentionEntity = ctx.message.entities.find(e => e.type === "mention");
    if (mentionEntity) {
      const username = ctx.message.text.slice(
        mentionEntity.offset,
        mentionEntity.offset + mentionEntity.length
      ).replace("@", "");

      try {
        const userInfo = await ctx.telegram.getChatMember(chatId, username);
        targetUser = userInfo.user;
      } catch (err) {
        console.error("âŒ ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù†Ø´Ù†:", err);
      }
    }
  }

  // Ù„Ùˆ ÙƒØªØ¨ ID Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±
  const args = ctx.message.text.split(" ").slice(1);
  if (!targetUser && args[0]) {
    try {
      const userInfo = await ctx.telegram.getChatMember(chatId, args[0]);
      targetUser = userInfo.user;
    } catch (err) {
      console.error("âŒ ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø¨Ø± ID:", err);
    }
  }

  if (!targetUser) {
    return ctx.reply("ğŸ©¸ Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø£Ùˆ Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„ØªÙ‡ Ø£Ùˆ Ø§ÙƒØªØ¨ ID Ø¹Ø´Ø§Ù† Ø£Ø·Ø±Ø¯Ù‡.");
  }

  // Ù…Ù†Ø¹ Ø·Ø±Ø¯ Ø§Ù„Ù…Ø·ÙˆØ±
  if (OWNER_ID.includes(String(targetUser.id))) {
    return ctx.reply("ğŸ™… Ù…Ø´ Ù‡Ø·Ø±Ø¯ Ø§Ù„Ù…Ø·ÙˆØ±!");
  }

  // Ù…Ù†Ø¹ Ø·Ø±Ø¯ Ø§Ù„Ø¨ÙˆØª Ù†ÙØ³Ù‡
  if (targetUser.id === (await ctx.telegram.getMe()).id) {
    return ctx.reply("ğŸ˜‚ Ù…Ø´ Ù‡Ø·Ø±Ø¯ Ù†ÙØ³ÙŠ!");
  }

  // ØªÙ†ÙÙŠØ° Ø§Ù„Ø·Ø±Ø¯
  try {
    await ctx.kickChatMember(targetUser.id);
    ctx.reply(
      `ââ”â”â”â•â•â”â”âªğŸ¥·â«â”â”â•â•â”â”â”â\n` +
      `ï½¢ğŸ·ï½£â‡‡ ØªÙ… Ø·Ø±Ø¯Ùƒ Ø¨Ù†Ø¬Ø§Ø­\n` +
      `ï½¢ğŸ·ï½£â‡‡ Ø¨Ø£Ù…Ø± Ù…Ù† â†œ @${ctx.from.username || ctx.from.id}\n` +
      `ââ”â”â”â•â•â”â”âªğŸ”¥â«â”â”â•â•â”â”â”â`,
      { parse_mode: "Markdown" }
    );
  } catch (e) {
    console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø·Ø±Ø¯:", e);
    ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ø·Ø±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ø¹Ù†Ø¯Ù‡ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø£Ø¯Ù…Ù†.");
  }
});

bot.command(["mute", "unmute"], async (ctx) => {
  const chatId = ctx.chat.id;

  // âœ… Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type === "private") {
    return ctx.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª.");
  }

  // âœ… ØªØ­Ù‚Ù‚ Ø£Ù† Ø§Ù„Ù„ÙŠ ÙƒØ§ØªØ¨ Ø§Ù„Ø£Ù…Ø± Ø£Ø¯Ù…Ù†
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["creator", "administrator"].includes(member.status)) {
    return ctx.reply(
      "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\n" +
      "â”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ø§Ø¯Ù…Ù† ÙÙ‚Ø· \n" +
      "â”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†Øª Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \n" +
      "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£"
    );
  }

  // ğŸŸ¢ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù‡Ø¯Ù (reply Ø£Ùˆ mention Ø£Ùˆ ID)
  let targetUser = null;

  if (ctx.message.reply_to_message) {
    targetUser = ctx.message.reply_to_message.from;
  }

  // Ù„Ùˆ ÙÙŠÙ‡ mention
  if (!targetUser && ctx.message.entities) {
    const mentionEntity = ctx.message.entities.find(e => e.type === "mention");
    if (mentionEntity) {
      const username = ctx.message.text.slice(
        mentionEntity.offset,
        mentionEntity.offset + mentionEntity.length
      ).replace("@", "");
      try {
        const userInfo = await ctx.telegram.getChatMember(chatId, username);
        targetUser = userInfo.user;
      } catch (err) {
        console.error("âŒ ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù†Ø´Ù†:", err);
      }
    }
  }

  // Ù„Ùˆ ÙƒØªØ¨ ID Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±
  const args = ctx.message.text.split(" ").slice(1);
  if (!targetUser && args[0]) {
    try {
      const userInfo = await ctx.telegram.getChatMember(chatId, args[0]);
      targetUser = userInfo.user;
    } catch (err) {
      console.error("âŒ ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø¨Ø± ID:", err);
    }
  }

  if (!targetUser) {
    return ctx.reply("âŒ Ù…Ù†Ø´Ù† Ø£Ùˆ Ø±Ø¯ Ø£Ùˆ Ø§ÙƒØªØ¨ ID Ø¹Ø´Ø§Ù† Ø£ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø¹Ø¶Ùˆ.");
  }

  // ğŸš« Ù…Ù†Ø¹ ÙƒØªÙ… Ø§Ù„Ø¨ÙˆØª Ù†ÙØ³Ù‡ Ø£Ùˆ Ø§Ù„Ù…Ø·ÙˆØ±
  if (OWNER_ID.includes(String(targetUser.id))) {
    return ctx.reply("ğŸ™… Ù…Ø´ Ù‡ÙƒØªÙ… Ø§Ù„Ù…Ø·ÙˆØ±!");
  }
  if (targetUser.id === (await ctx.telegram.getMe()).id) {
    return ctx.reply("ğŸ˜‚ Ù…Ø´ Ù‡ÙƒØªÙ… Ù†ÙØ³ÙŠ!");
  }

  try {
    if (ctx.message.text.startsWith("/mute")) {
      // ÙƒØªÙ…
      await ctx.restrictChatMember(targetUser.id, {
        permissions: { can_send_messages: false }
      });

      ctx.reply(
        `ğŸ”‡ ØªÙ… ÙƒØªÙ… Ø§Ù„Ø¹Ø¶Ùˆ [${targetUser.first_name}](tg://user?id=${targetUser.id})`,
        { parse_mode: "Markdown" }
      );
    } else if (ctx.message.text.startsWith("/unmute")) {
      // ÙÙƒ Ø§Ù„ÙƒØªÙ…
      await ctx.restrictChatMember(targetUser.id, {
        permissions: { can_send_messages: true }
      });

      ctx.reply(
        `ğŸ”Š ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒØªÙ… Ø¹Ù† [${targetUser.first_name}](tg://user?id=${targetUser.id})`,
        { parse_mode: "Markdown" }
      );
    }
  } catch (err) {
    console.error("âŒ Ø®Ø·Ø£ ÙÙŠ mute/unmute:", err);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ØŒ ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ø¹Ù†Ø¯Ù‡ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ù…Ù†.");
  }
});


// Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª


// Ù…Ø§Ø¨ Ù„ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±ÙŠØ¨Ùˆ Ù…Ø¤Ù‚ØªØ§Ù‹
const repoCache = new Map();

bot.command("git", async (ctx) => {
  try {
    const text = ctx.message.text.split(" ").slice(1).join(" ");
    if (!text) {
      return ctx.reply(
        `âŒ ÙŠØ±Ø¬ÙŠ Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ø³Ù… Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ù„Ø¨Ø­Ø«.\nÙ…Ø«Ø§Ù„:\n/git TheMystic-Bot-MD`
      );
    }

    const res = await fetch(`https://api.github.com/search/repositories?q=${encodeURIComponent(text)}`);
    if (!res.ok) throw new Error(`HTTP error! Status: ${res.status}`);

    const json = await res.json();
    if (!json.items || json.items.length === 0) {
      return ctx.reply("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù….");
    }

    const repos = json.items.slice(0, 10); // Ø£ÙˆÙ„ 10 ÙÙ‚Ø·

    let buttons = repos.map((repo, index) => {
      const cacheId = `${ctx.from.id}_${Date.now()}_${index}`;
      repoCache.set(cacheId, {
        user: repo.owner.login,
        repo: repo.name
      });

      return [Markup.button.callback(`ğŸ“‚ ${repo.full_name}`, `download_${cacheId}`)];
    });

    await ctx.reply(
      `ğŸ” Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: ${text}\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„ØªØ­Ù…ÙŠÙ„ ğŸ‘‡`,
      {
        parse_mode: "Markdown",
        ...Markup.inlineKeyboard(buttons)
      }
    );
  } catch (error) {
    console.error(error);
    ctx.reply(`âš ï¸ Ø®Ø·Ø£: ${error.message}`);
  }
});

// Ù‡Ø§Ù†Ø¯Ù„Ø± Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ÙƒÙ€ ZIP
bot.action(/download_(.+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();

    const cacheId = ctx.match[1];
    const repoData = repoCache.get(cacheId);

    if (!repoData) {
      return ctx.reply("âš ï¸ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±ØŒ Ø§Ø¨Ø­Ø« Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
    }

    const { user, repo } = repoData;
    const url = `https://api.github.com/repos/${user}/${repo}/zipball`;

    await ctx.reply(`â¬‡ï¸ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹: *${repo}*`, { parse_mode: "Markdown" });

    await ctx.replyWithDocument({
      url,
      filename: `${repo}.zip`
    });
  } catch (error) {
    console.error(error);
    ctx.reply(`âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„: ${error.message}`);
  }
});

bot.command(["admin", "ØªØ±Ù‚ÙŠÙ‡", "Ø±ÙØ¹", "Ø§Ø±ÙØ¹Ùˆ", "Ø±ÙˆÙ„"], async (ctx) => {
  const chatId = ctx.chat.id;

  // Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type === "private") {
    return ctx.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª.");
  }

  // ØªØ­Ù‚Ù‚ Ø£Ù† Ø§Ù„Ù„ÙŠ ÙƒØ§ØªØ¨ Ø§Ù„Ø£Ù…Ø± Ø£Ø¯Ù…Ù†
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["creator", "administrator"].includes(member.status)) {
    return ctx.reply("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\nâ”‡ğŸ”¥â”‡ â†¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù† Ø¨Ø³ \nââŠ¹â”â”â”â”â”ã€ğ™ğ™‹ğ˜¼ğ™ˆã€â”â”â”â”â”âŠ¹â\nâ”‡ğŸ•·ï¸â”‡ â†¯ Ø§Ù†ØªØ§ Ù…Ø¬Ø±Ø¯ Ø¹Ø¶Ùˆ \nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£");
  }

  // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªØ±Ù‚ÙŠØªÙ‡ (Ù…Ù† reply Ø£Ùˆ mention)
  let target = null;

  if (ctx.message.reply_to_message) {
    target = ctx.message.reply_to_message.from;
  } else if (ctx.message.entities) {
    const mention = ctx.message.entities.find((e) => e.type === "mention");
    if (mention) {
      const username = ctx.message.text.slice(mention.offset + 1, mention.offset + mention.length);
      try {
        const user = await ctx.telegram.getChatMember(chatId, username);
        target = user.user;
      } catch (e) {
        console.error(e);
      }
    }
  }

  if (!target) {
    return ctx.reply("ğŸ©¸ Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø£Ùˆ Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„ØªÙ‡ Ø¹Ø´Ø§Ù† Ø£Ø±ÙØ¹Ù‡ Ø£Ø¯Ù…Ù†.");
  }

  // Ù…Ù†Ø¹ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¨ÙˆØª Ù†ÙØ³Ù‡
  if (target.id === (await ctx.telegram.getMe()).id) {
    return ctx.reply("ğŸ˜‚ Ø§Ù„Ø¨ÙˆØª Ù…Ø´ Ù…Ù…ÙƒÙ† ÙŠØ±Ù‚ÙŠ Ù†ÙØ³Ù‡!");
  }

  try {
    await ctx.telegram.promoteChatMember(chatId, target.id, {
      can_manage_chat: true,
      can_delete_messages: true,
      can_manage_video_chats: true,
      can_restrict_members: true,
      can_promote_members: false,
      can_invite_users: true,
      can_pin_messages: true,
    });

    ctx.reply(
      `â€¹âŒ—â€º ØªÙ€Ù… ØªÙ€Ø±Ù‚Ù€ÙŠÙ€Ø© â†œ @${target.username || target.id} Ù„Ù€ Ù…Ø´Ø±Ù Ø¨Ù†Ø¬Ø§Ø­ â€¹âŒ—â€º`,
      { parse_mode: "Markdown" }
    );
  } catch (e) {
    console.error(e);
    ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ±Ù‚ÙŠØ©ØŒ ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ø¹Ù†Ø¯Ù‡ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ù…Ù†.");
  }
});
const hina = [
  "2023","2024","2025","2026","2027","2028","2029","2030","2031","2032","2033","2034","2035","2036","2037","2038","2039","2040","2041","2042","2043","2044","2045","2046","2047","2048","2049","2050","2051","2052","2053","2054","2055","2056","2057","2058","2059","2060","2061","2062","2063","2064","2065","2066","2067","2068","2069","2070","2071","2072","2073","2074","2075","2076","2077","2078","2079","2080","2081","2082","2083","2084","2085","2089","2090","2091","2092","2093","2094","2095","2096","2097","2098","2099","2100","2101","2102","2103","2104","2105","2106","2107","2108","2109","2110","2111","2112","2113","2114","2115","2116","2117","2118","2119","2120","2121","2122","2123","2124","2125","2126","2127","2128","2129","2130"
];

const hinax = [
  "Ù…Ù„Ø§Ø±ÙŠØ§","Ø§Ù†ØªØ­Ø§Ø±","Ø§Ù„Ø³Ù„ Ø±Ø¦ÙˆÙŠ","Ù…Ø±Ø¶ Ø§Ù„Ø³ÙƒØ±ÙŠ","Ø­Ø§Ø¯Ø« Ù…Ø±ÙˆØ±","Ø³Ø±Ø·Ø§Ù† Ø§Ù„ÙƒØ¨Ø¯","Ø³Ø±Ø·Ø§Ù† Ø§Ù„Ø¯Ù…","Ø§Ù„Ø³Ù‚ÙˆØ· Ù…Ù† Ù…Ø±ØªÙØ¹","ØªØ¹ÙÙ† Ø§Ù„Ø¬Ù„Ø¯","Ø§Ø­ØªØ±Ø§Ù‚","ØªÙ„ÙŠÙ Ø§Ù„ÙƒØ¨Ø¯","Ø§Ù„ØºØ±Ù‚","Ø§Ù„Ø£Ù†ØªØ­Ø§Ø±","Ø§Ù„Ù‚ØªÙ„","Ø¬Ø±ÙŠÙ…Ø© Ù‚ØªÙ„","ÙƒÙˆØ±ÙˆÙ†Ø§","ÙƒÙˆÙÙŠØ¯","Ø§Ù†Ø³Ø¯Ø§Ø¯ Ø±Ø¦ÙˆÙŠ Ù…Ø²Ù…Ù†","Ø§ÙŠØ¯Ø²","Ø®Ø·Ø£ Ø·Ø¨ÙŠ","Ø§Ù„ÙˆÙ‚ÙˆØ¹ Ù…Ù† Ø§Ù„Ø¬Ø¨Ù„","Ø±ØµØ§ØµØ© Ø·Ø§Ø¦Ø´Ø©","Ø§Ù„ØªØ¹Ø±Ø¶ Ù„ØºØ§Ø²Ø§Øª Ø³Ø§Ù…Ø©","Ø³Ø±Ø·Ø§Ù† Ø§Ù„Ø±Ø¦Ø©","Ø§Ù„Ø¬ÙˆØ¹","Ø§Ù„ØºØ±Ù‚","Ø§Ù„Ø§Ø­ØªØ±Ø§Ù‚","Ø§Ù„Ù…ÙˆØª Ø§Ù„Ù…ÙØ§Ø¬Ø¦","Ø§Ø®ØªÙ†Ø§Ù‚","Ø§Ù†ÙØ¬Ø§Ø± Ø³ÙŠØ§Ø±Ø©","Ø§Ù„ØªØ¹Ø±Ø¶ Ù„Ù„Ø£Ø´Ø¹Ø§Ø¹Ø§Øª","Ø²Ù„Ø²Ø§Ù„","Ø§Ø¨ØªÙ„Ø§Ø¹ Ø§Ù„Ø²Ø±Ù†ÙŠØ®"
];

const hinaxx = ["1","2","3","4","5","6","7","8","9","10","11","12"];

// Ø¯Ø§Ù„Ø© Ø§Ø®ØªÙŠØ§Ø± Ø¹Ø´ÙˆØ§Ø¦
// Ø§Ù„Ø£Ù…Ø±
bot.command("die", async (ctx) => {
  const cause = pickRandom(hinax);
  const year = pickRandom(hina);
  const month = pickRandom(hinaxx);
  const day = Math.floor(Math.random() * 30) + 1;

  const message = `
âŒ¬ â›â• Ø³Ø¨Ø¨ Ø§Ù„ÙˆÙØ§Ù‡: ${cause}

âŒ¬ â›â• ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆÙØ§Ø©: ${day}/${month}/${year}



> âš ï¸ ØªÙ†ÙˆÙŠÙ‡: Ø§Ù„Ù„Ø¹Ø¨Ù‡ Ù„Ù„Ù…Ø²Ø­ ÙÙ‚Ø· Ù„Ø§ ØªØ£Ø®Ø°Ù‡Ø§ Ø¨Ø¬Ø¯ÙŠÙ‡.
  `;

  await ctx.reply(message, { parse_mode: "Markdown" });
});
// Ø¯Ø§Ù„Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ø§ÙŠØª Ù„Ø­Ø¬Ù… Ù…Ù‚Ø±ÙˆØ¡
let games = {};

// ğŸŸ¢ Ø£Ù…Ø± Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
bot.command("xo", async (ctx) => {
  const chatId = ctx.chat.id;
  const sender = ctx.from.id;

  if (games[chatId]) {
    return ctx.reply("âš  Ù‡Ù†Ø§Ùƒ Ù„Ø¹Ø¨Ø© Ø¬Ø§Ø±ÙŠØ© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©!");
  }

  games[chatId] = {
    player1: sender,
    player2: null,
    board: ["1ï¸âƒ£","2ï¸âƒ£","3ï¸âƒ£","4ï¸âƒ£","5ï¸âƒ£","6ï¸âƒ£","7ï¸âƒ£","8ï¸âƒ£","9ï¸âƒ£"],
    turn: null,
    started: false,
  };

  return ctx.reply(
    `ğŸ® ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø¹Ø¨Ø© Ø¥ÙƒØ³ Ø£Ùˆ Ø¨ÙˆØ§Ø³Ø·Ø© [${ctx.from.first_name}](tg://user?id=${sender})!
 Ø§ÙƒØªØ¨ /x_o Ù„Ù„Ø¯Ø®ÙˆÙ„ ÙƒÙ…Ù†Ø§ÙØ³.
 Ø£Ùˆ /x_del Ù„Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù‚Ø¨Ù„ Ø¨Ø¯Ø§ÙŠØªÙ‡Ø§.`,
    { parse_mode: "Markdown" }
  );
});

// ğŸŸ¢ Ø£Ù…Ø± Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…
bot.command("x_o", async (ctx) => {
  const chatId = ctx.chat.id;
  const sender = ctx.from.id;
  const game = games[chatId];

  if (!game) return ctx.reply("âš  Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¹Ø¨Ø© Ù…ÙØ¹Ù„Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.\nØ§ÙƒØªØ¨ /xo Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ø­Ø¯Ø©.");
  if (game.started) return ctx.reply("ğŸ©¸ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø¯Ø£Øª Ø¨Ø§Ù„ÙØ¹Ù„!");
  if (sender === game.player1) return ctx.reply("âš  Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù†ÙØ³Ùƒ!");
  if (game.player2) return ctx.reply("âš  ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¨Ø§Ù„ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ù„Ø§Ø¹Ø¨ Ø¢Ø®Ø±.");

  game.player2 = sender;
  game.turn = game.player1;
  game.started = true;

  const boardText = formatBoard(game.board);

  return ctx.reply(
    `ğŸ® ØªÙ… Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠ Ø¨ÙŠÙ†:

âŒ [${ctx.from.first_name}](tg://user?id=${game.player1})
â­• [${ctx.from.first_name}](tg://user?id=${game.player2})

âœ¨ Ø¯ÙˆØ±: [Ø§Ù„Ù„Ø§Ø¹Ø¨](tg://user?id=${game.turn})

${boardText}
ğŸ”¢ Ø§Ø®ØªØ± Ø±Ù‚Ù…Ù‹Ø§ Ù…Ù† (1-9) Ù„Ù„Ø¹Ø¨!`,
    { parse_mode: "Markdown" }
  );
});

// ğŸŸ¢ Ø£Ù…Ø± Ø§Ù„Ø­Ø°Ù
bot.command("x_del", (ctx) => {
  const chatId = ctx.chat.id;
  const sender = ctx.from.id;
  const game = games[chatId];

  if (!game) return ctx.reply("âš  Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¹Ø¨Ø© Ù„Ø­Ø°ÙÙ‡Ø§.");
  if (sender !== game.player1) return ctx.reply("âš  ÙÙ‚Ø· Ù…Ù†Ø´Ø¦ Ø§Ù„Ù„Ø¹Ø¨Ø© ÙŠÙ…ÙƒÙ†Ù‡ Ø­Ø°ÙÙ‡Ø§.");

  delete games[chatId];
  return ctx.reply("ğŸ©¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­.");
});

// ğŸŸ¢ Ø§Ù„Ù„Ø¹Ø¨ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… (1-9)
bot.hears(/^[1-9]$/, (ctx) => {
  const chatId = ctx.chat.id;
  const sender = ctx.from.id;
  const move = ctx.message.text;

  const game = games[chatId];
  if (!game || !game.started) return;

  if (![game.player1, game.player2].includes(sender))
    return ctx.reply("âŒ Ø£Ù†Øª Ù„Ø³Øª Ù…Ø´Ø§Ø±ÙƒÙ‹Ø§ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù„Ø¹Ø¨Ø©!");

  if (sender !== game.turn)
    return ctx.reply("ğŸ©¸ Ù„ÙŠØ³ Ø¯ÙˆØ±Ùƒ!");

  const index = parseInt(move) - 1;
  if (["âŒ", "â­•"].includes(game.board[index]))
    return ctx.reply("âš  Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§Ù†Ø© Ù…Ø´ØºÙˆÙ„Ø©.");

  game.board[index] = sender === game.player1 ? "âŒ" : "â­•";
  game.turn = sender === game.player1 ? game.player2 : game.player1;

  const boardText = formatBoard(game.board);
  const winner = checkWinner(game.board);

  if (winner) {
    const winnerId = winner === "âŒ" ? game.player1 : game.player2;
    delete games[chatId];
    return ctx.reply(
      `ğŸ‰ Ø§Ù„ÙØ§Ø¦Ø²: [Ø§Ù„Ù„Ø§Ø¹Ø¨](tg://user?id=${winnerId})\n\n${boardText}`,
      { parse_mode: "Markdown" }
    );
  }

  if (!game.board.some((cell) => /[1-9]/.test(cell))) {
    delete games[chatId];
    return ctx.reply(`ğŸ¤ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„ØªØ¹Ø§Ø¯Ù„!\n\n${boardText}`, {
      parse_mode: "Markdown",
    });
  }

  return ctx.reply(
    `âœ¨ Ø¯ÙˆØ±: [Ø§Ù„Ù„Ø§Ø¹Ø¨](tg://user?id=${game.turn})\n\n${boardText}`,
    { parse_mode: "Markdown" }
  );
});

// ğŸŸ¢ Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
function formatBoard(board) {
  return `
${board[0]} | ${board[1]} | ${board[2]}
â”€â”€â”€â”€â”€â”€â”€â”€â”€
${board[3]} | ${board[4]} | ${board[5]}
â”€â”€â”€â”€â”€â”€â”€â”€â”€
${board[6]} | ${board[7]} | ${board[8]}`;
}

function checkWinner(board) {
  const winPatterns = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6],
  ];
  for (const [a,b,c] of winPatterns) {
    if (board[a] === board[b] && board[b] === board[c]) return board[a];
  }
  return null;
}
// ğŸ› ï¸ Ø¯Ø§Ù„Ø© ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ø§ÙŠØª Ù„Ø­Ø¬Ù… Ù…Ù‚Ø±ÙˆØ¡
function formatBytes(bytes) {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

// Ø£Ù…Ø± ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ mp4
bot.command("vid", async (ctx) => {
  const query = ctx.message.text.replace("/vid", "").trim();

  if (!query) {
    return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø±Ø§Ø¨Ø· ÙŠÙˆØªÙŠÙˆØ¨ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/vid https://youtu.be/xyz");
  }

  try {
    const apiUrl = `https://api.zenkey.my.id/api/download/ytmp4?apikey=zenkey&url=${encodeURIComponent(query)}`;
    const response = await fetch(apiUrl);
    const result = await response.json();

    if (result.status && result.result?.download_url) {
      // Ø­Ø¬Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù€ API)
      const size = result.result.size ? formatBytes(result.result.size) : "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";

      await ctx.replyWithVideo(
        { url: result.result.download_url },
        { caption: `ğŸ¥ ${result.result.title}\nğŸ“¦ Ø§Ù„Ø­Ø¬Ù…: ${size}` }
      );
    } else {
      ctx.reply("âŒ ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ùˆ Ø¬Ø±Ø¨ Ù…Ø±Ø© ØªØ§Ù†ÙŠØ©.");
    }
  } catch (error) {
    console.error(error);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ API.");
  }
});
// âœ¨ Ø¯Ø§Ù„Ø© Ù„Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¹Ù„Ù‰ catbox
bot.command(["facebook", "fb"], async (ctx) => {
  const query = ctx.message.text.split(" ").slice(1).join(" ");
  if (!query) {
    return ctx.reply(
      "âŒ— Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ÙÙŠØ³Ø¨ÙˆÙƒ ğŸ“º\n\nÙ…Ø«Ø§Ù„:\n/facebook https://fb.watch/xxxx"
    );
  }

  await ctx.reply("ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ù† ÙÙŠØ³Ø¨ÙˆÙƒ ..");

  try {
    const getFBInfo = (videoUrl) => {
      const headers = {
        "sec-fetch-user": "?1",
        "sec-ch-ua-mobile": "?0",
        "sec-fetch-site": "none",
        "sec-fetch-dest": "document",
        "sec-fetch-mode": "navigate",
        "cache-control": "max-age=0",
        authority: "www.facebook.com",
        "upgrade-insecure-requests": "1",
        "accept-language":
          "en-GB,en;q=0.9,tr-TR;q=0.8,tr;q=0.7,en-US;q=0.6",
        "sec-ch-ua":
          '"Google Chrome";v="89", "Chromium";v="89", ";Not A Brand";v="99"',
        "user-agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36",
        accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
      };

      const parseString = (string) =>
        JSON.parse(`{"text": "${string}"}`).text;

      return new Promise((resolve, reject) => {
        if (!videoUrl || !videoUrl.trim()) {
          return reject("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· ØµØ­ÙŠØ­");
        }
        if (
          ["facebook.com", "fb.watch"].every(
            (domain) => !videoUrl.includes(domain)
          )
        ) {
          return reject("âŒ Ø§Ù„Ø±Ø§Ø¨Ø· Ù„ÙŠØ³ Ù…Ù† ÙÙŠØ³Ø¨ÙˆÙƒ");
        }

        axios
          .get(videoUrl, { headers })
          .then(({ data }) => {
            data = data
              .replace(/&quot;/g, '"')
              .replace(/&amp;/g, "&");

            const sdMatch =
              data.match(/"browser_native_sd_url":"(.*?)"/) ||
              data.match(/"playable_url":"(.*?)"/) ||
              data.match(/sd_src\s*:\s*"([^"]*)"/) ||
              data.match(/(?<="src":")[^"]*(https:\/\/[^"]*)/);

            const hdMatch =
              data.match(/"browser_native_hd_url":"(.*?)"/) ||
              data.match(/"playable_url_quality_hd":"(.*?)"/) ||
              data.match(/hd_src\s*:\s*"([^"]*)"/);

            const titleMatch = data.match(
              /<meta\sname="description"\scontent="(.*?)"/
            );
            const thumbMatch = data.match(
              /"preferred_thumbnail":{"image":{"uri":"(.*?)"/
            );

            if (sdMatch && sdMatch[1]) {
              const result = {
                url: videoUrl,
                sd: parseString(sdMatch[1]),
                hd:
                  hdMatch && hdMatch[1]
                    ? parseString(hdMatch[1])
                    : "",
                title:
                  titleMatch && titleMatch[1]
                    ? parseString(titleMatch[1])
                    : data.match(/<title>(.*?)<\/title>/)?.[1] ??
                      "",
                thumbnail:
                  thumbMatch && thumbMatch[1]
                    ? parseString(thumbMatch[1])
                    : "",
              };
              resolve(result);
            } else {
              reject(
                "ğŸ©¸ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙÙŠØ¯ÙŠÙˆØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
              );
            }
          })
          .catch(() =>
            reject("ğŸ©¸ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙÙŠØ¯ÙŠÙˆØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
          );
      });
    };

    const hasilny = await getFBInfo(query);
    let vd = `ğŸ¬ ${hasilny.title}`;

    await ctx.replyWithVideo(
      { url: hasilny.hd || hasilny.sd },
      { caption: vd }
    );
  } catch (e) {
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ù† ÙÙŠØ³Ø¨ÙˆÙƒ");
  }
});


// Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¤Ù‚ØªØ© (Ù…Ù…ÙƒÙ† ØªØ­ÙØ¸Ù‡Ø§ ÙÙŠ JSON Ø£Ùˆ DB)
let warnings = {}; // { chatId: { userId: count } }

bot.command(["warn", "ØªØ­Ø°ÙŠØ±", "Ø§Ù†Ø°Ø§Ø±"], async (ctx) => {
  const chatId = ctx.chat.id;

  if (ctx.chat.type === "private") {
    return ctx.reply("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª.");
  }

  // ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ù…Ù†
  const member = await ctx.telegram.getChatMember(chatId, ctx.from.id);
  if (!["creator", "administrator"].includes(member.status)) {
    return ctx.reply("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ ÙÙ‚Ø· Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†.");
  }

  // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‡Ø¯Ù
  let targetId, targetName;
  if (ctx.message.reply_to_message) {
    targetId = ctx.message.reply_to_message.from.id;
    targetName = ctx.message.reply_to_message.from.first_name;
  } else {
    return ctx.reply("â— Ù‚Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ­Ø°ÙŠØ±Ù‡.");
  }

  // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ­Ø°ÙŠØ±
  if (!warnings[chatId]) warnings[chatId] = {};
  if (!warnings[chatId][targetId]) warnings[chatId][targetId] = 0;

  warnings[chatId][targetId]++;
  const count = warnings[chatId][targetId];

  await ctx.reply(
    `â”â”… â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”… â”â”“
â”ƒâ•»âš ï¸â•¹â†µ Ù­ ØªÙ… ØªØ­Ø°ÙŠØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù­ â†¯
â”£ â”… â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”… â”âŠ¹â
â”ƒâ•»ğŸ‘¤â•¹â†µ Ù­ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… â†¯
â”ƒâ•»ğŸ“§â•¹â†µ Ù­ã€™${targetName}ã€˜
â”ƒâ•»â—â•¹â†µ Ù­ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª:ã€™ ${count}/3 ã€˜
â”—â”… â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”… â”`,
    { parse_mode: "Markdown" }
  );

  // Ù„Ùˆ ÙˆØµÙ„ 3
  if (count >= 3) {
    warnings[chatId][targetId] = 0;
    await ctx.reply(
      `ââ”â”â”â•â•â”â”âªğŸ©¸â«â”â”â•â•â”â”â”â
ã€ŒğŸ‘»ã€â‡‡ ã€Ø­Ø°Ø±ØªÙƒ Ø«Ù„Ø§Ø« Ù…Ø±Ø§Øª!!ã€ â‡‡ã€ŒğŸ•·ï¸ã€
ã€ŒğŸã€â‡‡ ã€${targetName}ã€ Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª 3 ØªØ­Ø°ÙŠØ±Ø§Øª.
ã€ŒğŸŒŸã€â‡‡ ã€Ø³ÙŠØªÙ… Ø·Ø±Ø¯Ùƒ Ø§Ù„Ø¢Ù†!ã€ ğŸ‘½
ââ”â”â”â•â•â”â”âªğŸ©¸â«â”â”â•â•â”â”â”â`,
      { parse_mode: "Markdown" }
    );

    try {
      await ctx.kickChatMember(targetId);
    } catch (err) {
      console.error(err);
      ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© Ø·Ø±Ø¯ Ø§Ù„Ø¹Ø¶Ùˆ (ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ø£Ø¯Ù…Ù†).");
    }
  }
});

// ===== Suno API Class =====
class SunoAPI {
  constructor() {
    this.baseURL = "https://suno.exomlapi.com";
    this.headers = {
      accept: "*/*",
      "content-type": "application/json",
      origin: "https://suno.exomlapi.com",
      referer: "https://suno.exomlapi.com/",
      "user-agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
    };
    this.interval = 3000; // 3 Ø«ÙˆØ§Ù†ÙŠ
    this.timeout = 300000; // 5 Ø¯Ù‚Ø§Ø¦Ù‚
  }

  async generate({ prompt }) {
    let taskId, token;
    try {
      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨ Ù„Ù„ØªÙˆÙ„ÙŠØ¯
      const generateResponse = await axios.post(
        `${this.baseURL}/generate`,
        { prompt },
        { headers: this.headers }
      );

      ({ taskId, token } = generateResponse.data);

      // Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø­Ø§Ù„Ø©
      const startTime = Date.now();
      while (Date.now() - startTime < this.timeout) {
        await new Promise((resolve) => setTimeout(resolve, this.interval));

        const statusResponse = await axios.post(
          `${this.baseURL}/check-status`,
          { taskId, token },
          { headers: this.headers }
        );

        if (
          statusResponse.data.results?.every(
            (res) => res.audio_url && res.image_url && res.lyrics
          )
        ) {
          return statusResponse.data;
        }
      }
      return { status: "timeout" };
    } catch (error) {
      return {
        status: "error",
        error: error.response?.data || error.message,
      };
    }
  }
}

// ===== Ø¨ÙˆØª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… =====

bot.command(["suno", "Ø§ØºÙ†ÙŠØªÙŠ"], async (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");
  if (!text) {
    return ctx.reply(
      "âŒï¸™Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© ÙˆØµÙ Ù„Ù„Ø£ØºÙ†ÙŠØ© ğŸ¶\n\nÙ…Ø«Ø§Ù„:\n`/suno Father`"
    );
  }

  await ctx.reply(
    `â•­â”€ââŒ© ğŸ¶ ğ’ğ”ğğ ğ€ğˆ ğŒğ”ğ’ğˆğ‚ âŒªââ”€â•®\nâ”‚âŒ² Ø¬Ø§Ø±ÙŠ ØµÙ†Ø¹ Ø£ØºÙ†ÙŠØªÙƒ ğŸ§âœ¨\nâ”‚âŒ² Ø§Ù„Ù…Ø±Ø¬Ùˆ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± â³\nâ•°â”€â”€â”€â•ââŠ±ââœ¿ââŠ°ââ•â”€â”€â”€â•¯`
  );

  const api = new SunoAPI();
  const result = await api.generate({ prompt: text });

  if (result.status === "error") {
    return ctx.reply(`âŒï¸™Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆÙ„ÙŠØ¯:\n\n${JSON.stringify(result.error, null, 2)}`);
  }

  if (result.status === "timeout") {
    return ctx.reply(`â³ï¸™Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª ÙˆÙ„Ù… ÙŠØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ğŸ•·ï¸`);
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø£ÙˆÙ„ Ù†ØªÙŠØ¬ØªÙŠÙ† ÙÙ‚Ø·
  const itemsToSend = result.results.slice(0, 2);

  for (const [index, item] of itemsToSend.entries()) {
    try {
      if (index > 0)
        await new Promise((resolve) => setTimeout(resolve, 2000));

      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª + Ø§Ù„ÙƒÙ„Ù…Ø§Øª
      await ctx.replyWithAudio(
        { url: item.audio_url },
        {
          title: `SunoAI Track ${index + 1}`,
          performer: "SunoAI",
          caption: `ğŸµ ${index + 1}/${itemsToSend.length}\nğŸ¶ï¸™*Ø§Ù„ÙƒÙ„Ù…Ø§Øª:*\n\n${item.lyrics}`,
        }
      );

      // Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù
      await ctx.replyWithPhoto(
        { url: item.image_url },
        {
          caption: `ğŸ©¸ï¸™*ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù ${index + 1}/${itemsToSend.length}* ğŸ¶`,
        }
      );
    } catch (error) {
      console.error("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:", error);
      await ctx.reply(
        `âŒï¸™Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªÙŠØ¬Ø© ${index + 1}\n\n${error.message}`
      );
    }
  }
});

// Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠ Ø§Ù†Øª Ø¨Ø¹ØªÙ‡ (Ù…ÙƒØªØ¨Ø© SaveTube)
const savetube = {
  api: {
    base: "https://media.savetube.me/api",
    cdn: "/random-cdn",
    info: "/v2/info",
    download: "/download"
  },
  headers: {
    'accept': '*/*',
    'content-type': 'application/json',
    'origin': 'https://yt.savetube.me',
    'referer': 'https://yt.savetube.me/',
    'user-agent': 'Postify/1.0.0'
  },
  formats: ['144', '240', '360', '480', '720', '1080', 'mp3'],
  crypto: {
    hexToBuffer: (hexString) => {
      const matches = hexString.match(/.{1,2}/g);
      return Buffer.from(matches.join(''), 'hex');
    },
    decrypt: async (enc) => {
      const secretKey = 'C5D58EF67A7584E4A29F6C35BBC4EB12';
      const data = Buffer.from(enc, 'base64');
      const iv = data.slice(0, 16);
      const content = data.slice(16);
      const key = savetube.crypto.hexToBuffer(secretKey);
      const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);
      let decrypted = decipher.update(content);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return JSON.parse(decrypted.toString());
    }
  },
  isUrl: str => { 
    try { new URL(str); return true; } catch (_) { return false; } 
  },
  youtube: url => {
    if (!url) return null;
    const a = [
      /youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/v\/([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
      /youtu\.be\/([a-zA-Z0-9_-]{11})/
    ];
    for (let b of a) {
      if (b.test(url)) return url.match(b)[1];
    }
    return null;
  },
  request: async (endpoint, data = {}, method = 'post') => {
    try {
      const { data: response } = await axios({
        method,
        url: `${endpoint.startsWith('http') ? '' : savetube.api.base}${endpoint}`,
        data: method === 'post' ? data : undefined,
        params: method === 'get' ? data : undefined,
        headers: savetube.headers
      });
      return { status: true, code: 200, data: response };
    } catch (error) {
      return { status: false, code: error.response?.status || 500, error: error.message };
    }
  },
  getCDN: async () => {
    const response = await savetube.request(savetube.api.cdn, {}, 'get');
    if (!response.status) return response;
    return { status: true, code: 200, data: response.data.cdn };
  },
  download: async (link, format) => {
    if (!link) return { status: false, code: 400, error: "âŒ ÙÙŠÙ† Ø§Ù„Ø±Ø§Ø¨Ø· ÙŠØ§ Ù…Ø¹Ù„Ù…ØŸ" };
    if (!savetube.isUrl(link)) return { status: false, code: 400, error: "âŒ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ø´ ØµØ­ÙŠØ­" };
    if (!format || !savetube.formats.includes(format)) {
      return { status: false, code: 400, error: `âŒ Ø§Ù„ØµÙŠØºØ© Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ø§Ù„ØµÙŠØº Ø§Ù„Ù…ØªØ§Ø­Ø©: ${savetube.formats.join(", ")}` };
    }
    const id = savetube.youtube(link);
    if (!id) return { status: false, code: 400, error: "âŒ Ù…Ø´ Ù‚Ø§Ø¯Ø± Ø£Ø³ØªØ®Ø±Ø¬ ÙƒÙˆØ¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ" };
    try {
      const cdnx = await savetube.getCDN();
      if (!cdnx.status) return cdnx;
      const cdn = cdnx.data;
      const result = await savetube.request(`https://${cdn}${savetube.api.info}`, {
        url: `https://www.youtube.com/watch?v=${id}`
      });
      if (!result.status) return result;
      const decrypted = await savetube.crypto.decrypt(result.data.data);
      const dl = await savetube.request(`https://${cdn}${savetube.api.download}`, {
        id: id,
        downloadType: format === 'mp3' ? 'audio' : 'video',
        quality: format === 'mp3' ? '128' : format,
        key: decrypted.key
      });
      return {
        status: true,
        code: 200, 
        result: {
          title: decrypted.title || "Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†",
          type: format === 'mp3' ? 'audio' : 'video',
          format: format,
          thumbnail: decrypted.thumbnail || `https://i.ytimg.com/vi/${id}/maxresdefault.jpg`,
          download: dl.data.data.downloadUrl,
          id: id,
          duration: decrypted.duration,
          quality: format === 'mp3' ? '128' : format
        }
      };
    } catch (error) {
      return { status: false, code: 500, error: error.message };
    }
  }
};

// Ø£Ù…Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„
bot.command("ytmp4", async (ctx) => {
  const text = ctx.message.text.split(" ").slice(1);
  const url = text[0];
  const format = text[1] || "360"; // Ø§ÙØªØ±Ø§Ø¶ÙŠ 360p
  
  if (!url) return ctx.reply("âŒ Ø­Ø· Ù„ÙŠÙ†Ùƒ Ø§Ù„ÙŠÙˆØªÙŠÙˆØ¨ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±.\nÙ…Ø«Ø§Ù„:\n/ytmp4 https://youtu.be/xxxx 720");

  ctx.reply("ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ØŒ Ø§Ø³ØªÙ†Ù‰ Ø¹Ù„ÙŠØ§...");
  try {
    const result = await savetube.download(url, format);
    if (!result.status) return ctx.reply("âŒ Ø®Ø·Ø£: " + result.error);

    await ctx.replyWithPhoto({ url: result.result.thumbnail }, { caption: `ğŸ¬ ${result.result.title}\nğŸ©¸ Ø§Ù„Ø¬ÙˆØ¯Ø©: ${result.result.quality}p` });
    await ctx.replyWithVideo({ url: result.result.download }, { caption: "ğŸ•¹ï¸ ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­ ğŸ‰" });

  } catch (err) {
    ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: " + err.message);
  }
});



const vo = {
  api: {
    voice: "https://text.pollinations.ai"
  },

  voiceModels: [
{ name: "a", arName: "alloy", desc: "ØµÙˆØª Ù…ØªÙˆØ§Ø²Ù† ÙˆÙ…Ø­Ø§ÙŠØ¯", value: "alloy" },
    { name: "Ø¥ÙŠÙƒÙˆ", arName: "Ø§ÙŠÙƒÙˆ", desc: "ØµÙˆØª Ø¹Ù…ÙŠÙ‚ ÙˆÙ‚ÙˆÙŠ", value: "echo" },
    { name: "ÙØ§Ø¨Ù„", arName: "ÙØ§Ø¨Ù„", desc: "ØµÙˆØª Ø¯Ø§ÙØ¦ ÙˆØ³Ø±Ø¯ÙŠ", value: "fable" },
    { name: "Ø£ÙˆÙ†ÙŠÙƒØ³", arName: "Ø£ÙˆÙ†ÙŠÙƒØ³", desc: "ØµÙˆØª Ù…Ù‡ÙŠØ¨ ÙˆØ¬Ø§Ø¯", value: "onyx" },
    { name: "Ù†ÙˆÙØ§", arName: "Ù†ÙˆÙØ§", desc: "ØµÙˆØª ÙˆØ¯ÙˆØ¯ ÙˆØ§Ø­ØªØ±Ø§ÙÙŠ", value: "nova" },
    { name: "Ø´ÙŠÙ…Ø±", arName: "Ø´ÙŠÙ…Ø±", desc: "ØµÙˆØª Ø®ÙÙŠÙ ÙˆÙ…Ø´Ø±Ù‚", value: "shimmer" },
    { name: "ÙƒÙˆØ±Ø§Ù„", arName: "ÙƒÙˆØ±Ø§Ù„", desc: "ØµÙˆØª Ù„Ø·ÙŠÙ ÙˆÙ‡Ø§Ø¯Ø¦", value: "coral" },
    { name: "ÙÙŠØ±Ø³", arName: "Ù…Ø§Ø±Ùƒ", desc: "ØµÙˆØª Ø­ÙŠÙˆÙŠ ÙˆÙ…Ø¤Ø«Ø±", value: "verse" },
    { name: "Ø¨Ø§Ù„Ø§Ø¯", arName: "Ø­Ø¨ÙŠØ¨", desc: "ØµÙˆØª Ø¹Ø§Ø·ÙÙŠ ÙˆÙ†Ø§Ø¹Ù…", value: "ballad" },
    { name: "Ø¢Ø´", arName: "Ø¢Ø´", desc: "ØµÙˆØª Ù…ÙÙƒØ± ÙˆØ«Ø§Ø¨Øª", value: "ash" },
    { name: "Ø³Ø§ÙŠØ¬", arName: "Ø­ÙƒÙŠÙ…", desc: "ØµÙˆØª Ø­ÙƒÙŠÙ… ÙˆØ®Ø¨ÙŠØ±", value: "sage" },
    { name: "Ø£Ù…ÙˆØ´", arName: "Ù†Ø´ÙŠØ·", desc: "ØµÙˆØª ØºÙ†ÙŠ ÙˆÙ…Ù„ÙŠØ¡", value: "amuch" },
    { name: "Ø£Ø³ØªØ±", arName: "ÙƒÙˆØ±Ùˆ", desc: "ØµÙˆØª ÙˆØ§Ø¶Ø­ ÙˆÙ…Ø¨Ø§Ø´Ø±", value: "aster" },
    { name: "Ø¨Ø±ÙˆÙƒ", arName: "Ø¨Ø±ÙˆÙƒ", desc: "ØµÙˆØª Ø³Ù„Ø³ ÙˆÙ…Ø±ÙŠØ­", value: "brook" },
    { name: "ÙƒÙ„ÙˆÙØ±", arName: "Ù†Ø¯ÙŠ", desc: "ØµÙˆØª Ù†Ø´ÙŠØ· ÙˆØµØºÙŠØ± Ø§Ù„Ø³Ù†", value: "clover" },
    { name: "Ø¯Ø§Ù†", arName: "Ø¯Ø§Ù†", desc: "ØµÙˆØª Ø±Ø¬ÙˆÙ„ÙŠ ÙˆØ«Ø§Ø¨Øª", value: "dan" },
    { name: "Ø¥ÙŠÙ„Ø§Ù†", arName: "Ø§ÙŠÙ„Ø§Ù†", desc: "ØµÙˆØª Ø£Ù†ÙŠÙ‚ ÙˆØ·Ù„ÙŠÙ‚", value: "elan" }
  ],

  voice: async (text, voiceValue) => {
    try {
      const voiceUrl = `${vo.api.voice}/${encodeURIComponent(text)}?model=openai-audio&voice=${voiceValue}`;
      return voiceUrl;
    } catch (error) {
      throw new Error(`ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª: ${error.message}`);
    }
  }
};

// Ø£Ù…Ø± Ø§Ù„Ø£ØµÙˆØ§Øª: Ù„Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© ÙƒÙ„ Ø§Ù„Ø£ØµÙˆØ§Øª
bot.command("vo", async (ctx) => {
  const voicesList = vo.voiceModels.map(v =>
    `ğŸ”Š ${v.arName} (/voice_${v.arName}) - ${v.desc}`
  ).join("\n");

  await ctx.replyWithMarkdown(`ğŸ¤ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØµÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:\n\n${voicesList}\n\nÙ…Ø«Ø§Ù„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n/voice_Ø£ÙˆÙ†ÙŠÙƒØ³ Ù…Ø±Ø­Ø¨Ù‹Ø§ ÙƒÙŠÙ Ø­Ø§Ù„ÙƒØŸ`);
});

// Ø£ÙˆØ§Ù…Ø± ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª Ù„ÙƒÙ„ ØµÙˆØª
vo.voiceModels.forEach(v => {
  bot.command(`voice_${v.arName}`, async (ctx) => {
    const text = ctx.message.text.replace(`/voice_${v.arName}`, "").trim();

    if (!text) {
      return ctx.reply(`âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/voice_${v.arName} Ù…Ø±Ø­Ø¨Ø§`);
    }

    try {
      const audioUrl = await vo.voice(text, v.value);
      await ctx.replyWithAudio({ url: audioUrl }, { title: `${v.arName}.mp3` });
    } catch (err) {
      console.error("Voice error:", err);
      await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
    }
  });
});//======
// alloy

// Ø¯Ø§Ù„Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª Ù…Ø¹ retry
async function generateVoice(text, voice = "alloy", retries = 2) {
  for (let i = 0; i < retries; i++) {
    try {
      const audioUrl = await vo.voice(text, voice);

      if (!audioUrl) continue; // Ù„Ùˆ Ù…ÙÙŠØ´ Ø±Ø§Ø¨Ø· Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ

      const res = await axios.head(audioUrl);
      if (!res.headers["content-length"] || parseInt(res.headers["content-length"]) < 1000) {
        continue; // Ù„Ùˆ Ø§Ù„ØµÙˆØª ÙØ§Ø¶ÙŠ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ
      }

      return audioUrl; // ğŸ•¹ï¸ ØµÙˆØª Ø³Ù„ÙŠÙ…
    } catch (err) {
      console.error(`Voice attempt ${i + 1} failed:`, err);
      // ÙŠØ¬Ø±Ø¨ ØªØ§Ù†ÙŠ Ù„Ùˆ Ù„Ø³Ù‡ ÙÙŠ Ù…Ø­Ø§ÙˆÙ„Ø§Øª
    }
  }
  return null; // âŒ ÙƒÙ„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª ÙØ´Ù„Øª
}

// Ø£Ù…Ø± alloy
bot.command("spam", async (ctx) => {
  const text = ctx.message.text.replace("/alloy", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/alloy Hello, how are you?");

  const audioUrl = await generateVoice(text, "alloy");

  if (!audioUrl) {
    return ctx.reply("âŒ Ø­ØµÙ„Øª Ù…Ø´ÙƒÙ„Ø© ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù†ÙŠØ©. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ Ø¨Ø¹Ø¯ Ø´ÙˆÙŠØ©.");
  }

  await ctx.replyWithAudio({ url: audioUrl }, { title: "alloy.mp3" });
});

// Ø±Ø¯ Ø¹Ù† Ø§Ù„Ù…Ø·ÙˆØ±
bot.hears(/Ø§Ù„Ù…Ø·ÙˆØ±|Ø§ÙˆÙ†Ø±|Ø§Ù„Ù…Ø§Ù„Ùƒ|Ù…ÙŠÙ† ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª/i, async (ctx) => {
  const text = "Ø¨Øµ ÙŠØ§ Ù…Ø¹Ù„Ù…ØŒ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ø¨ØªÙˆØ¹ÙŠ Ù‡Ù…Ø§ Ù…Ø§Ù„Ùƒ Ùˆ ØªÙŠØ±Ø¨Ùˆ Ùˆ Ø³Ù…ÙƒÙ‡ Ùˆ ÙØ§Ø±Ø³. ÙˆØ§Ù„Ø§ÙˆÙ†Ø± Ø§Ù„ÙƒØ¨ÙŠØ± Ù‡Ùˆ ØªÙŠÙ… Ø§Ø³Ø¨Ø§Ù…. Ùˆ Ø§Ø­Ù†Ø§ Ø´ØºØ§Ù„ÙŠÙ† Ø¨Ø§Ù„Ù…ØµØ±ÙŠ ÙƒØ¯Ù‡ Ø¹Ù„Ù‰ Ø·ÙˆÙ„ ÙŠØ§ ØµØ§Ø­Ø¨ÙŠ.";
  const audioUrl = await generateVoice(text, "alloy");

  if (!audioUrl) {
    return ctx.reply("âŒ Ø§Ù„ØµÙˆØª Ø¨ØªØ§Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ù…Ø§Ø·Ù„Ø¹Ø´ Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù†ÙŠØ©. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
  }

  await ctx.replyWithAudio({ url: audioUrl }, { title: "owner.mp3" });
});
// Ø±Ø¯ Ø¨Ø§Ù„ØµÙˆØª Ø¨Ø§Ù„Ù„Ù‡Ø¬Ø© Ø§Ù„Ù…ØµØ±ÙŠØ© Ù„Ùˆ Ø­Ø¯ Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø·ÙˆØ±
bot.hears(/Ø§Ù„Ù…Ø·ÙˆØ±|Ø§ÙˆÙ†Ø±|Ø§Ù„Ù…Ø§Ù„Ùƒ|Ù…ÙŠÙ† ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª/i, async (ctx) => {
  try {
    const text = "Ø¨Øµ ÙŠØ§ Ù…Ø¹Ù„Ù…ØŒ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ø¨ØªÙˆØ¹ÙŠ Ù‡Ù…Ø§ Ù…Ø§Ù„Ùƒ Ùˆ ØªÙŠØ±Ø¨Ùˆ Ùˆ Ø³Ù…ÙƒÙ‡ Ùˆ ÙØ§Ø±Ø³. ÙˆØ§Ù„Ø§ÙˆÙ†Ø± Ø§Ù„ÙƒØ¨ÙŠØ± Ù‡Ùˆ ØªÙŠÙ… Ø§Ø³Ø¨Ø§Ù…. Ùˆ Ø§Ø­Ù†Ø§ Ø´ØºØ§Ù„ÙŠÙ† Ø¨Ø§Ù„Ù…ØµØ±ÙŠ ÙƒØ¯Ù‡ Ø¹Ù„Ù‰ Ø·ÙˆÙ„ ÙŠØ§ ØµØ§Ø­Ø¨ÙŠ.";
    const audioUrl = await vo.voice(text, "alloy");

    if (!audioUrl) {
      return ctx.reply("âŒ Ø§Ù„ØµÙˆØª Ø¨ØªØ§Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ø·Ù„Ø¹ ÙØ§Ø¶ÙŠØŒ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
    }

    const res = await axios.head(audioUrl);
    if (!res.headers["content-length"] || parseInt(res.headers["content-length"]) < 1000) {
      return ctx.reply("âŒ Ø§Ù„ØµÙˆØª Ø·Ù„Ø¹ ÙØ§Ø¶ÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
    }

    await ctx.replyWithAudio({ url: audioUrl }, { title: "owner.mp3" });
  } catch (err) {
    console.error("Voice owner error:", err);
    await ctx.reply("âŒ ÙÙŠ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ØµÙˆØªØŒ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
  }
});

// echo
bot.command("echo", async (ctx) => {
  const text = ctx.message.text.replace("/echo", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/echo Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "echo");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "echo.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¬Ø¯ÙˆÙ„
let prayerTimes = {};
let cairoTZ = "Africa/Cairo";

// API Ù…ÙˆØ§Ù‚ÙŠØª Ø§Ù„ØµÙ„Ø§Ø©
async function fetchPrayerTimes(city = "Cairo") {
  try {
    const { data } = await axios.get(
      `https://api.aladhan.com/v1/timingsByCity?city=${city}&country=Egypt&method=8`
    );

    prayerTimes = {
      Fajr: data.data.timings.Fajr,
      Dhuhr: data.data.timings.Dhuhr,
      Asr: data.data.timings.Asr,
      Maghrib: data.data.timings.Maghrib,
      Isha: data.data.timings.Isha,
    };

    await createPrayerImage(prayerTimes, city);
    console.log("âœ… Prayer times updated", prayerTimes);
  } catch (err) {
    console.error("âŒ Error fetching prayer times:", err.message);
  }
}

// Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ø¨Ù…ÙˆØ§Ù‚ÙŠØª Ø§Ù„ØµÙ„Ø§Ø©
async function createPrayerImage(times, city) {
  const image = await Jimp.read(
    "https://telegra.ph/file/8e791e4a13e80881584dc.jpg"
  );
  const fontWhite = await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE);
  const fontBlack = await Jimp.loadFont(Jimp.FONT_SANS_64_BLACK);

  image.print(fontWhite, 550, 223, times.Fajr);
  image.print(fontWhite, 550, 321, times.Dhuhr);
  image.print(fontWhite, 550, 392, times.Asr);
  image.print(fontWhite, 550, 481, times.Maghrib);
  image.print(fontWhite, 550, 571, times.Isha);

  image.print(fontBlack, 870, 391, city);

  await image.writeAsync("./prayer.png");
}

// Ø§Ù„ØªØ­Ù‚Ù‚ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©
setInterval(async () => {
  if (!prayerTimes.Fajr) return;

  const date = new Date(
    new Date().toLocaleString("en-US", { timeZone: cairoTZ })
  );
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const now = `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}`;

  for (let [name, time] of Object.entries(prayerTimes)) {
    if (time.startsWith(now)) {
      await bot.telegram.sendAudio(
        CHAT_ID, // << Ø­Ø· Ø§Ù„Ø§ÙŠØ¯ÙŠ Ø¨ØªØ§Ø¹ Ø§Ù„Ø¬Ø±ÙˆØ¨ Ø§Ùˆ Ø§Ù„Ø´Ø®Øµ Ù‡Ù†Ø§
        { url: "https://media.vocaroo.com/mp3/1ofLT2YUJAjQ" },
        {
          caption: `ğŸ•Œ Ø­Ø§Ù† Ø§Ù„Ø¢Ù† ÙˆÙ‚Øª ØµÙ„Ø§Ø© ${name}\nğŸ•‘ ${time}`,
          parse_mode: "Markdown",
        }
      );
      await bot.telegram.sendPhoto(CHAT_ID, { source: "./w.png" });
    }
  }
}, 60 * 1000);

// Ø£Ù…Ø± ÙŠØ¯ÙˆÙŠ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ÙˆØ§Ù‚ÙŠØª


// fable
bot.command("fable", async (ctx) => {
  const text = ctx.message.text.replace("/fable", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/fable Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "fable");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "fable.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// onyx
bot.command("onyx", async (ctx) => {
  const text = ctx.message.text.replace("/onyx", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/onyx Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "onyx");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "onyx.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// nova
bot.command("nova", async (ctx) => {
  const text = ctx.message.text.replace("/nova", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/nova Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "nova");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "nova.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});



// Ø£ÙˆØ§Ù…Ø±
bot.command(["my_msg", "Ø±Ø³Ø§Ø¦Ù„ÙŠ"], async (ctx) => {
  const chatId = ctx.chat.id;
  const userId = ctx.from.id;

  if (!global.groupData[chatId] || !global.groupData[chatId][userId]) {
    return ctx.reply("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù† Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†.");
  }

  const messagesSent = global.groupData[chatId][userId].messagesSent;

  let message = `ğŸ©¸ Ø¥Ø­Ù€ØµÙ€Ø§Ø¦Ù€ÙŠÙ€Ø§Øª Ø±Ø³Ù€Ø§Ø¦Ù€Ù„Ù€Ùƒ\n\n`;
  message += `ğŸ”¥ Ø§Ù„Ù€Ù…Ù€Ø¬Ù€Ù…Ù€ÙˆØ¹Ù€Ø©: ${ctx.chat.title}\n`;
  message += `ğŸ”¥ Ø§Ù„Ù€Ù…Ù€Ø³Ù€ØªÙ€Ø®Ù€Ø¯Ù…: [${ctx.from.first_name}](tg://user?id=${userId})\n`;
  message += `ğŸ”¥ Ø¹Ù€Ø¯Ø¯ Ø§Ù„Ù€Ø±Ø³Ù€Ø§Ø¦Ù€Ù„: ${messagesSent} Ø±Ø³Ù€Ø§Ù„Ù€Ø©\n`;

  ctx.replyWithMarkdown(message);
});

bot.command("total", async (ctx) => {
  const chatId = ctx.chat.id;

  if (!global.groupData[chatId]) {
    return ctx.reply("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†.");
  }

  const groupUsers = global.groupData[chatId];
  const sortedUsers = Object.entries(groupUsers).sort(
    (a, b) => b[1].messagesSent - a[1].messagesSent
  );

  const totalMessages = sortedUsers.reduce(
    (sum, user) => sum + user[1].messagesSent,
    0
  );
  const totalMembers = await ctx.getChatMembersCount();

  let resultMessage = `ğŸ©¸ Ø¥Ø­Ù€ØµÙ€Ø§Ø¦Ù€ÙŠÙ€Ø§Øª Ø§Ù„Ù€Ø±Ø³Ù€Ø§Ø¦Ù€Ù„ Ø¯Ø§Ø®Ù€Ù„ Ø§Ù„Ù€Ù…Ù€Ø¬Ù€Ù…Ù€ÙˆØ¹Ù€Ø© ğŸ•·ï¸\n\n`;
  resultMessage += `ğŸ”¥ Ø§Ù„Ù€Ù…Ù€Ø¬Ù€Ù…Ù€ÙˆØ¹Ù€Ø©: ${ctx.chat.title}\n`;
  resultMessage += `ğŸ”¥ Ø¹Ù€Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ù€Ø¶Ù€Ø§Ø¡: ${totalMembers}\n`;
  resultMessage += `ğŸ”¥ Ø¥Ø¬Ù€Ù…Ù€Ø§Ù„Ù€ÙŠ Ø§Ù„Ù€Ø±Ø³Ù€Ø§Ø¦Ù€Ù„: ${totalMessages} Ø±Ø³Ø§Ù„Ø©\n\n`;

  if (sortedUsers.length > 0) {
    const king = sortedUsers[0];
    resultMessage += `ğŸ©¸ Ù…Ù€Ù„Ù€Ùƒ Ø§Ù„Ù€ØªÙ€ÙÙ€Ø§Ø¹Ù€Ù„! \n`;
    resultMessage += `âœ¨ [User](tg://user?id=${king[0]}) - ${king[1].messagesSent} Ø±Ø³Ù€Ø§Ù„Ù€Ø© ğŸ•·ï¸\n\n`;
  }

  resultMessage += `ğŸ”¥ Ø¯ØªÙ€ÙÙ€Ø§ØµÙ€ÙŠÙ€Ù„ Ø§Ù„Ù€Ø±Ø³Ù€Ø§Ø¦Ù€Ù„ Ø­Ù€Ø³Ù€Ø¨ Ø§Ù„Ù€Ø£Ø¹Ù€Ø¶Ù€Ø§Ø¡: ğŸ©¸\n`;
  sortedUsers.forEach(([user, data], index) => {
    const userMention = `[User](tg://user?id=${user})`;
    resultMessage += `${index + 1}. ${userMention} - ${data.messagesSent} Ø±Ø³Ù€Ø§Ù„Ù€Ø©\n`;
    resultMessage += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  });

  ctx.replyWithMarkdown(resultMessage);
});

// shimmer
bot.command("shimmer", async (ctx) => {
  const text = ctx.message.text.replace("/shimmer", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/shimmer Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "shimmer");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "shimmer.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// coral
bot.command("coral", async (ctx) => {
  const text = ctx.message.text.replace("/coral", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/coral Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "coral");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "coral.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// verse
bot.command("verse", async (ctx) => {
  const text = ctx.message.text.replace("/verse", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/verse Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "verse");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "verse.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});


// Ù…ØµÙÙˆÙØ© Ø§Ù„ØµÙˆØ±
const p = [
  'https://telegra.ph/file/0b4edfff71de7f421736b.jpg', 
  'https://telegra.ph/file/966e5a75adcf3038d2117.jpg',     
  'https://telegra.ph/file/129cf324be09328bde328.jpg', 
  'https://telegra.ph/file/1ba93e9e0d969b6ea645c.jpg',     
  'https://telegra.ph/file/a76e59689727873121251.jpg', 
  'https://telegra.ph/file/dc9d31300e8714770b3a8.jpg', 
  'https://telegra.ph/file/fc5b11c266fe9b906253b.jpg', 
  'https://telegra.ph/file/fa89bc4eff660c0a2a715.jpg', 
  'https://telegra.ph/file/b45f2556309e6fa341b62.jpg', 
  'https://telegra.ph/file/f6544a989885590ed653c.jpg', 
  'https://telegra.ph/file/2d6ae1007a4a5fc0dc38b.jpg', 
  'https://telegra.ph/file/cffd6599039759d29df15.jpg', 
  'https://telegra.ph/file/58397881dace03ce7e7de.jpg', 
  'https://telegra.ph/file/8ad3c7e4b606536e6256d.jpg', 
  'https://telegra.ph/file/545bb8656b828f0248617.jpg', 
  'https://telegra.ph/file/eaeac375c6377b459eb55.jpg', 
  'https://telegra.ph/file/41cd9ffae9e40b8ce36a7.jpg', 
  'https://telegra.ph/file/2fbb2eba2db74876ec289.jpg', 
  'https://telegra.ph/file/8bea1ca85dee6f0ba788b.jpg', 
  'https://telegra.ph/file/41cd9ffae9e40b8ce36a7.jpg', 
  'https://telegra.ph/file/1c728549ef79e7974458d.jpg', 
  'https://telegra.ph/file/1c728549ef79e7974458d.jpg', 
  'https://telegra.ph/file/adfd607d2aaa459504872.jpg', 
  'https://telegra.ph/file/c95e72f6b703e04d9573b.jpg', 
  'https://telegra.ph/file/1b68f1ee280ac79575325.jpg', 
  'https://telegra.ph/file/cd125e9978540758943f1.jpg', 
  'https://telegra.ph/file/cd125e9978540758943f1.jpg', 
  'https://telegra.ph/file/0fd432892427ff46191b1.jpg', 
  'https://telegra.ph/file/2b6ed24f87092d1e6900c.jpg', 
  'https://telegra.ph/file/2b6ed24f87092d1e6900c.jpg', 
  'https://telegra.ph/file/f2a4e534db1f22af8ce2c.jpg', 
  'https://telegra.ph/file/3d6d1f51138ad750577ed.jpg', 
  'https://telegra.ph/file/61799c54946579bfa08a1.jpg', 
  'https://telegra.ph/file/1afc70ea404504d2f5994.jpg',
  'https://telegra.ph/file/2ce9d4eb31577da9f1525.jpg',
  'https://telegra.ph/file/9c732155bf4e6a2308bcc.jpg',
  'https://telegra.ph/file/3cc38e940f156c3746d7d.jpg',
  'https://telegra.ph/file/dc5e2740d8248144bc996.jpg',
  'https://telegra.ph/file/b3b9565430764ae00a2d8.jpg',
  'https://telegra.ph/file/8fee44c2ee4130e35aa4d.jpg',
  'https://telegra.ph/file/9a8657130d89d8b118714.jpg',     
  'https://telegra.ph/file/2d1a2180234953c6dc622.jpg', 
  'https://telegra.ph/file/fc039b7423a3b27d0bddd.jpg', 
  'https://telegra.ph/file/7dccd99036b926b14fcc6.jpg', 
  'https://telegra.ph/file/c0e74a9a6f7498e7e931c.jpg', 
  'https://telegra.ph/file/2e8f8c310d98d4cc35307.jpg', 
  'https://telegra.ph/file/a8a16e0678ff4d1d3b2e5.jpg', 
  'https://telegra.ph/file/d960b628d8bf86248a0ce.jpg', 
  'https://telegra.ph/file/d960b628d8bf86248a0ce.jpg', 
  'https://telegra.ph/file/4d06e2f75f512c584bb26.jpg', 
  'https://telegra.ph/file/6c3400b471e6797fd9f12.jpg', 
  'https://telegra.ph/file/a861285da4b31a51b9250.jpg', 
  'https://telegra.ph/file/c324633c18ad44955db12.jpg', 
  'https://telegra.ph/file/00c745531c05693a713fa.jpg', 
  'https://telegra.ph/file/77df02f5227a5bab6091d.jpg', 
  'https://telegra.ph/file/01960a18a9bd6b1a55d01.jpg', 
  'https://telegra.ph/file/c3b0fc047f232acfe6cc8.jpg', 
  'https://telegra.ph/file/5e82362b93b0bd30eceee.jpg', 
  'https://telegra.ph/file/0f8cfef83b256d8f20fa6.jpg', 
  'https://telegra.ph/file/f2b81fcced4b3e6c74efc.jpg', 
  'https://telegra.ph/file/7a2feb1fc3219802f8c16.jpg', 
  'https://telegra.ph/file/1b0f08ca14c593b531ee5.jpg', 
  'https://telegra.ph/file/13ad84060675b1d63f9a5.jpg', 
  'https://telegra.ph/file/2bf5dd82da40be37fe23e.jpg', 
  'https://telegra.ph/file/35887f0b62af93bd1209c.jpg', 
  'https://telegra.ph/file/47202d8641c9062df29e4.jpg', 
  'https://telegra.ph/file/1da3bbc0d089c837ce977.jpg', 
  'https://telegra.ph/file/41202fccf9541aae90522.jpg', 
  'https://telegra.ph/file/67cca40d8e37f67af1514.jpg', 
  'https://telegra.ph/file/67cca40d8e37f67af1514.jpg', 
  'https://telegra.ph/file/e4d770e74bea737d93a7d.jpg',
  'https://telegra.ph/file/7c3fc3534e42995525a81.jpg',
  'https://telegra.ph/file/7f9daca6edf0ed3279a81.jpg',
  'https://telegra.ph/file/8e42d965afb9bab2c1b2d.jpg',
  'https://telegra.ph/file/bee606c7ceeca46a6d7d6.jpg',
  'https://telegra.ph/file/7f9daca6edf0ed3279a81.jpg',
  'https://telegra.ph/file/ee7d6171e234869534231.jpg',
  'https://telegra.ph/file/9ea5e1a33f20aa39f856a.jpg',
  'https://telegra.ph/file/5ec51f907d0cfeb066a9f.jpg',
  'https://telegra.ph/file/ffb9f5c6438ac3278f221.jpg',
  'https://telegra.ph/file/7f9daca6edf0ed3279a81.jpg', 
];
bot.command(["dado", "anime"], async (ctx) => {
  const randomImg = p[Math.floor(Math.random() * p.length)];
  await ctx.replyWithPhoto(
    { url: randomImg },
    {
      caption: "â”â†â”ƒØ®Ù€Ù„ÙÙ€ÙŠØ§Øª Ø§Ù†Ù€Ù…Ù€ÙŠ Ù…Ù€Ù†Ù€ÙˆØ¹Ù‡ ğŸ”–â”ƒ",
    }
  );
});

// ballad
bot.command("ballad", async (ctx) => {
  const text = ctx.message.text.replace("/ballad", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/ballad Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "ballad");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "ballad.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// ash
bot.command("ash", async (ctx) => {
  const text = ctx.message.text.replace("/ash", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/ash Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "ash");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "ash.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// sage
bot.command("sage", async (ctx) => {
  const text = ctx.message.text.replace("/sage", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/sage Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "sage");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "sage.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// amuch
bot.command("amuch", async (ctx) => {
  const text = ctx.message.text.replace("/amuch", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/amuch Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "amuch");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "amuch.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// aster
bot.command("aster", async (ctx) => {
  const text = ctx.message.text.replace("/aster", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/aster Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "aster");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "aster.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// brook
bot.command("brook", async (ctx) => {
  const text = ctx.message.text.replace("/brook", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/brook Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "brook");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "brook.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// clover
bot.command("clover", async (ctx) => {
  const text = ctx.message.text.replace("/clover", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/clover Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "clover");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "clover.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// dan
bot.command("dan", async (ctx) => {
  const text = ctx.message.text.replace("/dan", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/dan Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "dan");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "dan.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

// elan
bot.command("elan", async (ctx) => {
  const text = ctx.message.text.replace("/elan", "").trim();
  if (!text) return ctx.reply("âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±. Ù…Ø«Ø§Ù„:\n/elan Ù…Ø±Ø­Ø¨Ø§");
  try {
    const audioUrl = await vo.voice(text, "elan");
    await ctx.replyWithAudio({ url: audioUrl }, { title: "elan.mp3" });
  } catch (err) {
    console.error("Voice error:", err);
    await ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});
// Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„Ø§Øª
const chatModels = {
  gpt: {
    name: "openai",
    description: "ğŸ¯ GPT-4o-mini | (Ù…ÙˆØ¯ÙŠÙ„ Ø£Ø³Ø§Ø³ÙŠ)",
    command: "gpt",
    emoji: "ğŸ¤–"
  },
  gpt4: {
    name: "openai-large",
    description: "ğŸš€ GPT-4o | (Ù…ÙˆØ¯ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…)",
    command: "gpt_pro",
    emoji: "ğŸ§ "
  },
  o1: {
    name: "openai-reasoning",
    description: "ğŸ§© o1-mini | (Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚)",
    command: "ai_1",
    emoji: "ğŸ§®"
  },
  o3: {
    name: "openai-reasoning",
    description: "ğŸ”¬ o3-mini | (Ø±Ø¤ÙŠØ© ÙˆÙ…Ù†Ø·Ù‚)",
    command: "ai_pro",
    emoji: "ğŸ§¿"
  },
  llama: {
    name: "llama",
    description: "ğŸ¦™ Llama 3.3 | (Ù…ÙØªÙˆØ­ Ø§Ù„Ù…ØµØ¯Ø±)",
    command: "lima",
    emoji: "ğŸŒ¿"
  },
  mistral: {
    name: "mistral",
    description: "ğŸ· Mistral Nemo | (ÙØ±Ù†Ø³ÙŠ)",
    command: "franso",
    emoji: "ğŸ‡«ğŸ‡·"
  },
  claude: {
    name: "claude",
    description: "ğŸ© Claude 3.5 Haiku",
    command: "claude",
    emoji: "ğŸ“œ"
  },
  gemini: {
    name: "gemini",
    description: "ğŸ’  Gemini Flash | (Ù…Ù† Ø¬ÙˆØ¬Ù„)",
    command: "gemini",
    emoji: "âš¡"
  },
  deepseek: {
    name: "deepseek",
    description: "ğŸŒŒ DeepSeek-V3",
    command: "deepseek",
    emoji: "ğŸ”"
  },
  phi: {
    name: "phi",
    description: "ğŸ“¡ Phi-4 | (Ù…Ù† Ù…Ø§ÙŠÙƒØ±ÙˆØ³ÙˆÙØª)",
    command: "phi",
    emoji: "ğŸª"
  }
};

// API Pollinations
const pollinations = {
  api: {
    chat: "https://text.pollinations.ai",
  },
  header: {
    'Connection': 'keep-alive',
    'User-Agent': 'Mozilla/5.0',
    'Accept': '*/*'
  }
};

// Ø¯Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù€ API
async function chatWithPollinations(model, question) {
  try {
    const res = await axios.get(`${pollinations.api.chat}/${encodeURIComponent(question)}`, {
      params: { model },
      headers: pollinations.header,
      timeout: 15000,
    });
    return res.data;
  } catch (e) {
    if (e.code === 'ECONNABORTED') throw new Error("â± Ø§Ù„Ø®Ø§Ø¯Ù… ØªØ£Ø®Ø± Ø¨Ø§Ù„Ø±Ø¯.");
    throw new Error(`âŒ Ø®Ø·Ø£: ${e.message}`);
  }
}

// Ø£Ù…Ø± /start Ù„Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±
bot.start((ctx) => {
  let helpMessage = `ğŸ¤– Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ \n\n`;
  for (const key in chatModels) {
    const model = chatModels[key];
    helpMessage += `${model.emoji} ${model.description}\n`;
    helpMessage += `   â”— /${model.command} <Ø³Ø¤Ø§Ù„Ùƒ>\n\n`;
  }
  ctx.reply(helpMessage, { parse_mode: "Markdown" });
});

// Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙˆØ§Ù…Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ù„ÙƒÙ„ Ù…ÙˆØ¯ÙŠÙ„
for (const key in chatModels) {
  const model = chatModels[key];

  bot.command(model.command, async (ctx) => {
    const question = ctx.message.text.replace(`/${model.command}`, "").trim();

    if (!question) {
      return ctx.reply(`âŒ Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±.\nğŸ©¸ Ù…Ø«Ø§Ù„: /${model.command} Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠØŸ`);
    }

    const waitMsg = await ctx.reply(`ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ${model.description}...`, { parse_mode: "Markdown" });

    try {
      const answer = await chatWithPollinations(model.name, question);

      await ctx.telegram.editMessageText(
        ctx.chat.id,
        waitMsg.message_id,
        null,
        `${model.emoji} ${model.description}\n\n${answer}`,
        { parse_mode: "Markdown" }
      );

    } catch (error) {
      ctx.reply(`âŒ Ø®Ø·Ø£: ${error.message}`);
    }
  });
}

//==========

bot.command(["apk2", "dapk2"], async (ctx) => {
  const args = ctx.message.text.split(" ").slice(1);
  if (!args[0]) {
    return ctx.reply(
      `âŒ¯ï¸™ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ø³Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„Ù‡.\nâŒ¯ï¸™Ù…Ø«Ø§Ù„: /apk2 ÙƒÙ„Ø§Ø´ Ø±ÙˆÙŠØ§Ù„`
    );
  }

  await ctx.reply(`âŒ¯ï¸™Ø¬Ø§Ø±Ù Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...\nâŒ¯ï¸™ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ù‹Ø§ ğŸ”`);

  try {
    let res = await axios.get(
      `https://api.dorratz.com/v2/apk-dl?text=${args.join(" ")}`,
      {
        maxContentLength: 50 * 1024 * 1024,
        maxBodyLength: 50 * 1024 * 1024,
      }
    );

    let result = res.data;
    if (!result?.dllink) {
      return ctx.reply("âŒ¯ï¸™Ø¹Ø°Ø±Ù‹Ø§ØŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… âŒ");
    }

    let { name, size, lastUpdate, icon, dllink } = result;

    let texto = `âŒ¯ï¸™Ø¬Ø§Ø±Ù ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚... ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ğŸ“¦
âŒ¯ï¸™Ø§Ù„Ø§Ø³Ù…: ${name}
âŒ¯ï¸™Ø§Ù„Ø­Ø¬Ù…: ${size}
âŒ¯ï¸™Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: ${lastUpdate}

> âœ¦â”‡ğŒğˆğŠğ„ğ˜ |â™•| ğğğ“â”‡âœ¦`;

    // ØµÙˆØ±Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯Ø©
    if (icon) {
      await ctx.replyWithPhoto({ url: icon }, { caption: texto });
    } else {
      await ctx.reply(texto);
    }

    // Ù…Ù„Ù APK
    await ctx.replyWithDocument(
      { url: dllink, filename: `${name}.apk` },
      {
        caption: `âŒ¯ï¸™ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­ ğŸ©¸\n> âœ¦â”‡ğŒğˆğŠğ„ğ˜ |â™•| ğğğ“â”‡âœ¦`,
      }
    );
  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« Ø£Ùˆ Ø§Ù„ØªØ­Ù…ÙŠÙ„ØŒ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.");
  }
});
bot.command(['happymod'], async (ctx) => {
  const text = ctx.message.text.split(' ').slice(1).join(' ');
  if (!text) return ctx.reply('â— Ù…Ù† ÙØ¶Ù„Ùƒ Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†Ù‡ ÙÙŠ HappyMod.');

  await ctx.reply('ğŸ©¸ Ø¬Ø§Ø±Ù Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙÙŠ HappyMod...');

  try {
    const searchUrl = `https://happymod.com/search.html?q=${encodeURIComponent(text)}`;
    const res = await fetch(searchUrl);
    const html = await res.text();
    const $ = cheerio.load(html);

    const result = $('.pdt-app-box').first();
    if (!result.length) return ctx.reply('Ø·âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬.');

    const appLink = result.find('a').attr('href');
    if (!appLink) return ctx.reply('Ø¯âŒ ØªØ¹Ø°Ø± Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ·Ø¨ÙŠÙ‚.');

    const pageUrl = appLink.startsWith('http') ? appLink : `https://happymod.com${appLink}`;
    await fetchAppInfo(pageUrl, ctx);

  } catch (e) {
    console.error(e);
    ctx.reply('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ù† HappyMod.');
  }
});

async function fetchAppInfo(url, ctx) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

    const html = await res.text();
    const $ = cheerio.load(html);

    const title = $('h1').first().text().trim() || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
    const update = $('.app-box p').first().text().trim() || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';

    const rows = $('table.pdt-table tr');
    let version = '', date = '', size = '', rating = '', system = '', modInfo = '', developer = '', category = '', playUrl = '';

    rows.each((_, el) => {
      const key = $(el).find('td').first().text().trim().toLowerCase();
      const val = $(el).find('td').last().text().trim();

      if (key.includes('version')) version = val;
      else if (key.includes('update') || key.includes('date')) date = val;
      else if (key.includes('size')) size = val;
      else if (key.includes('rating')) rating = val;
      else if (key.includes('system') || key.includes('os')) system = val;
      else if (key.includes('mod info') || key.includes('mod features')) modInfo = val;
      else if (key.includes('developer') || key.includes('publisher')) developer = val;
      else if (key.includes('category')) category = val;
      else if (key.includes('google play') || key.includes('get it on')) {
        playUrl = $(el).find('a').attr('href') || 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
      }
    });

    let apkLink = '';
    $('.download-btn').each((_, el) => {
      const btnText = $(el).text().toLowerCase();
      if (btnText.includes('download') && btnText.includes('apk')) {
        apkLink = $(el).attr('href');
        return false;
      }
    });

    if (apkLink) {
      apkLink = apkLink.startsWith('http') ? apkLink :
        apkLink.startsWith('./') ? `https://happymod.com${apkLink.replace('./', '/')}` :
          `https://happymod.com${apkLink}`;
    } else {
      apkLink = 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
    }

    let icon = $('.top_info img').attr('src') ||
      $('.app-icon img').attr('src') ||
      $('.app-box img').first().attr('src');

    if (icon && !icon.startsWith('http')) {
      icon = `https://happymod.com${icon.startsWith('/') ? icon : `/${icon}`}`;
    }

    const caption = `ã€” HappyMod ã€•
ğŸ® Ø§Ù„Ø§Ø³Ù…: ${title}
ğŸ†š Ø§Ù„Ø¥ØµØ¯Ø§Ø±: ${version || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}
ğŸ“¦ Ø§Ù„Ø­Ø¬Ù…: ${size || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}
â­ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: ${rating || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}
âš™ï¸ Ø§Ù„Ù†Ø¸Ø§Ù…: ${system || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}
ğŸ§° Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…ÙˆØ¯: ${modInfo || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}
ğŸ§‘â€ğŸ’» Ø§Ù„Ù…Ø·ÙˆØ±: ${developer || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}
ğŸ“ Ø§Ù„ØªØµÙ†ÙŠÙ:Ø· ${category || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}
ğŸ“† Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:Ø· ${date || update || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}
ğŸ”— Ø±Ø§Ø¨Ø· Play: ${playUrl || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}
â¬‡ï¸ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„: ${apkLink}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯`;

    if (icon) {
      try {
        const resImg = await fetch(icon);
        const buffer = await resImg.buffer();

        const __dirname = path.dirname(fileURLToPath(import.meta.url));
        const tempPath = path.join(__dirname, 'temp_icon.jpg');
        fs.writeFileSync(tempPath, buffer);

        await ctx.replyWithPhoto({ source: tempPath }, { caption });
        fs.unlinkSync(tempPath);
      } catch (err) {
        console.warn('â— ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ ÙÙ‚Ø·.');
        await ctx.reply(caption);
      }
    } else {
      await ctx.reply(caption);
    }

  } catch (e) {
    console.error('Error in fetchAppInfo:', e);
    ctx.reply('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚.');
  }
}
// ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
// ========== Ø§Ù„Ø¯ÙˆØ§Ù„ ==========
async function saveweb2zip(url, options = {}) {
  if (!url) throw new Error('ÙŠØ¬Ø¨ ØªÙ‚Ø¯ÙŠÙ… Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ÙˆÙ‚Ø¹');
  url = url.startsWith('https://') ? url : `https://${url}`;

  const { data } = await axios.post('https://copier.saveweb2zip.com/api/copySite', {
    url,
    renameAssets: options.renameAssets,
    saveStructure: options.saveStructure,
    alternativeAlgorithm: options.alternativeAlgorithm,
    mobileVersion: options.mobileVersion
  }, {
    headers: {
      'accept': '*/*',
      'content-type': 'application/json',
      'origin': 'https://saveweb2zip.com',
      'referer': 'https://saveweb2zip.com/',
      'user-agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36'
    }
  });

  while (true) {
    const { data: process } = await axios.get(`https://copier.saveweb2zip.com/api/getStatus/${data.md5}`, {
      headers: {
        'accept': '*/*',
        'content-type': 'application/json',
        'origin': 'https://saveweb2zip.com',
        'referer': 'https://saveweb2zip.com/',
        'user-agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36'
      }
    });

    if (!process.isFinished) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      continue;
    } else {
      return {
        url,
        error: {
          text: process.errorText,
          code: process.errorCode
        },
        copiedFilesAmount: process.copiedFilesAmount,
        downloadUrl: `https://copier.saveweb2zip.com/api/downloadArchive/${process.md5}`
      };
    }
  }
}
// ============ ØªÙƒÙ…Ù„Ù‡ ===============
async function yta(link) {
  const format = "mp3";
  const apiBase = "https://media.savetube.me/api";
  const apiCDN = "/random-cdn";
  const apiInfo = "/v2/info";
  const apiDownload = "/download";

  const decryptData = async (enc) => {
    try {
      const key = Buffer.from('C5D58EF67A7584E4A29F6C35BBC4EB12', 'hex');
      const data = Buffer.from(enc, 'base64');
      const iv = data.slice(0, 16);
      const content = data.slice(16);
      const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);
      let decrypted = decipher.update(content);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return JSON.parse(decrypted.toString());
    } catch {
      return null;
    }
  };

  const request = async (endpoint, data = {}, method = 'post') => {
    try {
      const { data: response } = await axios({
        method,
        url: `${endpoint.startsWith('http') ? '' : apiBase}${endpoint}`,
        data: method === 'post' ? data : undefined,
        params: method === 'get' ? data : undefined,
        headers: {
          'accept': '*/*',
          'content-type': 'application/json',
          'origin': 'https://yt.savetube.me',
          'referer': 'https://yt.savetube.me/',
          'user-agent': 'Postify/1.0.0'
        }
      });
      return { status: true, data: response };
    } catch (error) {
      return { status: false, error: error.message };
    }
  };

  const youtubeID = link.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/))([a-zA-Z0-9_-]{11})/);
  if (!youtubeID) return { status: false, error: "ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ ID Ø§Ù„ÙÙŠØ¯ÙŠÙˆ." };

  try {
    const cdnRes = await request(apiCDN, {}, 'get');
    if (!cdnRes.status) return cdnRes;
    const cdn = cdnRes.data.cdn;
    const infoRes = await request(`https://${cdn}${apiInfo}`, { url: `https://www.youtube.com/watch?v=${youtubeID[1]}` });
    if (!infoRes.status) return infoRes;
    const decrypted = await decryptData(infoRes.data.data);
    if (!decrypted) return { status: false, error: "ÙØ´Ù„ ÙÙŠ ÙÙƒ ØªØ´ÙÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ." };

    const downloadRes = await request(`https://${cdn}${apiDownload}`, { id: youtubeID[1], downloadType: 'audio', quality: '128', key: decrypted.key });
    if (!downloadRes.status || !downloadRes.data.data.downloadUrl) return { status: false, error: "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· ØªÙ†Ø²ÙŠÙ„ ØµØ§Ù„Ø­." };

    return { status: true, result: { title: decrypted.title || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ", type: 'audio', format, download: downloadRes.data.data.downloadUrl } };
  } catch (error) {
    return { status: false, error: error.message };
  }
}
// --- Ø¯Ø§Ù„Ø© flux ---
async function flux(options) {
  try {
    options = {
      prompt: options?.prompt,
      seed: options?.seed || Math.floor(Math.random() * 2147483647) + 1,
      random_seed: options?.random_seed ?? true,
      width: options?.width ?? 512,
      height: options?.height ?? 512,
      steps: options?.steps ?? 8,
    };

    if (!options.prompt) return { status: false, message: "undefined reading prompt!" };

    const session_hash = randomString(11);

    const joinResponse = await fetch(
      "https://black-forest-labs-flux-1-schnell.hf.space/queue/join",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          data: [
            options.prompt,
            options.seed,
            options.random_seed,
            options.width,
            options.height,
            options.steps,
          ],
          event_data: null,
          fn_index: 2,
          trigger_id: 5,
          session_hash,
        }),
      }
    );

    if (!joinResponse.ok) throw new Error("Failed to join queue");

    const dataResponse = await fetch(
      `https://black-forest-labs-flux-1-schnell.hf.space/queue/data?session_hash=${session_hash}`
    );

    if (!dataResponse.ok) throw new Error("Failed to retrieve data");

    const rawData = await dataResponse.text();
    const lines = rawData.split("\n");
    const jsonObjects = [];

    for (let line of lines) {
      if (line.startsWith("data: ")) {
        try {
          jsonObjects.push(JSON.parse(line.slice(6).trim()));
        } catch (err) {
          console.error("Failed to parse JSON from Flux API");
        }
      }
    }

    const result = jsonObjects.find((d) => d.msg === "process_completed") || {};
    if (!result?.success) return { status: false, message: result };

    const images = result.output.data
      .filter((d) => typeof d === "object")
      .map((d) => d.url);

    return { status: true, data: { images } };
  } catch (e) {
    return { status: false, message: e.message };
  }
}

// --- Ø¯Ø§Ù„Ø© ØªÙˆÙ„ÙŠØ¯ Ø³Ù„Ø³Ù„Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ---
function randomString(length) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
// ======== Ø§Ù„Ø§Ø¹Ù„Ø§Ù… ===============

bot.command("blur", async (ctx) => {
  const chatId = ctx.chat.id;
  const userId = ctx.message.reply_to_message
    ? ctx.message.reply_to_message.from.id
    : ctx.from.id;

  try {
    // ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„
    const photos = await ctx.telegram.getUserProfilePhotos(userId, { limit: 1 });
    if (!photos.total_count) {
      return ctx.reply("âŒ Ù…ÙÙŠØ´ ØµÙˆØ±Ø© Ø¨Ø±ÙˆÙØ§ÙŠÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ø¹Ø¶Ùˆ Ø¯Ù‡");
    }

    const fileId = photos.photos[0][0].file_id;
    const file = await ctx.telegram.getFile(fileId);
    const avatarUrl = `https://api.telegram.org/file/bot${bot.telegram.token}/${file.file_path}`;

    // API Ø¨Ù„ÙˆØ±
    const apiUrl = `https://some-random-api.com/canvas/blur?avatar=${encodeURIComponent(
      avatarUrl
    )}`;

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ù€ API
    const res = await fetch(apiUrl);
    const buffer = await res.buffer();

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    await ctx.replyWithPhoto({ source: buffer }, {
      caption: `â›§ï¸™ØªÙ€Ù… Ø¶Ù€Ø¨Ù€Ø· Ø§Ù„Ù€ØµÙ€ÙˆØ±Ø© Ø¨Ù€ØªÙ€Ø£Ø«ÙŠÙ€Ø± â˜ ï¸\n> ğ“ğ„ğ‘ğğ ğ’ğğ€ğŒ ğŸ©¸`,
      reply_to_message_id: ctx.message.message_id,
    });
  } catch (err) {
    console.error(err);
    ctx.reply("ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©.");
  }
});

bot.command('flix', async (ctx) => {
  const text = ctx.message.text.split(' ').slice(1).join(' ');
  if (!text) return ctx.reply(`â€¢ Ø²ÙŠ ÙƒØ¯Ù‡ ÙŠ Ø®Ø§Ù„ : /ÙÙ„ÙƒØ³
  [Ø§Ù„Ù†Øµ]`, { parse_mode: 'Markdown' });

  await ctx.reply("ğŸ©¸ Ø§Ù„ØµØ¨Ø± ÙŠ Ø®Ø§Ù„ØŒ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±...");

  try {
    const data = await flux({ prompt: text });

    if (!data.status || !data.data.images.length) {
      return ctx.reply("âŒ Ù„Ù… ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠ ØµÙˆØ±ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ù‹Ø§.");
    }

    for (let i of data.data.images) {
      try {
        await ctx.replyWithPhoto(i);
      } catch (err) {
        console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©:", err.message);
      }
    }
  } catch (err) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Flux API:", err.message);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±ØŒ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.");
  }
});
//==========
bot.command('flag1', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„Ø£Ø±Ø¯Ù†\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”", { parse_mode: 'Markdown' });

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    
    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· ÙƒÙ€ buffer
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://files.catbox.moe/eb7wk8.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) }, {
      caption: "â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•´ï¸ï¹â€¢ â”â”€â”€â”€ â‹… \ná¯“ ğ…¦ğ…§ğ‘²ğ‘¨ğ‘° ğ‘©ğ‘¶ğ‘»Ë–ğ–¥”\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ”¥ï¹â€¢ â”â”€â”€â”€ â‹… â”",
      parse_mode: 'Markdown'
    });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});

bot.command('flag2', async (ctx) => {
    try {
        const photo = ctx.message.reply_to_message?.photo?.[ctx.message.reply_to_message.photo.length - 1];
        if (!photo) return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠÙ‡\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”");

        ctx.reply("ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...");

        const fileLink = await ctx.telegram.getFileLink(photo.file_id);
        const userImage = await Jimp.read(fileLink.href);
        const background = await Jimp.read("https://files.catbox.moe/6xjh4c.png");

        let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
        userImage.cover(circleSize, circleSize);
        userImage.circle();

        let posX = Math.floor((background.bitmap.width - circleSize) / 2);
        let posY = Math.floor((background.bitmap.height - circleSize) / 2);

        background.composite(userImage, posX, posY);

        const filePath = "./output_sa.png";
        await background.writeAsync(filePath);

        await ctx.replyWithPhoto({ source: fs.createReadStream(filePath) }, { caption: "ğŸ‡¸ğŸ‡¦ Ø¥Ø·Ø§Ø± Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©" });
        await fs.promises.unlink(filePath);

    } catch (err) {
        console.error(err);
        ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©.");
    }
});


// Ø£Ù…Ø± /owner
bot.command("owner", async (ctx) => {
  try {


    // ØµÙˆØ±Ø©
    await ctx.replyWithPhoto(
      { source: "./w.jpg" },
      {
        caption: "Developer",
        parse_mode: "Markdown",
        reply_markup: {
          inline_keyboard: [
            [
              { text: "â¦• TERBO â¦–", url: "https://t.me/terbo_001" },
              { text: "â¦• SAMKA â¦–", url: "https://t.me/SAMKA888Xx" }
            ],
            [
              { text: "â¦• MODY â¦–", url: "https://t.me/Z_MODY" },
              { text: "â¦• MALIK â¦–", url: "https://t.me/malik888Xx" }
            ]
          ]
        }
      }
    );
  } catch (err) {
    console.error(err);
    ctx.reply("Ø­ØµÙ„ Ø®Ø·Ø£ âš ï¸");
  }
});

bot.command('flag3', async (ctx) => {
    try {
        const photo = ctx.message.reply_to_message?.photo?.[ctx.message.reply_to_message.photo.length - 1];
        if (!photo) return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„Ù…ØºØ±Ø¨\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”");

        ctx.reply("ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...");

        const fileLink = await ctx.telegram.getFileLink(photo.file_id);
        const userImage = await Jimp.read(fileLink.href);
        const background = await Jimp.read("https://files.catbox.moe/l0893d.jpg");

        let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
        userImage.cover(circleSize, circleSize);
        userImage.circle();

        let posX = Math.floor((background.bitmap.width - circleSize) / 2);
        let posY = Math.floor((background.bitmap.height - circleSize) / 2);

        background.composite(userImage, posX, posY);

        const filePath = "./output_ma.png";
        await background.writeAsync(filePath);

        await ctx.replyWithPhoto({ source: fs.createReadStream(filePath) }, { caption: "ğŸ‡²ğŸ‡¦ Ø¥Ø·Ø§Ø± Ø§Ù„Ù…ØºØ±Ø¨" });
        await fs.promises.unlink(filePath);

    } catch (err) {
        console.error(err);
        ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©.");
    }
});

    bot.command('flag4', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„Ø³ÙˆØ¯Ø§Ù†\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”");

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://files.catbox.moe/7afwwe.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});
bot.command('flag5', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„Ø§Ù…Ø§Ø±Ø§Øª\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”");

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://files.catbox.moe/ipaq1h.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});
bot.command('flag6', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„ÙŠÙ…ÙŠÙ†\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”");

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://files.catbox.moe/mh6jtt.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});
bot.command('flag7', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) 
      return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø³ÙˆØ±ÙŠØ§ \nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”", { parse_mode: 'Markdown' });

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://files.catbox.moe/iti79i.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) }, {
      caption: "â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± \nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”",
      parse_mode: 'Markdown'
    });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});
bot.command('flag8', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) 
      return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± ÙÙ„Ø³Ø·ÙŠÙ† \nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”", { parse_mode: 'Markdown' });

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://files.catbox.moe/786f2j.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) }, {
      caption: "â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\ná¯“ ğ…¦ğ…§ğ‘²ğ‘¨ğ‘° ğ‘©ğ‘¶ğ‘»Ë–ğ–¥”\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹ â”â”€â”€â”€ â‹… â”",
      parse_mode: 'Markdown'
    });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});
bot.command('flag9', async (ctx) => {
  try {
    let message = ctx.message.reply_to_message || ctx.message;
    if (!message.photo) 
      return ctx.reply("â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ù…ØµØ± ğŸ‡ªğŸ‡¬\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹ â”â”€â”€â”€ â‹… â”", { parse_mode: 'Markdown' });

    const fileId = message.photo[message.photo.length - 1].file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();

    let userImage = await Jimp.read(buffer);
    let background = await Jimp.read("https://d.uguu.se/mpMvoTFB.jpg");

    let circleSize = Math.floor(Math.min(background.bitmap.width, background.bitmap.height) * 0.9);
    userImage.cover(circleSize, circleSize);
    userImage.circle();

    let posX = Math.floor((background.bitmap.width - circleSize) / 2);
    let posY = Math.floor((background.bitmap.height - circleSize) / 2);

    background.composite(userImage, posX, posY);

    const filePath = "./output_image_with_background.png";
    await background.writeAsync(filePath);

    await ctx.replyWithPhoto({ source: fs.readFileSync(filePath) }, {
      caption: "â” â‹… â”€â”€â”€â” â€¢ï¹ğŸ•·ï¸ï¹â€¢ â”â”€â”€â”€ â‹… â”\nØ§Ù„Ù…Ø±Ø¬Ùˆ Ø¹Ù…Ù„ Ø±ÙŠØ¨Ù„ÙŠØª Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ±ÙŠØ¯ Ø¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¥Ø·Ø§Ø± Ø§Ù„Ø£Ø±Ø¯Ù†\nâ” â‹… â”€â”€â”€â” â€¢ï¹ğŸ©¸ï¹â€¢ â”â”€â”€â”€ â‹… â”",
      parse_mode: 'Markdown'
    });

    await fs.promises.unlink(filePath);

  } catch (err) {
    console.error(err);
    ctx.reply("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©.");
  }
});
//=============================

bot.command(["report"], async (ctx) => {
  const text = ctx.message.text.split(" ").slice(1).join(" ");

  if (!text) {
    return ctx.reply(
      `ğŸ©¸ Ø§ÙƒØªØ¨ Ø§Ù„Ø®Ø·Ø£ Ø£Ùˆ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹ Ø³Ø¨Ø¨ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©\n\nÙ…Ø«Ø§Ù„: /ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù„Ø§ØµÙ‚ Ù…Ø´ Ø´ØºØ§Ù„`,
      { parse_mode: "Markdown" }
    );
  }

  if (text.length < 15) {
    return ctx.reply(`ğŸ§šğŸ¼â€â™‚ï¸ ã€ Ù„Ø§Ø²Ù… Ø¹Ù„Ø´Ø§Ù† ØªÙ‚Ø¯Ø± ØªØ¨Ø¹Øª Ø§Ù„Ø¨Ù„Ø§Øº ØªÙƒÙˆÙ† Ù…Ø¹Ø¯ÙŠ Ø§Ù„15 Ø­Ø±Ù ã€`);
  }

  if (text.length > 1000) {
    return ctx.reply(`ğŸ§šğŸ¼â€â™‚ï¸ ã€ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù‡Ùˆ 1000 Ø­Ø±Ù Ø¹Ø´Ø§Ù† ØªØ¹Ù…Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ã€`);
  }

  // Ù†Øµ Ø§Ù„Ø¨Ù„Ø§Øº
  let report = `â”â•¼â•¾â•¼â§¼â§¼â§¼ ã€ Ø¨Ù„Ø§Øº Ø¬Ø¯ÙŠØ¯ ã€ â§½â§½â§½â•¼â•¼â•¼â”“
â•â€¢ ã€ Ø§Ù„Ù…Ø±Ø³Ù„ ã€: @${ctx.from.username || ctx.from.id}
â•â€¢ ã€ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ã€: ${text}
â”—â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼â•¼`;

  // ØªØ£ÙƒÙŠØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
  await ctx.reply(
    `ğŸ§šğŸ¼â€â™‚ï¸ ã€ ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ù„Ø§Øº Ù„Ù„Ù…Ø·ÙˆØ±ØŒ Ù‡ÙŠØªÙ… Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡ Ù‚Ø±ÙŠØ¨Ù‹Ø§ØŒ Ù„Ùˆ Ø§Ù„Ø¨Ù„Ø§Øº Ù…Ø´ Ø­Ù‚ÙŠÙ‚ÙŠ Ù‡ÙŠØªØ¬Ø§Ù‡Ù„ÙˆÙ‡ ã€`
  );

  // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ù„Ø§Øº Ù„ÙŠÙƒ (Ø§Ù„Ù…Ø·ÙˆØ±)
  await bot.telegram.sendMessage(OWNER_ID, report, { parse_mode: "Markdown" });
});
//==============================

bot.command("saf", async (ctx) => {
  try {
    // Ø·Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† API
    const res = await fetch(
      "https://the-end-api.vercel.app/home/sections/Tools/api/api/safeum/accounts?apikey=Emam-4k8j2d9f7x"
    );

    if (!res.ok) throw new Error("ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù€ API");

    const json = await res.json();

    if (!json.status || !Array.isArray(json.accounts)) {
      return ctx.reply("âŒ ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª.");
    }

    const list = json.accounts
      .map((acc, i) => {
        const [email, password] = acc.split(":");
        return `${i + 1}. ğŸ“§ Email: ${email}\nğŸ”‘ Pass: ${password}`;
      })
      .join("\n\n");

    const message = `SAFEUM ACCOUNTS\nğŸ“¦ Total: ${json.count}\nğŸ§¾ Remaining: ${json.remaining}\n\n${list}`;

    // Ù…Ø¹Ø±Ù Ø§Ù„Ù‚Ù†Ø§Ø©
    const channelId = "@spam1379"; // ğŸ”´ ØºÙŠØ±Ù‡ Ø¨Ø§Ù„Ù€ chat id Ø£Ùˆ ÙŠÙˆØ²Ø± Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨ØªØ§Ø¹ØªÙƒ

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù‚Ù†Ø§Ø©
    await ctx.telegram.sendMessage(channelId, message, { parse_mode: "Markdown" });

    // Ø±Ø¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await ctx.reply("ğŸ©¸ ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø¥Ù„Ù‰ Ù‚Ù†Ø§Ø© SAFEUM.");
  } catch (err) {
    console.error("API Error:", err);
    await ctx.reply("âŒ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§ØªØŒ Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ.");
  }
});
//=============
	bot.command(['saveweb', 'web2zip', 'Ø­ÙØ¸-Ù…ÙˆÙ‚Ø¹', 'ÙˆÙŠØ¨', 'Ø¹ÙŠÙŠ'], async (ctx) => {
  const args = ctx.message.text.split(' ').slice(1);
  const commandName = ctx.message.text.split(' ')[0].replace('/', '').toLowerCase();
  const isArabicCommand = ['Ø¹ÙŠÙŠ','ÙˆÙŠØ¨','Ø­ÙØ¸-Ù…ÙˆÙ‚Ø¹'].includes(commandName);

  const usageMessage = `
ğŸ§ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
â–¢ ${commandName} <Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ÙˆÙ‚Ø¹>
â–¢ Ù…Ø«Ø§Ù„: ${commandName} https://google.com
`;

  if (!args[0]) {
    return ctx.reply(isArabicCommand 
      ? `ğŸ©¸ ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ÙˆÙ‚Ø¹!\n\n${usageMessage}` 
      : `ğŸ©¸ Please enter a website URL first!\n\n${usageMessage}`
    );
  }

  ctx.reply(isArabicCommand ? 'ğŸ©¸ Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„Ù…ÙˆÙ‚Ø¹...' : 'ğŸ©¸ Saving website...');

  try {
    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØ·Ù„Ø¨Ù‡ ÙƒÙ€ zip Ù…Ø¨Ø§Ø´Ø±
    const result = await saveweb2zip(args[0], {
      format: "zip",            // âš¡ Ù‡Ù†Ø§ Ù†Ø®Ù„ÙŠ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ zip
      renameAssets: true,
      saveStructure: false,
      alternativeAlgorithm: false,
      mobileVersion: false
    });

    // Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø¨ØµÙŠØºØ© zip
    await ctx.replyWithDocument(
      { url: result.downloadUrl, filename: "website.zip" },
      {
        caption: `ğŸ©¸ ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØ¶ØºØ·Ù‡ Ø¨Ù†Ø¬Ø§Ø­!\nâ–¢ Ø§Ù„Ø±Ø§Ø¨Ø·: ${args[0]}\nâ–¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª: ${result.copiedFilesAmount}\nğŸ©¸ Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ø³Ø¨Ø§Ù… Ø¨ÙˆØª`,
        parse_mode: "Markdown"
      }
    );

  } catch (err) {
    ctx.reply(isArabicCommand 
      ? `âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„Ù…ÙˆÙ‚Ø¹!\nâ–¢ Ø§Ù„ØªÙØ§ØµÙŠÙ„: ${err.message}` 
      : `âŒ Failed to save the website!\nâ–¢ Details: ${err.message}`
    );
  }
});
// =================== YouTube =====
const headers = {
  authority: "ttsave.app",
  accept: "application/json, text/plain, */*",
  origin: "https://ttsave.app",
  referer: "https://ttsave.app/en",
  "user-agent": "Postify/1.0.0",
};

const ttsave = {
  submit: async function (url, referer) {
    const headerx = { ...headers, referer };
    const data = { query: url, language_id: "1" };
    return axios.post("https://ttsave.app/download", data, { headers: headerx });
  },

  parse: function ($) {
    const uniqueId = $("#unique-id").val();
    const nickname = $("h2.font-extrabold").text();
    const profilePic = $("img.rounded-full").attr("src");
    const username = $("a.font-extrabold.text-blue-400").text();
    const description = $("p.text-gray-600").text();

    const dlink = {
      nowm: $("a.w-full.text-white.font-bold").first().attr("href"),
      wm: $("a.w-full.text-white.font-bold").eq(1).attr("href"),
      audio: $("a[type='audio']").attr("href"),
      profilePic: $("a[type='profile']").attr("href"),
      cover: $("a[type='cover']").attr("href"),
    };

    const slides = $("a[type='slide']")
      .map((i, el) => ({ number: i + 1, url: $(el).attr("href") }))
      .get();

    const songTitle = $(".flex.flex-row.items-center.justify-center.gap-1.mt-5")
      .find("span.text-gray-500")
      .text()
      .trim();

    return { uniqueId, nickname, profilePic, username, description, dlink, songTitle, slides };
  },

  video: async function (link) {
    const response = await this.submit(link, "https://ttsave.app/en");
    const $ = cheerio.load(response.data);
    const result = this.parse($);

    if (result.slides && result.slides.length > 0) return { type: "slide", ...result };
    return { type: "video", ...result, videoInfo: { nowm: result.dlink.nowm, wm: result.dlink.wm }, audioUrl: result.dlink.audio };
  },
};

// ---- Ø¯Ø¹Ù… ttsave ----

// ================ TikTok ===================
bot.command('tiktok', async (ctx) => {
  const text = ctx.message.text.split(' ').slice(1).join(' ');
  if (!text) return ctx.reply(`â— ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· ØªÙŠÙƒ ØªÙˆÙƒ:\nÙ…Ø«Ø§Ù„: /ØªÙŠÙƒ https://vm.tiktok.com/ZM686Q4ER/`);

  try {
    const videoResult = await ttsave.video(text);
    const { type, nickname, username, songTitle, description, videoInfo, slides, audioUrl } = videoResult;

    let message = `
ğŸµ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: ${songTitle || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
ğŸ‘¤ Ø§Ù„ØµØ§Ù†Ø¹: ${nickname || username || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"}
âœï¸ Ø§Ù„ÙˆØµÙ: ${description || "Ø¨Ø¯ÙˆÙ† ÙˆØµÙ"}
`.trim();

    if (type === "slide") {
      message += "\nğŸ“· Ø§Ù„Ù†ÙˆØ¹: Ø¹Ø±Ø¶ Ø´Ø±Ø§Ø¦Ø­ (ØµÙˆØ±)";
      await ctx.reply(message);

      for (let slide of slides) {
        await ctx.replyWithPhoto(slide.url, { caption: `Slide ${slide.number}` });
      }
    } else if (type === "video") {
      message += "\nğŸ¥ Ø§Ù„Ù†ÙˆØ¹: ÙÙŠØ¯ÙŠÙˆ";
      if (videoInfo.nowm) {
        await ctx.replyWithVideo(videoInfo.nowm, {
          caption: message,
          parse_mode: 'Markdown',
          ...Markup.inlineKeyboard([
            [Markup.button.url('ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª ğŸ§', audioUrl || videoInfo.nowm)]
          ])
        });
      } else {
        await ctx.reply("â— ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¯ÙˆÙ† Ø¹Ù„Ø§Ù…Ø© Ù…Ø§Ø¦ÙŠØ©.");
      }
    }

    if (audioUrl) {
      await ctx.replyWithAudio(audioUrl);
    }
  } catch (error) {
    console.error(error);
    await ctx.reply("â— Ø­Ø¯Ø« Ø®Ø·Ø£ Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø±Ø§Ø¨Ø·. ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ø§Ø¨Ø· ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
  }
});

const replies = [
  { regex: /^ÙŠØ±ÙˆØ­ÙŠ$/i, text: "â¤ï¸ Ù‚Ù„Ø¨ Ø±ÙˆØ­Ùƒ ÙŠØ§ Ø¹Ø³Ù„" },
  { regex: /^ØµÙ„ÙŠ Ø¹Ù„ÙŠ Ø§Ù„Ù†Ø¨ÙŠ|ØµÙ„ÙŠ Ø¹ Ø§Ù„Ù†Ø¨ÙŠ$/i, text: "ğŸ•Œ Ø¹Ù„ÙŠÙ‡ Ø§ÙØ¶Ù„ Ø§Ù„ØµÙ„Ø§Ø© ÙˆØ§Ù„Ø³Ù„Ø§Ù…" },
  { regex: /^Ø¹Ø§Ù…Ù„ Ø§ÙŠ|Ø§Ø²ÙŠÙƒ|Ø§Ø®Ø¨Ø§Ø±Ùƒ|Ø­Ø§Ù„Ùƒ$/i, text: "ğŸ‘Œ ØªÙ…Ø§Ù… Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ ÙŠØ§ Ù‚Ù„Ø¨ÙŠ" },
  { regex: /^Ø§Ù†Ø§ Ù…Ø®Ù†ÙˆÙ‚|Ù…Ø®Ù†ÙˆÙ‚|Ù…Ø®Ù†ÙˆÙ‚Ù‡$/i, text: "ğŸ˜¢ ØªØ¹Ø§Ù„Ù‰ Ø§Ø­Ø¶Ù†Ùƒ ÙˆØ®Ù„Ø§Øµ" },
  { regex: /^Ø¨Ù…ÙˆØª ÙÙŠÙƒ$/i, text: "ğŸ¥¹ Ø¨Ø¹Ø´Ù‚Ùƒ Ù…ÙˆØª" },
  { regex: /^ÙƒÙ„Ù…ÙˆÙ†ÙŠ$/i, text: "ğŸ˜ ÙƒÙ„Ù…Ùƒ Ø¹ÙØ±ÙŠØª Ø§Ø­Ù†Ø§ Ù…Ø§Ù„Ù†Ø§" },
  { regex: /^Ø¨Ø¯ÙŠ Ø§ØªØ¬ÙˆØ²Ùƒ|ØªØªØ¬ÙˆØ²Ù†ÙŠ|Ø§ØªØ¬ÙˆØ²Ù†ÙŠ$/i, text: "ğŸ˜ Ù…ÙˆØ§ÙÙ‚ ÙˆØ¨Ø´Ø¯Ù‡" },
  { regex: /^Ù…Ø­Ø­|Ø§Ù…ÙˆØ§Ø­$/i, text: "ğŸ˜˜ Ø¨ÙˆØ³Ù‡ Ù…Ø³ÙƒØ±Ù‡" },
  { regex: /^ÙƒÙˆØªÙŠ$/i, text: "ğŸ¥° Ù…ÙˆØªÙŠ Ø¨ÙˆØªÙŠ" },
  { regex: /^ÙˆØ­Ø´Ù†ÙŠ|ÙˆØ­Ø´ØªÙ†ÙŠ$/i, text: "ğŸ’• Ø§ÙƒØªØ± ÙŠØ§ Ø±ÙˆØ­ Ù‚Ù„Ø¨ÙŠ" },
  { regex: /^Ø¨Ø­Ø¨Ùƒ$/i, text: "â¤ï¸ ÙˆØ§Ù†Ø§ ÙƒÙ…Ø§Ù† Ø¨Ù…ÙˆØª ÙÙŠÙƒ" },
  { regex: /^Ù…ÙˆØªÙÙŠÙ‚$/i, text: "ğŸ˜¹ Ø¨Ø¹Ø´Ù‚ Ø§Ù„ØªØ±Ø§Ø¨ Ø§Ù„Ù„ÙŠ Ø¨ØªÙ…Ø´ÙŠ Ø¹Ù„ÙŠÙ‡" },
  { regex: /^Ø­Ø±Ø§Ù…ÙŠ|Ø³Ø§Ø±Ù‚$/i, text: "ğŸ¤¦ Ø§Ù†Øª Ø¹Ø¨ÙŠØ· ÙˆÙ„Ø§ Ø§ÙŠÙ‡ØŸ Ø¨ØªÙ‚ÙˆÙ„ Ø§ÙŠ ÙƒÙ„Ø§Ù…" },
  { regex: /^Ù‡Ø§ÙŠ|Ù‡Ø§Ù„Ùˆ|Ø§Ù‡Ù„Ø§$/i, text: "ğŸ‘‹ Ù‡Ø§ÙŠ ÙŠØ±ÙˆØ­ÙŠ" },
  { regex: /^Ø¨ÙˆØ³Ù‡|Ù‡Ø§Øª Ø¨ÙˆØ³Ù‡$/i, text: "ğŸ˜˜ Ø§Ù…ÙˆØ§Ø§Ø§Ø§Ø­" },
  { regex: /^Ø­Ø¨Ù†ÙŠ|Ø­Ø¨ÙˆÙ†ÙŠ$/i, text: "ğŸ’– Ø¨Ø¹Ø´Ù‚Ùƒ Ù…Ø´ Ø¨Ø­Ø¨Ùƒ Ø¨Ø³" },
  { regex: /^Ø¨ØªØ¹Ø´Ù‚Ù†ÙŠ$/i, text: "ğŸ¥‚ Ø§ÙˆÙŠ ÙƒÙ…Ø§Ù†" },
  { regex: /^Ø¨Ø¹Ø´Ù‚Ùƒ$/i, text: "ğŸ¥‚ Ø¨Ù…ÙˆØª ÙÙŠÙƒ/ÙŠ" },
  { regex: /^Ù…ØªÙŠØ¬ÙŠ|Ù…Ø´Ù‡ØªÙŠØ¬ÙŠ$/i, text: "ğŸ¤ Ù…Ø´Ù‡Ø±ÙˆØ­" },
  { regex: /^ØªØµØ¨Ø­ Ø¹Ù„ÙŠ Ø®ÙŠØ±|ØªØµØ¨Ø­ÙˆØ§ Ø¹Ù„ÙŠ Ø®ÙŠØ±$/i, text: "ğŸŒ™ ÙˆØ§Ù†Øª Ù…Ù† Ø§Ù‡Ù„ Ø§Ù„Ø®ÙŠØ±" },
  { regex: /^ØµØ¨Ø§Ø­Ùˆ|ØµØ¨Ø§Ø­$/i, text: " ØµØ¨Ø§Ø­ Ø§Ù„Ù†ÙˆØ± ğŸ˜š" },
  { regex: /^Ø±Ø¨Ù†Ø§ ÙŠØ³Ù…Ø­Ùƒ$/i, text: "Ø§Ù†Øª Ø®Ø¯Øª Ø­Ø³Ù†Ø§Øª Ùˆ Ù‡ÙˆØ§ Ø®Ø¯ ÙØ·ÙŠØ²Ùˆ Ø¨Ø§Ù„Ø¬Ø§Ù…Ø¯ ğŸ˜­ğŸ˜‚" },
  { regex: /^Ø²Ø­Ù„Ø§Ù†|Ø²Ø¹Ù„ØªÙ†ÙŠ|Ø²Ø¹Ù„Ø§Ù†|Ø²Ø¹Ù„Ø§Ù†Ù‡|Ø³Ø­Ù„Ø§Ù†Ù‡$/i, text: "ğŸ™‚ Ø­Ù‚Ùƒ Ø¹Ù„ÙŠØ§" },
  { regex: /^Ø­Ø¨Ù‚|Ø¨Ø­Ø¨$/i, text: "ğŸŒš Ø¨Ù…ÙˆØª ÙÙŠÙƒ" },
  { regex: /^ÙŠØºÙˆØªÙŠ$/i, text: "Ø¨Ø­Ø¨Ùƒ Ø·ÙŠØ¨ğŸ§š" },
  // ÙÙ„ÙÙ„Ù‡ / Ø´ØªØ§ÙŠÙ… Ø²ÙŠØ§Ø¯Ø©
  { regex: /^ÙŠØ§ ØºØ¨ÙŠ|ÙŠØ§ Ø­Ù…Ø§Ø±|ÙŠØ§ Ù…ØªÙ†Ø§Ùƒ|ÙŠ ØºØ¨ÙŠ|ÙŠØºØ¨ÙŠ|ÙŠ Ø­Ù…Ø§Ø±|ÙŠØ­Ù…Ø§Ø±|Ø¨ Ù…ØªÙ†Ø§Ùƒ|ÙŠÙ…ØªÙ†Ø§Ùƒ$/i, text: "ÙƒØ³Ù…Ùƒ Ø§ÙˆÙŠ Ø§ÙˆÙŠ ÙˆÙ„Ø§ Ù†Øµ Ù†Øµ" },
  { regex: /^ÙŠØ§ Ø­Ù…Ø§Ø±$/i, text: "ğŸ« Ø§Ù†Øª Ø§Ù„Ø­Ù…Ø§Ø± ÙˆØ§Ù†Øª Ø§Ù„Ù‚Ù…Ø± ÙƒÙ…Ø§Ù†" },
  { regex: /^ÙŠØ§ ÙƒÙ„Ø¨$/i, text: "ğŸ¶ Ø§Ù„ÙƒÙ„Ø¨ Ø§ÙˆÙÙŠ Ù…Ù†Ùƒ" },
  { regex: /^ÙŠØ§ Ø§Ø¨Ù†$/i, text: "ğŸ¤ Ù‚ÙˆÙ… ÙŠÙ„Ø§ Ù…Ø´ Ù†Ø§Ù‚ØµÙŠÙ† Ù‚Ù„Ø© Ø§Ø¯Ø¨" },
  { regex: /^ÙŠÙ„Ø¹Ù† Ø§Ø¨ÙˆÙƒÙ…$/i, text: "ğŸ˜¹ ÙŠÙ„Ø¹Ù† Ø§Ø¨Ùˆ Ø§Ù„Ù„ÙŠ ÙŠØ²Ø¹Ù„Ù†Ø§" },
  { regex: /^ÙŠØ¹Ø±Øµ$/i, text: "ÙƒÙ†Øª Ø¨Ø¹Ø±Øµ Ø§Ù†Ø§ Ø¹Ù„ÙŠ Ø§Ù…Ùƒ ØŸ" },
  { regex: /^ÙÙ„ÙÙ„Ù‡$/i, text: "ğŸŒ¶ï¸ Ø§Ù„Ù†Ø§Ø± Ù…ÙˆÙ„Ø¹Ù‡ ÙŠØ§ ÙÙ„ÙÙ„" },
  { regex: /^Ø¨ÙˆØª$/i, text: "ğŸ¤– Ù†Ø¹Ù… ÙŠØ§ Ø­Ø¨" }
];

// Ù‡Ø§Ù†Ø¯Ù„Ø± Ù„Ù„Ø±Ø³Ø§Ø¦Ù„
bot.on("text", async (ctx) => {
  const text = ctx.message.text;
  for (const r of replies) {
    if (r.regex.test(text)) {
      return ctx.reply(r.text, { reply_to_message_id: ctx.message.message_id });
    }
  }
});

// =================== Instagram ==============

// Ø±ÙŠØ¬ÙƒØ³ Ù„Ù„Ø±ÙˆØ§Ø¨Ø· (ÙˆØ§ØªØ³Ø§Ø¨ + ØªÙ„ÙŠØ¬Ø±Ø§Ù…)
const linkRegex = /(chat\.whatsapp\.com\/[0-9A-Za-z]{20,}|whatsapp\.com\/channel\/[0-9A-Za-z]{20,}|t\.me\/[A-Za-z0-9_]+|telegram\.me\/[A-Za-z0-9_]+)/i;

// Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª ØªØ­Ø°ÙŠØ±Ø§Øª
let warns = {};

bot.on("message", async (ctx) => {
  const chatId = ctx.chat.id;
  const userId = ctx.from.id;
  const text = ctx.message.text || "";

  // Ù†ØªØ£ÙƒØ¯ Ø§Ù†Ù‡ Ø¬Ø±ÙˆØ¨
  if (ctx.chat.type !== "supergroup" && ctx.chat.type !== "group") return;

  const isLink = linkRegex.exec(text);

  if (isLink) {
    try {
      // Ø¬ÙŠØ¨ Ø§Ù„Ø§Ø¯Ù…Ù†Ø²
      const admins = await ctx.getChatAdministrators();
      const isAdmin = admins.some((a) => a.user.id === userId);

      if (isAdmin) {
        return ctx.reply("ğŸ©¸ Ø§Ù†Øª Ø§Ø¯Ù…Ù† Ù…Ø´ Ù‡Ù…Ø³Ùƒ Ø§Ù„ÙŠÙ†ÙƒØŒ Ø¨Ø³ Ø£ÙŠ Ø­Ø¯ ØªØ§Ù†ÙŠ Ù‡ÙŠØªÙ…Ø³Ø­ Ø§Ù„Ù„ÙŠÙ†Ùƒ ÙˆÙŠØªØ­Ø³Ø¨Ù„Ù‡ ØªØ­Ø°ÙŠØ±");
      }

      if (!isAdmin) {
        // Ø²ÙŠØ§Ø¯Ù‡ ØªØ­Ø°ÙŠØ±
        warns[chatId] ||= {};
        warns[chatId][userId] ||= 0;
        warns[chatId][userId]++;

        const warnCount = warns[chatId][userId];

        // Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙˆØ±Ø§
        await ctx.deleteMessage(ctx.message.message_id);

        // Ø§Ø±Ø³Ø§Ù„ ØªØ­Ø°ÙŠØ±
        await ctx.replyWithHTML(
          `â¬£â”â”â”ã€˜ğŸ¥· Ù…Ø§Ù†Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ğŸ©¸ã€™â”â”
ğŸ©¸â”‡ ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø±Ø§Ø¨Ø·
ââŠ¹â”â”â”â”ã€SPAMã€â”â”â”âŠ¹â
ğŸ©¸â”‡ <a href="tg://user?id=${userId}">Ù…Ù…Ù†ÙˆØ¹ ÙŠØ³Ø·Ø§</a>
ââŠ¹â”â”â”â”ã€SPAMã€â”â”â”âŠ¹â
ğŸ©¸â”‡ ØªØ­Ø°ÙŠØ± Ø±Ù‚Ù… (${warnCount}/3)
â¬£â”â”â”ã€˜ğŸ¥· Ù…Ø§Ù†Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ğŸ©¸ã€™â”â”—`
        );

        // Ù„Ùˆ ÙˆØµÙ„ 3 ØªØ­Ø°ÙŠØ±Ø§Øª â†’ Ø·Ø±Ø¯
        if (warnCount >= 3) {
          await ctx.kickChatMember(userId);
          warns[chatId][userId] = 0; // ØªØµÙÙŠØ± Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª Ø¨Ø¹Ø¯ Ø§Ù„Ø·Ø±Ø¯
        }
      }
    } catch (e) {
      console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø§Ù†Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·:", e);
    }
  }
});

bot.on('message', async (ctx) => {
  const text = ctx.message.text;
  if (!text) return;

  if (text.match(/(?:https?:\/\/)?(?:www\.)?(?:instagram\.com|instagr\.am)\/[\w\-/?=]+/i)) {
    try {
      const encodedURL = encodeURIComponent(text.trim());
      const apiUrl = `https://the-end-api.vercel.app/home/sections/Download/api/Instagram/ajax?url=${encodedURL}`;
      const response = await axios.get(apiUrl);
      const downloadUrl = response.data.data?.[1]?.url;
      if (!downloadUrl) return ctx.reply('ğŸ©¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Instagram');
      await ctx.replyWithVideo({ url: downloadUrl, caption: 'ğŸ©¸ ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† Instagram!' });
    } catch (e) {
      console.error(e);
      ctx.reply('ğŸ©¸ Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Instagram.');
    }
  }
});

// â›© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø³ÙŠØ·Ø©
global.db = {
  users: {},
  logs: []
};

// ğŸ“œ Ø¯Ø§Ù„Ø© ØªØ³Ø¬Ù‘Ù„ Ø§Ù„Ù„ÙˆØ¬
function saveLog(ctx, isCmd = false) {
  const sender = ctx.from.id;
  const pushname = ctx.from.first_name || ctx.from.username || "Unknown";
  const groupName = ctx.chat.title || "Private Chat";
  const budy = ctx.message?.text || ctx.updateType;

  // âš¡ Ø¥Ø¶Ø§ÙØ© Ù„ÙˆØ¬ Ù„Ù„Ø°Ø§ÙƒØ±Ø©
  const log = {
    type: ctx.chat.type,
    text: budy,
    from: pushname,
    sender: sender,
    group: groupName,
  };
  global.db.logs.push(log);



  if (isCmd && !global.db.users[sender]) {
    global.db.users[sender] = { firstCommand: budy };
    fs.writeFileSync("./user.json", JSON.stringify(global.db.users, null, 2));
  }
}

bot.on("message", (ctx) => {
  const isCmd = ctx.message.text?.startsWith("/") || false;
  saveLog(ctx, isCmd);
});


bot.command("logs", (ctx) => {
  if (global.db.logs.length === 0) {
    return ctx.reply("ğŸ“­ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„ÙˆØ¬Ø§Øª Ù„Ø­Ø¯ Ø¯Ù„ÙˆÙ‚ØªÙŠ.");
  }

  let lastLogs = global.db.logs.slice(-5) // Ø¢Ø®Ø± 5 Ø¨Ø³
    .map((log, i) => `${i + 1}. [${log.type}] ${log.from}: ${log.text}`)
    .join("\n");

  ctx.reply(`ğŸ“œ Ø¢Ø®Ø± Ø§Ù„Ù„ÙˆØ¬Ø§Øª:\n\n${lastLogs}`);
});
if (!global.groupData) {
  global.groupData = {};
}

// Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
bot.on("message", async (ctx) => {
  if (!ctx.chat || ctx.chat.type !== "supergroup") return;

  const chatId = ctx.chat.id;
  const userId = ctx.from.id;

  if (!global.groupData[chatId]) {
    global.groupData[chatId] = {};
  }

  const groupUsers = global.groupData[chatId];

  if (!groupUsers[userId]) {
    groupUsers[userId] = { messagesSent: 0 };
  }

  if (ctx.message.text) {
    groupUsers[userId].messagesSent += 1;
  }
});


bot.launch();
process.once('SIGINT', () => bot.stop('SIGINT'))
process.once('SIGTERM', () => bot.stop('SIGTERM'))
console.log("Tele bot is starting ğŸ©¸!");